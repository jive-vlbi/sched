
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>pckbsr</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>pckbsr</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
 PCKBSR ( PCK, buffer segments for readers )

      SUBROUTINE PCKBSR ( FNAME,
     .                    HANDLE,
     .                    BODY,
     .                    ET,
     .                    DESCR,
     .                    <a href="ident.html">IDENT</a>,
     .                    FOUND   )

      IMPLICIT NONE
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Load and unload PCK binary files for use by the readers.
     Buffer segments for readers.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/pck.html">PCK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     PCK
     FILES
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
      CHARACTER*(*)         FNAME
      INTEGER               HANDLE
      INTEGER               BODY
      DOUBLE PRECISION      ET
      DOUBLE PRECISION      DESCR    ( * )
      CHARACTER*(*)         <a href="ident.html">IDENT</a>
      LOGICAL               FOUND

      INTEGER               FTSIZE
      PARAMETER           ( FTSIZE =   5000 )

      INTEGER               BTSIZE
      PARAMETER           ( BTSIZE =     20 )

      INTEGER               LBPOOL
      PARAMETER           ( LBPOOL =     -5 )

      INTEGER               STSIZE
      PARAMETER           ( STSIZE =   5000 )
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Entry points
     --------  ---  --------------------------------------------------
     FNAME      I   <a href="pcklof.html">PCKLOF</a>
     HANDLE    I/O  <a href="pcklof.html">PCKLOF</a>, <a href="pckuof.html">PCKUOF</a>, <a href="pcksfs.html">PCKSFS</a>
     BODY       I   <a href="pcksfs.html">PCKSFS</a>
     ET         I   <a href="pcksfs.html">PCKSFS</a>
     DESCR      O   <a href="pcksfs.html">PCKSFS</a>
     <a href="ident.html">IDENT</a>      O   <a href="pcksfs.html">PCKSFS</a>
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     FNAME      is the name of an PCK file to be loaded.

     HANDLE     on input is the handle of an PCK file to be
                unloaded.

     BODY       is the NAIF integer code of an ephemeris object,
                typically a solar system body.

     ET         is a time, in seconds past the epoch J2000 TDB.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     HANDLE     on output is the handle of the binary PCK file
                containing a located segment.

     DESCR      is the descriptor of a located segment.

     <a href="ident.html">IDENT</a>      is the identifier of a located segment.

     FOUND      is a logical flag indicating whether a segment meeting
                the search criteria was found. FOUND will have the
                value .TRUE. if an appropriate segment was found during
                the search; it will have the value of .FALSE.
                otherwise. If FOUND has the value .FALSE., then either
                an appropriate segment could not be found in any of the
                loaded files or there were no PCK kernel files loaded
                when the request for a segment was made.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     FTSIZE     is the maximum number of files that may be loaded
                by <a href="pcklof.html">PCKLOF</a> at any given time for use by the PCK readers.

     BTSIZE     is the maximum number of bodies whose segments can be
                buffered by <a href="pcksfs.html">PCKSFS</a>.

     STSIZE     Maximum number of segments that can be buffered at any
                given time by <a href="pcksfs.html">PCKSFS</a>.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1) If <b>PCKBSR</b> is called directly, the error 'SPICE(BOGUSENTRY)'
        is signaled.

     2) See entry points <a href="pcklof.html">PCKLOF</a>, <a href="pckuof.html">PCKUOF</a>, and <a href="pcksfs.html">PCKSFS</a> for exceptions
        specific to them.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     PCK kernel  files are indicated by filename before loading
     (see <a href="pcklof.html">PCKLOF</a>) and handle after loading (all other places).
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     <b>PCKBSR</b> serves as an umbrella, allowing data to be shared by its
     entry points:

        <a href="pcklof.html">PCKLOF</a>       Load PCK binary file.
        <a href="pckuof.html">PCKUOF</a>       Unload PCK binary file.
        <a href="pcksfs.html">PCKSFS</a>       Select file and segment.

     Before a file can be read by the PCK kernel readers, it must be
     loaded by <a href="pcklof.html">PCKLOF</a>, which among other things, calls routines to
     open the specified file.

     Multiple files may be loaded for use simultaneously, and a file
     need only be loaded once to become a potential search target
     for any number of subsequent reads.

     Once a PCK kernel file is loaded and opened, it is assigned a file
     handle, which is used by the calling program to refer to the file
     in all subsequent calls to PCK routines.

     A file may be removed from the list of files searched by using
     <a href="pckuof.html">PCKUOF</a> to unload it.

     <a href="pcksfs.html">PCKSFS</a> performs the search for segments within a file for the
     PCK kernel readers.  It searches through the most recently loaded
     files first.  Within a single file, <a href="pcksfs.html">PCKSFS</a> searches through
     the segments in reverse order, beginning with the last segment in
     the file.  The search stops when the first appropriate segment is
     found or all files and segments have been searched without a
     match.

     <a href="pcksfs.html">PCKSFS</a> buffers information from loaded PCK files to improve access
     time by preventing unnecessary file reads during segment searches.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     Example 1:
     ---------

     Suppose that the data of interest are contained in the file
     THE_MISSION.PCK, and that we want to generate a table containing
     the descriptors of the PCK segments, or a message indicating that
     no segment was found, for various request times. We are interested
     in the data coverage of the segments in the file.

     Let

        PCK_HANDL      be the handle for the mission PCK file.
        HANDLE         be the handle obtained from a segment search. In
                       this example, because there is only a single
                       file, this will always have the same value.
        BODY           be the NAIF ID code for the body of interest.
        BEG_ET         be the beginning epoch for a data table that
                       is generated.
        END_ET         be the ending epoch for a data table that is
                       generated.
        DELTA          be the time step, in seconds, between
                       consecutive times for a data table that is
                       generated.
        ET             be the epoch of interest for a segment
                       search to get a data table entry.
        DESCR ( 5 )    be the descriptor of the PCK segment that is
                       found.
        <a href="ident.html">IDENT</a>          be the identifier of the PCK segment that is
                       found.
        TABLE          be the logical unit for the data table that is
                       generated.
        ENTRY          be a string to hold a formatted PCK segment
                       descriptor which is to be written to the table.
        FOUND          be a logical flag indicating that an
                       appropriate PCK segment has been found.

     The two routine names FORMAT_ENTRY and WRITE_ENTRY are used here
     for purposes of demonstration only. Routines with these names do
     not exist in SPICELIB. FORMAT_ENTRY is used to format a PCK
     segment descriptor into a character string for the table
     generated, and WRITE_ENTRY is used to write an entry to the file.

     The code fragment below loads PCK files and performs searches for
     various epochs, generating a table containing the segment
     descriptors, if found, or a message indicating that a segment
     descriptor was not found.

     C
     C     Load the mission PCK file.
     C
           CALL <a href="pcklof.html">PCKLOF</a> ( 'THE_MISSION.PCK',  PCK_HANDL )

     C
     C     Search for segments using evenly spaced epochs between
     C     BEG_ET and END_ET.
     C
           ET = BEG_ET

           DO WHILE ( ET .LE. END_ET )

     C
     C        Locate the applicable segment (handle and descriptor).
     C
              CALL <a href="pcksfs.html">PCKSFS</a> ( BODY, ET, HANDLE, DESCR, <a href="ident.html">IDENT</a>, FOUND )

              IF ( FOUND ) THEN

                 CALL FORMAT_ENTRY ( DESCR, ENTRY )

              ELSE

                 ENTRY = '***** SEGMENT NOT FOUND *****'

              END IF

              CALL WRITE_ENTRY ( ET, ENTRY, TABLE )

     C
     C        Increment the epoch.
     C
              ET = ET + DELTA

           END DO

     Example 2:
     ---------

     In this example multiple PCK files are loaded and searched for
     segments.

     Let

        PCK_HANDL      be the handle used when loading PCK files.
        HANDLE         be the handle obtained from a segment search. In
                       this example, because there is only a single
                       file, this will always have the same value.
        BODY           be the NAIF ID code for the body of interest.
        ET             be the epoch of interest for a segment
                       search to get a data table entry.
        DESCR ( 5 )    be the descriptor of the PCK segment that is
                       found.
        <a href="ident.html">IDENT</a>          be the identifier of the PCK segment that is
                       found.
        FOUND          be a logical flag indicating that an
                       appropriate PCK segment has been found.

     The code fragment below loads several PCK files and then performs
     a search for an appropriate segment.

     C
     C     Load the PCK files. We can reuse the variable PCK_HANDL
     C     because the handle for the appropriate file is returned by
     C     the search.
     C
           CALL <a href="pcklof.html">PCKLOF</a> ( 'FIRST.PCK',   PCK_HNDL )
           CALL <a href="pcklof.html">PCKLOF</a> ( 'SECOND.PCK',  PCK_HNDL )
           CALL <a href="pcklof.html">PCKLOF</a> ( 'THIRD.PCK',   PCK_HNDL )
           CALL <a href="pcklof.html">PCKLOF</a> ( 'FOURTH.PCK',  PCK_HNDL )
           CALL <a href="pcklof.html">PCKLOF</a> ( 'FIFTH.PCK',   PCK_HNDL )

     C
     C     Do some computation that yields a body and epoch
     C     of interest.
     C
                              .
                              .
                              .
     C
     C     Search for an appropriate segment in the loaded files.
     C

           CALL <a href="pcksfs.html">PCKSFS</a> ( BODY, ET, HANDLE, DESCR, <a href="ident.html">IDENT</a>, FOUND )

           IF ( FOUND ) THEN

              Display results.

           ELSE

              WRITE (*,*) 'Sorry, no segment was found.'

           END IF
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     1) If Fortran I/O errors occur while searching a loaded PCK
        file, the internal state of this suite of routines may
        be corrupted.  It may be possible to correct the state
        by unloading the pertinent PCK files and then re-loading
        them.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman    (JPL)
     K.S. Zukor      (JPL)
     J.M. Lynch      (JPL)
     R.E. Thurman    (JPL)
     W.L. Taber      (JPL)
     B.V. Semenov    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 2.0.0, 17-MAR-2014 (NJB)

        Updated segment pool initialization condition in entry
        point <a href="pcklof.html">PCKLOF</a> so that the pool is initialized only if the file
        table is empty.
     
    SPICELIB Version 1.4.0, 03-JAN-2014 (BVS)(EDW)

        Minor edits to Procedure; clean trailing whitespace.

        Increased FTSIZE (from 1000 to 5000).

        Increased STSIZE (from 100 to 5000).

    SPICELIB Version 1.3.0, 01-MAR-2011 (NJB)

        Bug fix:

          In the <a href="pcksfs.html">PCKSFS</a> 'MAKE ROOM' state, when the suspended activity
          is 'ADD TO FRONT' and no segment table room is available,
          the body table's pointer to the current segment list
          is now set to null. Previously the pointer was allowed to go
          stale.

    SPICELIB Version 1.2.0, 08-SEP-2005 (NJB)

        Updated to remove non-standard use of duplicate arguments
        in MOVED calls in entry points <a href="pckuof.html">PCKUOF</a> and <a href="pcksfs.html">PCKSFS</a>.

    SPICELIB Version 1.1.0, 08-NOV-2001 (NJB)

        Bug fixes:

           1) When a segment list is freed because the entire list
              is contributed by a single PCK file, and the list is
              too large to be buffered, the corresponding body table
              pointer is now set to null.

           2) An algorithm change has eliminated a bug caused by not
              updating the current body index when body table entries
              having empty segment lists were compressed out of the
              body table.  Previously the body table pointer BINDEX
              could go stale after the compression.

           3) When a already loaded kernel is re-opened with <a href="dafopr.html">DAFOPR</a>,
              it now has its link count reset to 1 via a call to
              <a href="dafcls.html">DAFCLS</a>.

           4) The load routine <a href="pcklof.html">PCKLOF</a> now resets all file numbers when
              the next file number reaches INTMAX()-1, thereby
              avoiding arithmetic overflow.

           5) The unload routine <a href="pckuof.html">PCKUOF</a> now calls RETURN() on entry and
              returns if so directed.

           6) In <a href="pcksfs.html">PCKSFS</a>, DAF calls are followed by tests of <a href="failed.html">FAILED</a>()
              in order to ensure that the main state loop terminates.

           7) In <a href="pcksfs.html">PCKSFS</a>, a subscript bound violation in a loop
              termination test was corrected.

        The &quot;re-use interval&quot; feature was introduced to improve speed
        in the case where repeated, consecutive requests are satisified
        by the same segment.  For each body, the associated re-use
        interval marks the time interval containing the previous
        request time for which the previously returned segment provides
        the  highest-priority data available.

        The segment list cost algorithm was modified slightly:
        the contribution of a file search to the cost of a list
        is included only when the file search is completed.  The
        cost of finding the re-use interval is accounted for when
        unbuffered searches are required.

        The file table size has been increased to 1000, in order
        to take advantage of the DAF system's new ability to load
        1000 files.

        Various small updates and corrections were made to the
        comments throughout the file.

        In order to simplify the source code, the in-line singly
        linked list implementation of the segment table has been
        replaced by an implementation relying on the SPICELIB
        doubly linked list routines.

    SPICELIB Version 1.0.0, 16-MAR-1994 (KSZ)

        This differs only slightly from the SPKXXX code.
        The main difference is that the SFS subroutine returns
        FOUND = .FALSE. if no files are found, rather than returning
        an error.</PRE>
<h4>Link to routine PCKBSR source file <a href='../../../src/spicelib/pckbsr.f'>pckbsr.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:42 2014</pre>

</body>
</html>

