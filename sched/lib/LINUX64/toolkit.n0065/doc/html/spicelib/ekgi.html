
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>ekgi</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>ekgi</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
     EKGI  ( EK, get event data, integer )
 
      ENTRY EKGI ( SELIDX, ROW, ELMENT, IDATA, NULL, FOUND )
 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Return an element of an entry in a column of integer
     type in a specified row.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/ek.html">EK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     ASSIGNMENT
     EK
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
     INTEGER               SELIDX
     INTEGER               ROW
     INTEGER               ELMENT
     INTEGER               IDATA
     LOGICAL               NULL
     LOGICAL               FOUND
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Description
     --------  ---  --------------------------------------------------
     SELIDX     I   Index of parent column in SELECT clause.
     ROW        I   Row to fetch from.
     ELMENT     I   Index of element, within column entry, to fetch.
     IDATA      O   Integer element of column entry.
     NULL       O   Flag indicating whether column entry was null.
     FOUND      O   Flag indicating whether column was present in row.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     SELIDX         is the SELECT clause index of the column to
                    fetch from.

     ROW            is the output row containing the entry to fetch
                    from.

     ELMENT         is the index of the element of the column entry
                    to fetch.  The normal range of ELMENT is from 1 to
                    the size of the column's entry, but ELMENT is
                    allowed to exceed the number of elements in the
                    column entry; if it does, FOUND is returned .FALSE.
                    This allows the caller to read data from the column
                    entry in a loop without checking the number of
                    available elements first.

                    Null values in variable-sized columns are
                    considered to have size 1.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     IDATA          is the requested element of the specified column
                    entry.  If the entry is null, IDATA is undefined.

     NULL           is a logical flag indicating whether the entry
                    belonging to the specified column in the specified
                    row is null.

     FOUND          is a logical flag indicating whether the specified
                    element was found.  If the element does not exist,
                    FOUND is returned .FALSE.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1)  If the input argument ELMENT is less than 1, FOUND is returned
         .FALSE., and the error SPICE(INVALIDINDEX) is signaled.
         However, ELMENT is allowed to be greater than the number of
         elements in the specified column entry; this allows the caller
         to read data from the column entry in a loop without checking
         the number of available elements first.  If ELMENT is greater
         than the number of available elements, FOUND is returned
         .FALSE.

     2)  If SELIDX is outside of the range established by the
         last query passed to <a href="eksrch.html">EKSRCH</a>, the error SPICE(INVALIDINDEX)
         will be signaled.

     3)  If the input argument ROW is less than 1 or greater than
         the number of rows matching the query, FOUND is returned
        .FALSE., and the error SPICE(INVALIDINDEX) is signaled.

     4)  If the specified column does not have integer type, the
         error SPICE(INVALIDTYPE) is signaled.

     5)  If this routine is called when no E-kernels have been loaded,
         the error SPICE(NOLOADEDFILES) is signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     See the header of <a href="ekqmgr.html">EKQMGR</a> for a description of files used
     by this routine.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     This routine allows retrieval of data from integer columns.

     This routine returns one element at a time in order to save the
     caller from imposing a limit on the size of the column entries
     that can be handled.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     1)  Suppose the EK table TAB contains the following columns:

            Column name   Data Type   Size
            -----------   ---------   ----
            INT_COL_1     INT         1
            INT_COL_2     INT         VARIABLE
            INT_COL_3     INT         10


         Suppose the query

            QUERY = 'SELECT INT_COL_1 FROM TAB'

         is issued to <a href="ekfind.html">EKFIND</a> via the call

            CALL <a href="ekfind.html">EKFIND</a> ( QUERY, NMROWS, ERROR, ERRMSG )

         To fetch and dump column values from the rows that satisfy the
         query, the loop below could be used.  Note that we don't check
         the FOUND flags returned by <b>EKGI</b> since we know that every
         entry in column INT_COL_1 contains one element.

            C
            C     Since INT_COL_1was the first column selected,
            C     the selection index SELIDX is set to 1.
            C     The column is scalar, so the element index ELTIDX
            C     is set to 1.  The variable NMROWS is the number of
            C     matching rows returned by <a href="ekfind.html">EKFIND</a>.
            C

                  SELIDX = 1
                  ELTIDX = 1

                  DO ROW = 1, NMROWS

                     WRITE (*,*) ' '
                     WRITE (*,*) 'ROW  = ', ROW
                     WRITE (*,*) ' '

            C
            C        Fetch values from column INT_COL_1.
            C
                     CALL <b>EKGI</b> ( SELIDX,  ROW,     ELTIDX,
                                 IVAL,    ISNULL,  FOUND   )

                     IF ( ISNULL ) THEN
                        WRITE (*,*) '&lt;Null&gt;'
                     ELSE
                        WRITE (*,*) IVAL
                     END IF

                  END DO



     2)  Suppose the EK table TAB is as in example 1, and we issue
         the query

            QUERY = 'SELECT INT_COL_1, INT_COL_2, INT_COL_3 FROM TAB'

         to <a href="ekfind.html">EKFIND</a> via the call

            CALL <a href="ekfind.html">EKFIND</a> ( QUERY, NMROWS, ERROR, ERRMSG )

         To fetch and dump column values from the rows that satisfy the
         query, the loop below could be used.  Note that we don't check
         the FOUND flags returned by <b>EKGI</b> since we know in advance how
         many elements are contained in each column entry we fetch.


                  DO ROW = 1, NMROWS

                     WRITE (*,*) ' '
                     WRITE (*,*) 'ROW  = ', ROW
                     WRITE (*,*) ' '

            C
            C        Fetch values from column INT_COL_1.  Since
            C        INT_COL_1 was the first column selected, the
            C        selection index SELIDX is set to 1.
            C
                     SELIDX = 1
                     ELTIDX = 1
                     CALL <b>EKGI</b> ( SELIDX,    ROW,     ELTIDX,
                                 IVALS(1),  ISNULL,  FOUND   )

                     WRITE (*,*) ' '
                     WRITE (*,*) 'COLUMN = INT_COL_1'
                     WRITE (*,*) ' '

                     IF ( ISNULL ) THEN
                        WRITE (*,*) '&lt;Null&gt;'
                     ELSE
                        WRITE (*,*) IVALS(1)
                     END IF

            C
            C        Fetch values from column INT_COL_2 in the current
            C        row.  Since INT_COL_2 contains variable-size array
            C        elements, we call <a href="eknelt.html">EKNELT</a> to determine how many
            C        elements to fetch.
            C
                     SELIDX = 2
                     CALL <a href="eknelt.html">EKNELT</a> ( SELIDX, ROW, NELT )

                     ELTIDX = 1
                     ISNULL = .FALSE.

                     DO WHILE (       ( ELTIDX .LE.  NELT   )
                 .              .AND. (        .NOT. ISNULL )  )

                        CALL <b>EKGI</b> ( SELIDX,         ROW,     ELTIDX,
                                    IVALS(ELTIDX),  ISNULL,  FOUND   )

                        ELTIDX = ELTIDX + 1

            C
            C           If the column entry is null, we'll be kicked
            C           out of this loop after the first iteration.
            C
                     END DO

                     WRITE (*,*) ' '
                     WRITE (*,*) 'COLUMN = INT_COL_2'
                     WRITE (*,*) ' '

                     IF ( ISNULL ) THEN
                        WRITE (*,*) '&lt;Null&gt;'
                     ELSE
                        WRITE (*,*) ( IVALS(I), I = 1, NELT )
                     END IF

            C
            C        Fetch values from column INT_COL_3 in the current
            C        row.  We need not call <a href="eknelt.html">EKNELT</a> since we know how
            C        many elements are in each column entry.
            C
                     SELIDX = 3
                     ELTIDX = 1
                     ISNULL = .FALSE.

                     DO WHILE (       ( ELTIDX .LE.  10    )
                 .              .AND. (        .NOT. ISNULL )  )

                        CALL <b>EKGI</b> ( SELIDX,         ROW,     ELTIDX,
                                    IVALS(ELTIDX),  ISNULL,  FOUND   )

                        ELTIDX = ELTIDX + 1

                     END DO

                     WRITE (*,*) ' '
                     WRITE (*,*) 'COLUMN = INT_COL_3'
                     WRITE (*,*) ' '

                     IF ( ISNULL ) THEN
                        WRITE (*,*) '&lt;Null&gt;'
                     ELSE
                        WRITE (*,*) ( IVALS(I), I = 1, 10 )
                     END IF

                  END DO


     3)  See the $Examples section of the umbrella routine <a href="ekqmgr.html">EKQMGR</a>
         for an example in which the names and data types of the
         columns from which to fetch data are not known in advance.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman   (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 2.0.1, 22-SEP-2004 (EDW)

        Edited 1.1.0 Version entry to not include
        the token used to mark the $Procedure section.

    SPICELIB Version 2.0.0, 16-NOV-2001 (NJB)

        Bug fix:   When an already loaded kernel is opened with <a href="ekopr.html">EKOPR</a>,
        it now has its link count reset to 1 via a call to <a href="ekcls.html">EKCLS</a>.

    SPICELIB Version 1.1.0, 07-JUL-1996 (NJB)

        Redundant CHKIN call removed from SELIDX error check.
        Misspelling of &quot;issued&quot; was fixed.  Previous version line
        was changed from &quot;Beta&quot; to &quot;SPICELIB.&quot;  Header $Procedure
        line was corrected to indicate integer data type.

    SPICELIB Version 1.0.0, 23-OCT-1995 (NJB)</PRE>
<h4>Link to routine EKGI source file <a href='../../../src/spicelib/ekqmgr.f'>ekqmgr.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:16 2014</pre>

</body>
</html>

