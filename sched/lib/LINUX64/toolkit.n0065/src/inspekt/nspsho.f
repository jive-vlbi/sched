C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
 
      SUBROUTINE NSPSHO ( COMMND, ERROR )
 
C
C     Nov 21, 1995
C
C        Removed the show symbol capability since it is now supported
C        by the generic command loop capability.
C
C     Nov 2, 1995
C
C        Added the ability to use templates instead of full
C        names when requesting information about a column.
C
C     August 14, 1995
C
C     Increased the declared length of syntax templates from 64 to 100
C
C     March 2, 1995.
C
C     Corrected error message generated by SHOW COLUMN x  when
C     x is not the name of a known column.
C
      IMPLICIT NONE
 
      CHARACTER*(*)         COMMND
      CHARACTER*(*)         ERROR   ( 2 )
 
 
 
 
 
 
 
C
C     SPICELIB functions
C
      LOGICAL               RETURN
      INTEGER               RTRIM
C
C     Meta/2 Functions
C
      LOGICAL               M2XIST
 
C
C     Interface to the SPICELIB error handling.
C
      LOGICAL               HAVE
 
C
C     Functions/routines that are passed on to someplace else
C
      EXTERNAL              NSPWLN
C
C     Meta/2 syntax definition variables.
C
      INTEGER               LBCELL
      PARAMETER           ( LBCELL = -5 )
 
      INTEGER               WDSIZE
      PARAMETER           ( WDSIZE = 64 )
 
      INTEGER               NUPPER
      PARAMETER           ( NUPPER = 9 )
 
      INTEGER               NSYN
      PARAMETER           ( NSYN   = NUPPER )
 
      INTEGER               SYNLEN
      PARAMETER           ( SYNLEN = 100 )
 
      CHARACTER*(WDSIZE)    SYNKEY ( LBCELL : NSYN )
      INTEGER               SYNPTR ( LBCELL : NSYN )
      CHARACTER*(SYNLEN)    SYNVAL ( LBCELL : NSYN )
C
C     Local Variables
C
      CHARACTER*(1)         BS
      INTEGER               I
      INTEGER               R1
      INTEGER               R2
      INTEGER               ID
      LOGICAL               FIRST
 
 
      INTEGER               LNSIZE
      PARAMETER           ( LNSIZE = 80 )
 
 
      INTEGER               MAXLNS
      PARAMETER           ( MAXLNS = 500 )
 
 
      CHARACTER*(3)         OFFON ( 0 : 2 )
 
      CHARACTER*(LNSIZE)    ALIAS
      CHARACTER*(LNSIZE)    VALUES ( MAXLNS )
      CHARACTER*(LNSIZE)    PAGETL
      CHARACTER*(LNSIZE)    REST
      CHARACTER*(LNSIZE)    FORMAT
      CHARACTER*(LNSIZE)    TFMT
      CHARACTER*(LNSIZE)    DFMT
      CHARACTER*(LNSIZE)    IFMT
      CHARACTER*(LNSIZE)    FILNAM
 
      CHARACTER*(WDSIZE)    COLNAM
      CHARACTER*(WDSIZE)    CMPNTS
      CHARACTER*(WDSIZE)    LITNAM
      CHARACTER*(WDSIZE)    FREQ ( -1:1 )
      CHARACTER*(WDSIZE)    INDEXD
      CHARACTER*(WDSIZE)    JUST
      CHARACTER*(WDSIZE)    LR
      CHARACTER*(WDSIZE)    NAME
      CHARACTER*(WDSIZE)    NAMES ( MAXLNS )
      CHARACTER*(WDSIZE)    MARK
      CHARACTER*(WDSIZE)    TABLE
      CHARACTER*(WDSIZE)    TYPE
      CHARACTER*(WDSIZE)    WORD
      CHARACTER*(WDSIZE)    DQ(2)
 
      INTEGER               ADJUST
      INTEGER               CWIDTH
      INTEGER               LIMIT
      INTEGER               K
      INTEGER               N
      INTEGER               NITEMS
      INTEGER               PAGEHT
      INTEGER               PAGEWD
      INTEGER               TLFREQ
      INTEGER               HDFREQ
      INTEGER               USEID
      INTEGER               NUMFND
      INTEGER               P
 
      LOGICAL               HEADER
      LOGICAL               FOUND
      LOGICAL               STATUS ( 3 )
 
 
 
 
 
C
C     Save everything.
C
      SAVE
 
 
      DATA      FIRST
     .       / .TRUE. /
 
      DATA   (  SYNVAL(I), I=LBCELL,NUPPER )
     .       / ' ', ' ', ' ', ' ', ' ', ' ',
     .         'FORMAT[format] ',
     .         'PAGE[page]',
     .         'KERNELS[kernels]',
     .         'COLUMN[column] #word[colnam] ',
     .         'INDEXES[indexed]',
     .         'SUMMARY[summary]',
     .         'ENVIRONMENT[env]',
     .         'COMMENTS[comment] #word[file]',
     .         'COMMENTS[comment]'  /
 
      DATA      FREQ
     .       / 'No page',
     .         'First page only',
     .         'Every page'       /
 
      DATA      OFFON
     .       / 'OFF',
     .         'ASK',
     .         'ON'    /
 
 
C
C     Standard Spicelib error handling.
C
      IF ( RETURN() ) THEN
         RETURN
      END IF
 
      CALL CHKIN ( 'NSPSHO' )
C
C     On the first pass establish the syntax that this routine
C     is responsible for recognizing.
C
      IF ( FIRST ) THEN
 
         FIRST = .FALSE.
         BS    =  '@'
 
         DO I = 1, NUPPER
            CALL REPLCH ( SYNVAL(I), '#', BS, SYNVAL(I)        )
         END DO
 
         CALL M2INTS ( NSYN, SYNKEY, SYNPTR, SYNVAL )
 
      END IF
 
C
C     See if this command matches a known syntax.  If it doesn't
C     there is no point in hanging around.
C
      CALL M2CHCK ( COMMND, SYNKEY, SYNPTR, SYNVAL, ERROR )
 
      IF ( HAVE(ERROR) ) THEN
         CALL PREFIX ( 'NSPSHO:', 1, ERROR(2) )
         CALL CHKOUT ( 'NSPSHO' )
         RETURN
      END IF
C
C     Determine what the user wants to see.
C
      IF      ( M2XIST('format')  ) THEN
 
         FORMAT = ' '
         MARK   = '(not applicable)'
 
         CALL BBGETC_1 ( 'COPY', 'FORMAT',       N, FORMAT )
         CALL BBGETC_1 ( 'COPY', 'TIMEFMT',      N, TFMT   )
         CALL BBGETC_1 ( 'COPY', 'INTFMT',       N, IFMT   )
         CALL BBGETC_1 ( 'COPY', 'DPFMT',        N, DFMT   )
         CALL BBGETI_1 ( 'COPY', 'REPORTLIMIT',  N, LIMIT  )
         CALL BBGETI_1 ( 'COPY', 'AUTOADJUST',   N, ADJUST )
 
         CALL NEXTWD ( FORMAT, WORD, REST )
 
         IF ( WORD .EQ. 'MARKED' ) THEN
C
C           Put the mark in MARK starting at the second character so
C           that we preserve the quote that's already in the first
C           character.
C
            MARK     = ''''
            CALL BBGETC_1 ( 'COPY', 'FMTMARK', N, MARK(2:) )
            MARK(3:) = ''''
 
         END IF
 
 
         NAMES(1) = ' '
         NAMES(2) = 'Report Format'
         NAMES(3) = 'Report Mark'
         NAMES(4) = 'Default Time     Format'
         NAMES(5) = 'Default Integer  Format'
         NAMES(6) = 'Default Floating Format'
         NAMES(7) = 'Deluge Warning '
         NAMES(8) = 'Auto Adjust '
         NAMES(9) = ' '
 
 
         VALUES(1) = ' '
         VALUES(2) = FORMAT
         VALUES(3) = MARK
         VALUES(4) = TFMT
         VALUES(5) = IFMT
         VALUES(6) = DFMT
 
         CALL INTSTR ( LIMIT, VALUES(7) )
 
         VALUES(8) = OFFON(ADJUST)
     .             // ' (applies only to tabular formats)'
         VALUES(9) = ' '
 
         NITEMS    = 9

         IF (     FORMAT .EQ. 'DELIMITED'
     .       .OR. FORMAT .EQ. 'DELIMITED PRESERVED' ) THEN
            
            CALL BBGETC_1( 'COPY', 'DELIMITER', N, DQ(1) )
            CALL BBGETC_1( 'COPY', 'QUOTE',     N, DQ(2) )
            R1 = RTRIM(DQ(1))
            R2 = RTRIM(DQ(2))
            NAMES(3) = 'Delimiter / Quote '
            VALUES(3) =  DQ(1)(1:R1) // ' / ' // DQ(2)(1:R2)
            
         END IF
         
      ELSE IF ( M2XIST('env')     ) THEN
 
         NAMES(1) = 'Editor'
         NAMES(2) = 'Echoing Commands'
         NAMES(3) = 'Screen Output File'
 
         CALL GETEDT ( VALUES(1) )
         CALL GTECHO ( VALUES(2) )
 
         CALL NSPGST ( 'SAVE', STATUS )
 
         IF ( STATUS(1) .AND. STATUS(2) .AND. .NOT. STATUS(3) ) THEN
            CALL NSPPFL ( 'SAVE', VALUES(3) )
         ELSE
            VALUES(3) = 'No Current Screen Save File'
         END IF
 
 
         NAMES(4) = 'Help Waiting'
         CALL BBGETI_1( 'COPY', 'HELPPROMPT', N, K )
 
         IF ( K .EQ. 0 ) THEN
            VALUES(4) = 'DISABLED'
         ELSE
            VALUES(4) = 'ENABLED'
         END IF
 
         NAMES(5)  = 'Leapseconds Kernel'
 
         CALL BBFNDC_1 ( 'LEAPSECONDS', N )
 
         IF ( N .EQ. 0 ) THEN
            VALUES(5) = '<None Loaded>'
         ELSE
            CALL BBGETC_1 ( 'COPY', 'LEAPSECONDS', N, VALUES(5) )
         END IF
 
         NAMES(6) = 'Spacecraft Clock Kernel'
 
         CALL BBFNDC_1 ( 'SCLK', N )
 
         IF ( N .EQ. 0 ) THEN
            VALUES(6) = '<None Loaded>'
            NITEMS    = 6
         ELSE
            CALL BBGETC_1 ( 'COPY', 'SCLK', N, VALUES(6) )
            DO I = 2, N
               NAMES(5+I) = ' '
            END DO
            NITEMS = 5 + N
 
            IF ( N .GT. 1 ) THEN
               NAMES(6) = 'Spacecraft Clock Kernels'
            END IF
 
         END IF
 
         CALL NSPWLN ( ' ' )
         CALL NSPWLN ( 'Current Inspekt Environment' )
         CALL NSPWLN ( ' ' )
         CALL FLGRPT ( NITEMS, NAMES, VALUES, NSPWLN )
         CALL NSPWLN ( ' ' )
 
         CALL CHKOUT ( 'NSPSHO' )
         RETURN
 
      ELSE IF ( M2XIST('page')    ) THEN
 
         PAGETL = ' '
 
         CALL BBGETI_1 ( 'COPY', 'PAGEHEIGHT',         N, PAGEHT )
         CALL BBGETI_1 ( 'COPY', 'PAGEWIDTH',          N, PAGEWD )
         CALL BBGETI_1 ( 'COPY', 'TITLEFREQUENCY',     N, TLFREQ )
         CALL BBGETI_1 ( 'COPY', 'HEADERFREQUENCY',    N, HDFREQ )
         CALL BBGETC_1 ( 'COPY', 'TITLEJUSTIFICATION', N, JUST   )
         CALL BBGETC_1 ( 'COPY', 'PAGETITLE',          N, PAGETL )
         CALL BBGETC_1 ( 'COPY', 'FORMAT',             N, FORMAT )
 
         HEADER = INDEX ( FORMAT, 'TABULAR' ) .GT. 0
 
         NAMES(1)  = ' '
         VALUES(1) = ' '
 
         NAMES(2)  = 'Page height (rows)'
         NAMES(3)  = 'Page width  (columns)'
         NAMES(4)  = ' '
 
         CALL INTSTR ( PAGEHT, VALUES(2) )
         CALL INTSTR ( PAGEWD, VALUES(3) )
 
         VALUES(4) = ' '
         NITEMS    =  4
C
C        If a title has not been supplied for reports, we don't bother
C        saying anything about whether or not it will be centered and
C        how often it will be displayed.
C
         IF      ( PAGETL .EQ. ' ' ) THEN
 
            NAMES (5) = ' '
            VALUES(5) = '(No title has been supplied)'
            NAMES (6) = ' '
            VALUES(6) = ' '
 
            NITEMS    =  6
 
         ELSE
 
            NAMES (5) = 'Page Title'
            VALUES(5) =  PAGETL
 
            NAMES (6) = 'Title Justification'
            VALUES(6) =  JUST
 
            NAMES (7) = 'Title Appears on'
 
            IF ( TLFREQ .LT. 2 ) THEN
 
               VALUES(7) = FREQ(TLFREQ)
 
            ELSE
 
               VALUES(7) = 'First page and every # page '
     .         //          'thereafter.'
 
               CALL REPMOT ( VALUES(7), '#', TLFREQ, 'L',
     .                       VALUES(7) )
 
            END IF
 
 
            NAMES (8) = ' '
            VALUES(8) = ' '
 
            NITEMS    =  8
 
         END IF
C
C        If a header applies to the current report format, then
C        we might as well state how often it shall be printed.
C
         IF ( HEADER ) THEN
 
            NITEMS        =  NITEMS + 1
            NAMES(NITEMS) = 'Header Appears on'
 
            IF ( HDFREQ .LT. 2 ) THEN
 
               VALUES(NITEMS) = FREQ(HDFREQ)
 
            ELSE
 
               VALUES(NITEMS) = 'First page and every # page '
     .         //               'thereafter.'
 
               CALL REPMOT ( VALUES(NITEMS), '#', HDFREQ, 'L',
     .                       VALUES(NITEMS) )
 
            END IF
 
            NITEMS         =  NITEMS + 1
            NAMES (NITEMS) = ' '
            VALUES(NITEMS) = ' '
 
         END IF
 
      ELSE IF ( M2XIST('kernels') ) THEN
 
         CALL NSPEKS
         CALL CHKOUT ( 'NSPSHO' )
         RETURN
 
      ELSE IF ( M2XIST('comment') ) THEN
 
         FILNAM = ' '
         CALL M2GETC ( 'file', COMMND, FOUND, FILNAM )
         CALL SUFFIX ( '*', 0, FILNAM                )
         CALL NSPEKC ( FILNAM )
         CALL CHKOUT ( 'NSPSHO' )
         RETURN
 
      ELSE IF ( M2XIST('column')  ) THEN
C
C        For now we shall only display the user adjustable
C        items.
C
         CALL M2GETC ( 'colnam', COMMND, FOUND, LITNAM )
         CALL UCASE  ( LITNAM,                  COLNAM )
         CALL NAMXPN ( COLNAM,  'COLUMN',       ERROR  )
 
         IF ( HAVE(ERROR) ) THEN
            CALL PREFIX ( 'NSPSHO:', 1, ERROR(2) )
            CALL CHKOUT ( 'NSPSHO' )
            RETURN
         END IF
C
C        First we see if the requested column is recognized.
C
         CALL CLN2ID ( COLNAM, ID, FOUND )
 
         IF ( FOUND ) THEN
C
C           Yes.  The requested column is recognized so we just
C           need to set a couple of values before further processing.
C
            USEID  = ID
            NUMFND = 1
            NAME   = COLNAM
 
         ELSE
C
C           Ooops.  The column wasn't qualified with a table name.
C           See if the column is in some table.  If it's in just
C           one table, we will show it.  If it's in more than one
C           say so.  If it's not in any of them say so.
C
            NUMFND = 0
 
            CALL CLNUM ( N )
 
            DO I = 1, N
 
               CALL CLNID ( I, ID, FOUND )
 
               IF ( FOUND ) THEN
 
                  CALL CLGAC ( ID, 'COLNAM', NAME )
                  P = MAX( 1, INDEX( NAME, '.' ) )
 
                  IF ( NAME(P:) .EQ. COLNAM ) THEN
                     USEID  = ID
                     NUMFND = NUMFND + 1
                  END IF
 
               END IF
 
            END DO
 
         END IF
 
 
         IF ( NUMFND .EQ. 0 ) THEN
 
            ERROR(1) =  'There is currently no column having the '
     .      //          'name ''#''.  To obtain a list of the columns '
     .      //          'that are available you can use the either of'
     .      //          'the commands: SHOW SUMMARY or SHOW KERNELS'
            CALL REPMC ( ERROR(1), '#', LITNAM, ERROR(1) )
            CALL CHKOUT(     'NSPSHO'  )
            RETURN
 
         ELSE IF ( NUMFND .GT. 1 ) THEN
 
            ERROR(1) = 'The column requested, ''#'', appears in '
     .      //         'more than one table. To specify the '
     .      //         'table and column of interest supply both '
     .      //         'the table and column names separated by '
     .      //         'a period as in ''TABLE.COLUMN''. '
 
 
            CALL REPMC ( ERROR(1), '#', LITNAM, ERROR(1) )
            CALL CHKOUT ( 'NSPSHO' )
            RETURN
 
         ELSE
 
            ID = USEID
            CALL CLGAC ( ID, 'COLNAM', NAME )
 
         END IF
 
         CALL CLGAC ( ID, 'TABLE',         TABLE  )
         CALL CLGAC ( ID, 'JUSTIFICATION', LR     )
         CALL CLGAC ( ID, 'INDEXED',       INDEXD )
         CALL CLGAC ( ID, 'SIZE',          CMPNTS )
         CALL CLGAC ( ID, 'ALIAS',         ALIAS  )
         CALL CLGAI ( ID, 'WIDTH',     N,  CWIDTH )
         CALL CLGAC ( ID, 'TYPE',          TYPE   )
         CALL CLGAC ( ID, 'FORMAT',        FORMAT )
 
         CALL SUFFIX ( '.',   0, TABLE )
         CALL PREFIX ( TABLE, 0, NAME  )
 
         NAMES (1) = ' '
         VALUES(1) = ' '
 
         NAMES (2) = 'Attributes of column: '
         VALUES(2) = NAME
 
 
         NAMES (3) = ' '
         VALUES(3) = ' '
 
         NAMES (4) = 'Type'
         VALUES(4) =  TYPE
 
         NAMES (5) = 'Indexed'
         VALUES(5) =  INDEXD
 
         NAMES (6) = 'Number of Components'
         VALUES(6) =  CMPNTS
 
         NAMES (7)  = ' '
         VALUES(7)  = ' '
 
         NAMES (8)  = 'User Adjustable Attributes'
         VALUES(8)  = ' '
 
         NAMES (9)  = ' '
         VALUES(9)  = ' '
 
         NAMES (10) = 'Column justification'
         VALUES(10) =  LR
 
         NAMES (11) =  'Column width'
         CALL INTSTR ( CWIDTH, VALUES(11) )
 
         NAMES (12)  = 'Column heading'
         VALUES(12)  =  ALIAS
 
         IF (     ( TYPE .EQ. 'TIME'    )
     .       .OR. ( TYPE .EQ. 'INTEGER' )
     .       .OR. ( TYPE .EQ. 'DOUBLE PRECISION') ) THEN
 
            NAMES (13) = 'Format of output'
            VALUES(13) =  FORMAT
            NAMES (14) = ' '
            VALUES(14) = ' '
 
            NITEMS    =  14
         ELSE
 
            NAMES (13) = ' '
            VALUES(13) = ' '
 
            NITEMS    =  13
 
         END IF
 
      ELSE IF ( M2XIST('indexed') ) THEN
 
         CALL CLNUM ( NITEMS )
 
         IF ( NITEMS .EQ. 0 ) THEN
 
            CALL NSPWLN(' ')
            CALL NSPWLN('There are currently no columns. ')
            CALL NSPWLN(' ')
            CALL CHKOUT ( 'NSPSHO' )
            RETURN
 
         END IF
 
         N  = 0
 
         DO I = 1, NITEMS
 
            CALL CLNID ( I,  ID, FOUND            )
            CALL CLGAC ( ID,    'INDEXED', INDEXD )
 
            IF  ( INDEXD .EQ. 'YES' ) THEN
               N  = N + 1
               CALL CLGAC ( ID, 'NAME', NAMES(N) )
            END IF
 
         END DO
 
         CALL SHELLC ( N, NAMES )
 
 
         CALL NSPWLN ( ' '                               )
         CALL NSPWLN ( 'Indexed Columns and their Types' )
         CALL NSPWLN ( ' '                               )
 
         DO I = 1, N
            CALL CLN2ID ( NAMES(I), ID,    FOUND     )
            CALL CLGAC  ( ID,      'TYPE', VALUES(I) )
         END DO
 
         CALL FLGRPT ( N, NAMES, VALUES, NSPWLN )
         CALL NSPWLN ( ' '                      )
         CALL CHKOUT ( 'NSPSHO' )
         RETURN
 
 
 
      ELSE IF ( M2XIST('summary') ) THEN
 
         NAMES (1)  = 'Column'
         VALUES(1)  = 'Description'
 
         NAMES (2) = ' '
         VALUES(2) = ' '
 
         CALL CLNUM ( NITEMS )
 
         IF ( NITEMS .EQ. 0 ) THEN
 
            CALL NSPWLN(' ')
            CALL NSPWLN('There are currently no columns. ')
            CALL NSPWLN(' ')
            CALL CHKOUT ( 'NSPSHO' )
            RETURN
 
         END IF
 
 
         DO I = 1, NITEMS
            CALL CLNID ( I,  ID, FOUND             )
            CALL CLGAC ( ID,    'NAME', NAMES(I+2) )
         END DO
 
         N = NITEMS + 2
C
C        Sort only the items from the 3rd index on.
C
         CALL SHELLC ( NITEMS, NAMES(3) )
 
         DO I = 3, NITEMS+2
            VALUES(I) = ' '
            CALL CLN2ID ( NAMES(I), ID,       FOUND     )
            CALL CLGAC  ( ID,      'TYPE',    VALUES(I) )
 
            CALL CLGAC  ( ID,      'INDEXED', INDEXD    )
 
            IF ( INDEXD .EQ. 'YES' ) THEN
               VALUES(I)(20:) ='(Indexed)'
            END IF
         END DO
 
         CALL NSPWLN ( ' '                               )
         CALL FLGRPT ( N,    NAMES,  VALUES,      NSPWLN )
         CALL NSPWLN ( ' '                               )
 
         CALL CHKOUT ( 'NSPSHO' )
         RETURN
 
      END IF
 
 
C
C     Now all we have to do is ship out these lines.
C
      CALL FLGRPT ( NITEMS, NAMES, VALUES, NSPWLN )
 
      CALL CHKOUT ( 'NSPSHO' )
      RETURN
 
      END
