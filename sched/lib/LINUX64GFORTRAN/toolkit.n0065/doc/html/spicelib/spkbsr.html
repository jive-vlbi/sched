
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>spkbsr</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>spkbsr</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
      SPKBSR ( S/P Kernel, Buffer segments for readers )
 
      SUBROUTINE SPKBSR ( FNAME,
     .                    HANDLE,
     .                    BODY,
     .                    ET,
     .                    DESCR,
     .                    <a href="ident.html">IDENT</a>,
     .                    FOUND   )

      IMPLICIT NONE
 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Load and unload files for use by the readers.  Buffer segments
     for readers.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/spk.html">SPK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     EPHEMERIS
     FILES
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
 
      CHARACTER*(*)         FNAME
      INTEGER               HANDLE
      INTEGER               BODY
      DOUBLE PRECISION      ET
      DOUBLE PRECISION      DESCR    ( * ) 
      CHARACTER*(*)         <a href="ident.html">IDENT</a>
      LOGICAL               FOUND
 
      INTEGER               FTSIZE
      PARAMETER           ( FTSIZE =  5000 )
 
      INTEGER               BTSIZE
      PARAMETER           ( BTSIZE =   200 )
 
      INTEGER               LBPOOL
      PARAMETER           ( LBPOOL =    -5 )

      INTEGER               STSIZE
      PARAMETER           ( STSIZE =  100000 )
      
 
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Entry points
     --------  ---  --------------------------------------------------
     FNAME      I   <a href="spklef.html">SPKLEF</a>
     HANDLE    I/O  <a href="spklef.html">SPKLEF</a>, <a href="spkuef.html">SPKUEF</a>, <a href="spksfs.html">SPKSFS</a>
     BODY       I   <a href="spksfs.html">SPKSFS</a>
     ET         I   <a href="spksfs.html">SPKSFS</a>
     DESCR      O   <a href="spksfs.html">SPKSFS</a>
     <a href="ident.html">IDENT</a>      O   <a href="spksfs.html">SPKSFS</a> 
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     FNAME      is the name of an SPK file to be loaded.

     HANDLE     on input is the handle of an SPK file to be
                unloaded.

     BODY       is the NAIF integer code of an ephemeris object,
                typically a solar system body.

     ET         is a time, in seconds past the epoch J2000 TDB.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     HANDLE     on output is the handle of the S/P-kernel file
                containing a located segment.

     DESCR      is the descriptor of a located segment.

     <a href="ident.html">IDENT</a>      is the identifier of a located segment.

     FOUND      indicates whether a requested segment was found or not.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     FTSIZE     is the maximum number of ephemeris files that can be
                loaded by <a href="spklef.html">SPKLEF</a> at any given time for use by the
                readers.

     BTSIZE     is the maximum number of bodies whose segments can be
                buffered by <a href="spksfs.html">SPKSFS</a>.

     STSIZE     Maximum number of segments that can be buffered at any
                given time by <a href="spksfs.html">SPKSFS</a>.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1) If <b>SPKBSR</b> is called directly, the error 'SPICE(BOGUSENTRY)'
        is signaled.

     2) See entry points <a href="spklef.html">SPKLEF</a>, <a href="spkuef.html">SPKUEF</a>, and <a href="spksfs.html">SPKSFS</a> for exceptions
        specific to them.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     S/P-kernel ephemeris files are indicated by filename before
     loading (see <a href="spklef.html">SPKLEF</a>) and handle after loading (all other places).
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     <b>SPKBSR</b> serves as an umbrella, allowing data to be shared by its
     entry points:

        <a href="spklef.html">SPKLEF</a>       Load ephemeris file.
        <a href="spkuef.html">SPKUEF</a>       Unload ephemeris file.
        <a href="spksfs.html">SPKSFS</a>       Select file and segment.

     Before a file can be read by the S/P-kernel readers, it must be
     loaded by <a href="spklef.html">SPKLEF</a>, which among other things, loads the file into
     the DAF system.

     Up to FTSIZE files may be loaded for use simultaneously, and a 
     file only has to be loaded once to become a potential search 
     target for any number of subsequent reads.

     Once an SPK file has been loaded, it is assigned a file
     handle, which is used to keep track of the file internally, 
     and which is used by the calling program to refer to the file 
     in all subsequent calls to SPK routines.

     A file may be removed from the list of files for potential
     searching by unloading it via a call to <a href="spkuef.html">SPKUEF</a>.

     <a href="spksfs.html">SPKSFS</a> performs the search for segments within a file for the
     S/P-kernel readers.  It searches through last-loaded files first.
     Within a single file, it searches through last-inserted segments
     first, thus assuming that &quot;newest data is best&quot;.

     Information on loaded files is used by <a href="spksfs.html">SPKSFS</a> to manage a buffer
     of saved segment descriptors and identifiers to speed up access
     time without having to necessarily perform file reads.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     Suppose that ephemeris data for the Mars Global Surveyor 
     spacecraft relative to Mars are contained in three separate files:
     PREDICT.SPK contains complete predict ephemeris data for several
     successive orbits, and UPDATE_1.SPK and UPDATE_2.SPK contain two
     separate updates to selected intervals within those orbits, based
     on altimeter fits.

     In the following example, states of the spacecraft are computed
     in two different ways:

     First, the predict file and one of the update files are both
     loaded and states are requested for regular intervals within
     the orbits. The update file is searched through first, and if no
     data for the requested time is available, the predict file is
     used.

     Then, the first update file is unloaded, the second update file
     is loaded, and the same requests are made as above.

     Throughout the two searches, a table is written which contains
     the state (position and velocity) of the spacecraft, and the
     file from which the data came, if such data was found, and an
     error message otherwise.

     It is assumed that the beginning and ending ephemeris times
     (BEG_ET, END_ET) for the entire span have already been
     initialized, along with the step-size for each measurement
     (DELTA). The two routines WRITE_TABLE and WRITE_ERROR do not
     exist in SPICELIB.


           INTEGER               PRED_HNDL
           INTEGER               UPD1_HNDL
           INTEGER               UPD2_HNDL
           INTEGER               HANDLE
           INTEGER               BODY
           INTEGER               CENTER

           DOUBLE PRECISION      BEG_ET
           DOUBLE PRECISION      END_ET
           DOUBLE PRECISION      DELTA
           DOUBLE PRECISION      ET
           DOUBLE PRECISION      DESCR ( 5 )
           DOUBLE PRECISION      STATE ( 6 )

           CHARACTER*40          <a href="ident.html">IDENT</a>
           CHARACTER*25          FNAME

           LOGICAL               FOUND

     C
     C     Load the predict file and the first update file.  Since
     C     last-loaded files get searched first, we want to load the
     C     update file second.
     C
           CALL <a href="spklef.html">SPKLEF</a> ( 'PREDICT.SPK',  PRED_HNDL )
           CALL <a href="spklef.html">SPKLEF</a> ( 'UPDATE_1.SPK', UPD1_HNDL )

     C
     C     NAIF code for the Mars Global Surveyor spacecraft is -94.
     C
           BODY = -94

     C
     C     Compute states for regular intervals between BEG_ET and
     C     END_ET.
     C
           ET = BEG_ET

           DO WHILE ( ET .LE. END_ET )

     C
     C        Locate the applicable segment (handle and descriptor).
     C
              CALL <a href="spksfs.html">SPKSFS</a> ( BODY, ET, HANDLE, DESCR, <a href="ident.html">IDENT</a>, FOUND )

              IF ( FOUND ) THEN
     C
     C           Evaluate the state, get the name of the file from
     C           whence the data came, and write the results to the
     C           table.
     C
                 CALL <a href="spkpv.html">SPKPV</a> ( HANDLE, DESCR, ET, 'J2000', STATE,
             .                CENTER )

                 CALL <a href="dafhfn.html">DAFHFN</a> ( HANDLE, FNAME )

                 CALL WRITE_TABLE ( ET, STATE, FNAME )

              ELSE

                 CALL WRITE_ERROR ( ET )

              END IF

     C
     C        The next time.
     C
              ET = ET + DELTA

           END DO

     C
     C     Unload the first update file, load the second, and do
     C     everything over again.  Since the original file stays
     C     loaded, the update file once again gets searched first.
     C
           CALL <a href="spkuef.html">SPKUEF</a> (  UPD1_HNDL )
           CALL <a href="spklef.html">SPKLEF</a> ( 'UPDATE_2.SPK', UPD2_HNDL )

           ET = BEG_ET

           DO WHILE ( ET .LE. END_ET )

     C
     C        Locate the applicable segment.
     C
              CALL <a href="spksfs.html">SPKSFS</a> ( BODY, ET, HANDLE, DESCR, <a href="ident.html">IDENT</a>, FOUND )

              IF ( FOUND ) THEN
     C
     C           Evaluate the state, get the name of the file from
     C           whence the data came, and write the results to the
     C           table.
     C
                 CALL <a href="spkpv.html">SPKPV</a> ( HANDLE, DESCR, ET, 'J2000', STATE,
             .                CENTER )

                 CALL <a href="dafhfn.html">DAFHFN</a> ( HANDLE, FNAME )

                 CALL WRITE_TABLE ( ET, STATE, FNAME )

              ELSE

                 CALL WRITE_ERROR ( ET )

              END IF

     C
     C        The next time.
     C
              ET = ET + DELTA

           END DO
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     1) If Fortran I/O errors occur while searching a loaded SPK
        file, the internal state of this suite of routines may
        be corrupted.  It may be possible to correct the state
        by unloading the pertinent SPK files and then re-loading
        them.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     SPK Required Reading.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman    (JPL)
     J.M. Lynch      (JPL)
     R.E. Thurman    (JPL)
     W.L. Taber      (JPL)
     B.V. Semenov    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 6.0.0, 17-MAR-2014 (NJB)

        Updated segment pool initialization condition in entry
        point <a href="spklef.html">SPKLEF</a> so that the pool is initialized only if the file
        table is empty.

    SPICELIB Version 5.4.0, 13-JUN-2013 (BVS)

        Increased FTSIZE (from 1000 to 5000).

        Increased STSIZE (from 50000 to 100000).

    SPICELIB Version 5.3.0, 01-MAR-2011 (NJB)

        Bug fix: 

          In the <a href="spksfs.html">SPKSFS</a> 'MAKE ROOM' state, when the suspended activity
          is 'ADD TO FRONT' and no segment table room is available,
          the body table's pointer to the current segment list
          is now set to null. Previously the pointer was allowed to go
          stale.

    SPICELIB Version 5.2.0, 07-APR-2010 (NJB)

        Increased segment table buffer size to 50000 entries.

    SPICELIB Version 5.1.0, 08-SEP-2005 (NJB)

        Updated to remove non-standard use of duplicate arguments
        in MOVED calls in entry points <a href="spkuef.html">SPKUEF</a> and <a href="spksfs.html">SPKSFS</a>.     

        Increased segment table buffer size to 30000 entries.

    SPICELIB Version 5.0.0, 21-FEB-2003 (NJB)

        Increased segment table buffer size to 10000 entries.

    SPICELIB Version 4.0.0, 28-DEC-2001 (NJB)

        Bug fixes:  
          
           1) When a segment list is freed because the entire list 
              is contributed by a single SPK file, and the list is
              too large to be buffered, the corresponding body table
              pointer is now set to null.  

           2) An algorithm change has eliminated a bug caused by not 
              updating the current body index when body table entries 
              having empty segment lists were compressed out of the 
              body table.  Previously the body table pointer BINDEX
              could go stale after the compression.

           3) When a already loaded kernel is re-opened with <a href="dafopr.html">DAFOPR</a>, 
              it now has its link count reset to 1 via a call to 
              <a href="dafcls.html">DAFCLS</a>.

           4) The load routine <a href="spklef.html">SPKLEF</a> now resets all file numbers when 
              the next file number reaches INTMAX()-1, thereby 
              avoiding arithmetic overflow.  

           5) The unload routine <a href="spkuef.html">SPKUEF</a> now calls RETURN() on entry and
              returns if so directed.

           6) In <a href="spksfs.html">SPKSFS</a>, DAF calls are followed by tests of <a href="failed.html">FAILED</a>()
              in order to ensure that the main state loop terminates.

           7) In <a href="spksfs.html">SPKSFS</a>, a subscript bound violation in a loop
              termination test was corrected.

        The &quot;re-use interval&quot; feature was introduced to improve speed 
        in the case where repeated, consecutive requests are satisified
        by the same segment.

        The segment list cost algorithm was modified slightly:  
        the contribution of a file search to the cost of a list
        is included only when the file search is completed.  The
        cost of finding the re-use interval is accounted for when
        unbuffered searches are required.

        The file table size has been increased to 1000, in order
        to take advantage of the DAF system's new ability to load 
        1000 files.

        The body table size has been increased to 200 in order to
        decrease the chance of thrashing due to swapping segment
        lists for different bodies.
     
        Various small updates and corrections were made to the 
        comments throughout the file.

    SPICELIB Version 3.0.0, 14-AUG-1995 (WLT)

        An interim fix to a bug in <b>SPKBSR</b> was made.  The parameters
        STSIZE and BTSIZE were increased to be much larger than before
        (from 100 and 20 to 2000 and 40 respectively).  This should
        keep the boundary errors experienced by Cassini users from
        occurring again.  Version 4.0.0 with a real fix to the
        boundary problem should be installed in SPICELIB by 
        October 1995

    SPICELIB Version 2.0.0, 25-NOV-1992 (JML)

     1) When loading a file, <a href="spklef.html">SPKLEF</a> now checks if the file table is
        full only after determining that the file is not currently
        loaded. Previously, if the file table was full and an attempt
        was made to reload a file, an error was signaled. A new
        exception was added as a result of this change.

     2) A bug in the way that <a href="spklef.html">SPKLEF</a> and <a href="spkuef.html">SPKUEF</a> clean up the body
        tables after a file is unloaded was fixed.

     3) Variable declarations were added to the example program
        so that it can now be compiled.

     4) A cut and paste error in the description of the segment
        table was corrected.

    SPICELIB Version 1.0.3, 10-MAR-1992 (WLT)

        Comment section for permuted index source lines was added
        following the header.

    SPICELIB Version 1.0.2, 9-SEP-1991 (HAN)

        The declaraion of the variable STATE in the Examples section
        was changed from a 3 dimensional vector to a 6 dimensional
        vector, and the term state was specified to be the position
        and velocity of a body relative to another body.

    SPICELIB Version 1.0.1, 22-MAR-1990 (HAN)

        Literature references added to the header.

    SPICELIB Version 1.0.0, 31-JAN-1990 (RET)</PRE>
<h4>Link to routine SPKBSR source file <a href='../../../src/spicelib/spkbsr.f'>spkbsr.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:25:02 2014</pre>

</body>
</html>

