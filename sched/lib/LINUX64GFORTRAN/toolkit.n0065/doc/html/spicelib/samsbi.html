
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>samsbi</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>samsbi</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
      SAMSBI (Same substrings, case insensitive)
 
      LOGICAL FUNCTION SAMSBI ( STR1, B1, E1,  STR2, B2, E2 )
 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Determine whether or not two substrings are the same up to
     case.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
      None.
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
       UTILITY
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
 
      IMPLICIT NONE
 
      CHARACTER*(*)         STR1
      INTEGER               B1
      INTEGER               E1
      CHARACTER*(*)         STR2
      INTEGER               B2
      INTEGER               E2
 
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  -------------------------------------------------
     STR1       I   A string
     B1         I   Beginning of a substring in STR1
     E1         I   End of s substring in STR1
     STR2       I   A second string
     B2         I   The beginning of a substring in STR2
     E2         I   The end  of s substring in STR2

     The function returns .TRUE. if the substrings are identical
     up to case.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     STR1       is a character string

     B1         are integers giving the beginning and ending of a
     E1         subsstring in STR1

     STR2       is a character string

     B2         are integers giving the beginning and ending of a
     E2         subsstring in STR2
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     The function returns TRUE if the two substrings STR(B1:E1) and
     STR(B2:E2) have the same length and the same characters up to
     case.

     If any of the indices B1, E1, B2, E2 are out of range or out
     of order the function returns FALSE.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
      None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     Error free.

     1) If any of the B1, E1, B2, E2 are out of range or if an
        ending substring index is before a beginning substring
        index, the function returns false.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
      None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     This routine is a macro for comparing two substrings of
     strings and handles all of the bounds checking to avoid
     out of range errors with string indices.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     Suppose a string contains a number of occurrences of some
     particular substring in sequence and that you need to locate
     the first character that is out of this sequence or the
     end of the string.

     If one ignores boundary constraints this can easily be
     coded as shown here:  We assume the particular substring is

     '/beg'

        B = 1
        E = B + LEN('/beg' )

        DO WHILE (       E           .LE. LEN(STR)
                   .AND. STRING(B:E) .EQ. '/beg' )

           B = B + LEN('/beg')
           E = E + LEN('/beg')

        END DO

        IF ( B .LT. LEN(STR) ) THEN

           we've found the start of a substring of interest

        ELSE

           there is no substring to find.

        END IF

     Unfortunately, you can't rely upon FORTRAN to check the boundary
     condition: E .LE. LEN(STR) and skip the second test if the first
     condition if false.  As a result you can get an out of range
     error.

     Instead you could code:

     B = 1
     E = B + LEN('/beg')

     IF ( E .LE. LEN(STR) ) THEN
        ALIKE = STRINB(B:E) .EQ. '/beg'
     ELSE
        ALIKE = .FALSE.
     END IF

     DO WHILE ( ALIKE )

           B = B + LEN('/beg')
           E = E + LEN('/beg')

        IF ( E .LE. LEN(STR) ) THEN
           ALIKE = STRINB(B:E) .EQ. '/beg'
        ELSE
           ALIKE = .FALSE.
        END IF

     END DO


     However, this is code is far more effort.  Using this routine
     you can make a much simpler block of code.

     B = 1
     E = B + LEN('/beg' )

     DO WHILE ( <b>SAMSBI</b>(STR,B,E, '/beg',1,4 ) )

        B = B + LEN('/beg')
        E = E + LEN('/beg')

     END DO
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
      None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
      W.L. Taber      (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.0, 31-MAR-1995 (WLT)</PRE>
<h4>Link to routine SAMSBI source file <a href='../../../src/spicelib/samsbi.f'>samsbi.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:53 2014</pre>

</body>
</html>

