
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>pxfrm2</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>pxfrm2</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
      PXFRM2 ( Position Transform Matrix, Different Epochs )
 
      SUBROUTINE PXFRM2 ( FROM, TO, ETFROM, ETTO, ROTATE  )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Return the 3x3 matrix that transforms position vectors from one
     specified frame at a specified epoch to another specified
     frame at another specified epoch.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     
     <a href="../req/frames.html">FRAMES</a> 
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     FRAMES
     TRANSFORM
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
 
      IMPLICIT NONE

      INCLUDE               'zzctr.inc'

      CHARACTER*(*)         FROM
      CHARACTER*(*)         TO
      DOUBLE PRECISION      ETFROM
      DOUBLE PRECISION      ETTO
      DOUBLE PRECISION      ROTATE  ( 3, 3 )
 
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  --------------------------------------------------
     FROM       I   Name of the frame to transform from.
     TO         I   Name of the frame to transform to.
     ETFROM     I   Evaluation time of 'FROM' frame.
     ETTO       I   Evaluation time of 'TO' frame.
     ROTATE     O   A position transformation matrix from
                    frame FROM to frame TO.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     FROM       is the name of a reference frame recognized by 
                SPICELIB that corresponds to the input ETFROM.


     TO         is the name of a reference frame recognized by
                SPICELIB that corresponds to the desired output
                at ETTO.


     ETFROM     is the epoch in ephemeris seconds past the epoch
                of J2000 (TDB) corresponding to the FROM reference 
                frame.


     ETTO       is the epoch in ephemeris seconds past the epoch
                of J2000 (TDB) that corresponds to the TO reference
                frame.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     ROTATE     is the transformation matrix that relates the reference
                frame FROM at epoch ETFROM to the frame TO at epoch 
                ETTO.

                If (x, y, z) is a position relative to the reference
                frame FROM at time ETFROM then the vector ( x', y',
                z') is the same position relative to the frame TO at
                epoch ETTO. Here the vector ( x', y', z' ) is defined
                by the equation:

                   -   -       -        -     -  -
                  | x'  |     |          |   | x  |
                  | y'  |  =  |  ROTATE  |   | y  |
                  | z'  |     |          |   | z  |
                   -   -       -        -     -  -
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.    
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1)  If sufficient information has not been supplied via loaded
         SPICE kernels to compute the transformation between the
         two frames, the error will be diagnosed by a routine
         in the call tree to this routine.

     2)  If either frame FROM or TO is not recognized the error
         'SPICE(UNKNOWNFRAME)' will be signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     Appropriate kernels must be loaded by the calling program before
     this routine is called.  Kernels that may be required include
     SPK files, PCK files, frame kernels, C-kernels, and SCLK kernels.

     Such kernel data are normally loaded once per program
     run, NOT every time this routine is called. 
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     <b>PXFRM2</b> is most commonly used to transform a position between
     time-dependant reference frames.  

     For more examples of where to use <b>PXFRM2</b>, please see:
            
           <a href="sincpt.html">SINCPT</a>
           <a href="surfpt.html">SURFPT</a>
           <a href="subslr.html">SUBSLR</a>
           <a href="ilumin.html">ILUMIN</a>
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for these examples may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine 
     specific arithmetic implementation. 

     1) Suppose that MGS has taken a picture of Mars at time ETREC with
        the MOC narrow angle camera. We want to know the latitude and
        longitude associated with two pixels projected to Mars'
        surface: the boresight and one along the boundary of the
        field of view (FOV). Due to light time, the photons taken in
        the picture left Mars at time ETEMIT, when Mars was at a
        different state than at time ETREC.

        In order to solve this problem, we could use the <a href="sincpt.html">SINCPT</a>
        routine for both pixels, but this would be slow.  Instead, we
        will assume that the light time for each pixel is the same. We
        will call <a href="sincpt.html">SINCPT</a> once to get the light time and surface point
        associated with the boresight. Then, we will rotate one of the
        FOV boundary vectors from the camera frame at ETREC to the
        body-fixed Mars frame at ETEMIT, and call the faster routine
        <a href="surfpt.html">SURFPT</a> to retrieve the surface point for one of the FOV
        boundary vectors.

        This example problem could be extended to find the latitude
        and longitude associated with every pixel in an instrument's
        field of view, but this example is simplified to only solve
        for two pixels:  the boresight and one along the boundary of
        the field of view.

        Assumptions:

           1)  The light times from the surface points in the camera's
               field of view to the camera are equal.

           2)  The camera offset from the center of gravity of the 
               spacecraft is zero. If the data are more accurate
               and precise, this assumption can be easily discarded.

           3)  An ellipsoid shape model for the target body is 
               sufficient.

           4)  The boundary field of view vector returned from <a href="getfov.html">GETFOV</a>
               is associated with a boundary field of view pixel. If
               this example were extended to include a geometric camera
               model, this assumption would not be needed since the
               direction vectors associated with each pixel would be
               calculated from the geometric camera model.

        Use the meta-kernel shown below to load the required SPICE
        kernels.

           KPL/MK

           File name: mgs_ex.tm
           
           This is the meta-kernel file for the example problem for
           the subroutine <b>PXFRM2</b>. These kernel files can be found in
           the NAIF archives.

           In order for an application to use this meta-kernel, the
           kernels referenced here must be present in the user's
           current working directory.
           
           The names and contents of the kernels referenced
           by this meta-kernel are as follows:

              File name                     Contents
              ---------                     --------
              de421.bsp                     Planetary ephemeris
              pck00009.tpc                  Planet orientation and
                                            radii
              naif0009.tls                  Leapseconds
              mgs_ext12_ipng_mgs95j.bsp     MGS ephemeris
              mgs_moc_v20.ti                MGS MOC instrument
                                            parameters
              mgs_sclkscet_00061.tsc        MGS SCLK coefficients
              mgs_sc_ext12.bc               MGS s/c bus attitude
                   
           \begindata

           KERNELS_TO_LOAD = ( 'de421.bsp',
                               'pck00009.tpc',
                               'naif0009.tls',
                               'mgs_ext12_ipng_mgs95j.bsp',
                               'mgs_moc_v20.ti',
                               'mgs_sclkscet_00061.tsc',
                               'mgs_sc_ext12.bc' )

           \begintext

           End of meta-kernel.


       Example code begins here.

           PROGRAM EX_PXFRM2
           IMPLICIT NONE
     C
     C     SPICELIB functions
     C
     C     Degrees per radian
     C
           DOUBLE PRECISION      <a href="dpr.html">DPR</a>
     C
     C     Distance between two vectors
     C
           DOUBLE PRECISION      <a href="vdist.html">VDIST</a>
     C
     C     Local parameters
     C
     C     ABCORR is the desired light time and stellar
     C     aberration correction setting.
     C
           CHARACTER*(*)         ABCORR
           PARAMETER           ( ABCORR = 'CN+S' )
     C
     C     MGS_MOC_NA is the name of the camera that took
     C     the picture being analyzed.
     C
           CHARACTER*(*)         CAMERA
           PARAMETER           ( CAMERA = 'MGS_MOC_NA' )

           CHARACTER*(*)         METAKR
           PARAMETER           ( METAKR = 'mgs_ex.tm' )

           INTEGER               FRNMLN
           PARAMETER           ( FRNMLN = 32 )

           INTEGER               NCORNR
           PARAMETER           ( NCORNR = 4 )

           INTEGER               SHPLEN
           PARAMETER           ( SHPLEN = 80 )

     C
     C     Local variables
     C
     C     OBSREF is the observer reference frame on MGS.
     C
           CHARACTER*(FRNMLN)    OBSREF
           CHARACTER*(SHPLEN)    SHAPE

           DOUBLE PRECISION      BOUNDS ( 3, NCORNR )
           DOUBLE PRECISION      BNDVEC ( 3 )
           DOUBLE PRECISION      BSIGHT ( 3 )
     C
     C     ETEMIT is the time at which the photons were
     C     emitted from Mars.  ETREC is the time at
     C     which the picture was taken by MGS.
     C
           DOUBLE PRECISION      ETREC
           DOUBLE PRECISION      ETEMIT
           DOUBLE PRECISION      DIST
     C
     C     LAT and LON are the latitude and longitude
     C     associated with one of the boundary FOV vectors.
     C
           DOUBLE PRECISION      LAT
           DOUBLE PRECISION      LON
     C
     C     PMGSMR is the opposite of the apparent position of
     C     Mars with respect to MGS.
     C
           DOUBLE PRECISION      PMGSMR ( 3 )
     C
     C     RADII is a vector of the semi-axes of Mars.
     C
           DOUBLE PRECISION      RADII  ( 3 )
           DOUBLE PRECISION      RADIUS
     C
     C     ROTATE is a position transformation matrix from
     C     the camera frame at ETREC to the IAU_MARS frame
     C     at ETEMIT.
     C
           DOUBLE PRECISION      ROTATE ( 3, 3 )
           DOUBLE PRECISION      SPOINT ( 3 )
           DOUBLE PRECISION      SRFVEC ( 3 )
           DOUBLE PRECISION      TMP    ( 3 )

           INTEGER               CAMID
           INTEGER               DIM
           INTEGER               N

           LOGICAL               FOUND
     C
     C     ------------------ Program Setup ------------------
     C
     C     Load kernel files via the meta-kernel.
     C
           CALL <a href="furnsh.html">FURNSH</a> ( METAKR )
     C
     C     Convert the time the picture was taken from a
     C     UTC time string to seconds past J2000, TDB.
     C
           CALL <a href="str2et.html">STR2ET</a> ( '2003 OCT 13 06:00:00 UTC', ETREC )
     C
     C     Assume the one-way light times from different
     C     surface points on Mars to MGS within the camera's
     C     FOV are equal. This means the photons that make
     C     up different pixels were all emitted from Mars at
     C     ETEMIT and received by the MGS MOC camera at ETREC. It
     C     would be slow to process images using <a href="sincpt.html">SINCPT</a> for every
     C     pixel. Instead, we will use <a href="sincpt.html">SINCPT</a> on the
     C     boresight pixel and use <a href="surfpt.html">SURFPT</a> for one of the FOV
     C     boundary pixels. If this example program were extended
     C     to include all of the camera's pixels, <a href="surfpt.html">SURFPT</a> would
     C     be used for the remaining pixels.
     C
     C     Get the MGS MOC Narrow angle camera (MGS_MOC_NA)
     C     ID code. Then look up the field of view (FOV)
     C     parameters by calling <a href="getfov.html">GETFOV</a>.
     C
           CALL <a href="bodn2c.html">BODN2C</a> ( CAMERA, CAMID, FOUND )

           IF ( .NOT. FOUND ) THEN

              CALL <a href="setmsg.html">SETMSG</a> ( 'Could not find ID code for ' //
          .                 'instrument #.'               )
              CALL <a href="errch.html">ERRCH</a>  ( '#', CAMERA                   )
              CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(NOTRANSLATION)'        )

           END IF
     C
     C     <a href="getfov.html">GETFOV</a> will return the name of the camera-fixed frame
     C     in the string OBSREF, the camera boresight vector in
     C     the array BSIGHT, and the FOV corner vectors in the
     C     array BOUNDS.
     C
           CALL <a href="getfov.html">GETFOV</a> ( CAMID,  NCORNR, SHAPE, OBSREF,
          .              BSIGHT, N,      BOUNDS       )

           WRITE (*,*) 'Observation Reference frame:  ', OBSREF

     C
     C     ----------- Boresight Surface Intercept -----------
     C
     C     Retrieve the time, surface intercept point, and vector
     C     from MGS to the boresight surface intercept point
     C     in IAU_MARS coordinates.
     C
           CALL <a href="sincpt.html">SINCPT</a> ( 'ELLIPSOID', 'MARS',  ETREC, 'IAU_MARS',
          .               ABCORR,     'MGS',   OBSREF, BSIGHT,
          .               SPOINT,      ETEMIT, SRFVEC, FOUND  )

           IF ( .NOT. FOUND ) THEN

              CALL <a href="setmsg.html">SETMSG</a> ( 'Intercept not found for the ' //
          .                 'boresight vector.'  )
              CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(NOINTERCEPT)' )

           END IF
     C
     C     Convert the intersection point of the boresight
     C     vector and Mars from rectangular into latitudinal
     C     coordinates. Convert radians to degrees.
     C
           CALL <a href="reclat.html">RECLAT</a> ( SPOINT, RADIUS, LON, LAT )

           LON = LON * <a href="dpr.html">DPR</a> ()
           LAT = LAT * <a href="dpr.html">DPR</a> ()

           WRITE (*,*) 'Boresight surface intercept ' //
          .            'coordinates:'
           WRITE (*,*) '   Radius    (km) :  ', RADIUS
           WRITE (*,*) '   Latitude  (deg):  ', LAT
           WRITE (*,*) '   Longitude (deg):  ', LON

     C
     C     --------- A Boundary FOV Surface Intercept (<a href="surfpt.html">SURFPT</a>) ------
     C
     C     Now we will transform one of the FOV corner vectors into the
     C     IAU_MARS frame so the surface intercept point can be
     C     calculated using <a href="surfpt.html">SURFPT</a>, which is faster than <a href="subpnt.html">SUBPNT</a>.
     C
     C     If this example program were extended to include all
     C     of the pixels in the camera's FOV, a few steps, such as
     C     finding the rotation matrix from the camera frame to the
     C     IAU_MARS frame, looking up the radii values for Mars,
     C     and finding the position of MGS with respect to Mars could
     C     be done once and used for every pixel.
     C
     C     Find the rotation matrix from the ray's reference
     C     frame at the time the photons were received (ETREC)
     C     to IAU_MARS at the time the photons were emitted
     C     (ETEMIT).
     C
           CALL <b>PXFRM2</b> ( OBSREF, 'IAU_MARS', ETREC, ETEMIT, ROTATE )

     C
     C     Look up the radii values for Mars.
     C
           CALL <a href="bodvrd.html">BODVRD</a> ( 'MARS', 'RADII', 3, DIM, RADII )

     C
     C     Find the position of the center of Mars with respect
     C     to MGS.  The position of the observer with respect
     C     to Mars is required for the call to <a href="surfpt.html">SURFPT</a>.  Note:
     C     the apparent position of MGS with respect to Mars is
     C     not the same as the negative of Mars with respect to MGS.
     C
           CALL <a href="vsub.html">VSUB</a>   ( SPOINT, SRFVEC, PMGSMR )

     C
     C     The selected boundary FOV pixel must be rotated into the
     C     IAU_MARS reference frame.
     C
           CALL <a href="mxv.html">MXV</a>    ( ROTATE, BOUNDS(1,1), BNDVEC )

     C
     C     Calculate the surface point of the boundary FOV
     C     vector.
     C
           CALL <a href="surfpt.html">SURFPT</a> ( PMGSMR,   BNDVEC, RADII(1), RADII(2),
          .              RADII(3), SPOINT, FOUND )

           IF ( .NOT. FOUND ) THEN

              CALL <a href="setmsg.html">SETMSG</a> ( 'Could not calculate surface point.')
              CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(NOTFOUND)' )

           END IF

           CALL <a href="vequ.html">VEQU</a>   ( SPOINT, TMP )
     C
     C     Convert the intersection point of the boundary
     C     FOV vector and Mars from rectangular into
     C     latitudinal coordinates. Convert radians
     C     to degrees.
     C
           CALL <a href="reclat.html">RECLAT</a> ( SPOINT, RADIUS, LON, LAT )

           LON = LON * <a href="dpr.html">DPR</a> ()
           LAT = LAT * <a href="dpr.html">DPR</a> ()

           WRITE (*,*) 'Boundary vector surface intercept ' //
          .               'coordinates using <a href="surfpt.html">SURFPT</a>:'
           WRITE (*,*) '   Radius    (km) :  ', RADIUS
           WRITE (*,*) '   Latitude  (deg):  ', LAT
           WRITE (*,*) '   Longitude (deg):  ', LON
           WRITE (*,*) '   Emit time using'
           WRITE (*,*) '   boresight LT(s):  ', ETEMIT

     C
     C     ------ A Boundary FOV Surface Intercept Verification ----
     C
     C     For verification only, we will calculate the surface
     C     intercept coordinates for the selected boundary vector
     C     using <a href="sincpt.html">SINCPT</a> and compare to the faster <a href="surfpt.html">SURFPT</a> method.
     C
           CALL <a href="sincpt.html">SINCPT</a> ( 'ELLIPSOID', 'MARS',  ETREC, 'IAU_MARS',
          .               ABCORR,     'MGS',   OBSREF, BOUNDS(1,1),
          .               SPOINT,      ETEMIT, SRFVEC, FOUND )

           IF ( .NOT. FOUND ) THEN

              CALL <a href="setmsg.html">SETMSG</a> ( 'Intercept not found for the ' //
          .                 'boresight vector.'  )
              CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(NOINTERCEPT)' )

           END IF
     C
     C     Convert the intersection point of the selected boundary
     C     vector and Mars from rectangular into latitudinal
     C     coordinates. Convert radians to degrees.
     C
           CALL <a href="reclat.html">RECLAT</a> ( SPOINT, RADIUS, LON, LAT )

           LON = LON * <a href="dpr.html">DPR</a> ()
           LAT = LAT * <a href="dpr.html">DPR</a> ()

           WRITE (*,*) 'Boundary vector surface intercept ' //
          .               'coordinates using <a href="sincpt.html">SINCPT</a>:'
           WRITE (*,*) '   Radius    (km) :  ', RADIUS
           WRITE (*,*) '   Latitude  (deg):  ', LAT
           WRITE (*,*) '   Longitude (deg):  ', LON
           WRITE (*,*) '   Emit time using'
           WRITE (*,*) '   boundary LT(s) :  ', ETEMIT

     C
     C     We expect this to be a very small distance.
     C
           DIST = <a href="vdist.html">VDIST</a> ( TMP, SPOINT )

           WRITE (*,*) 'Distance between surface points'
           WRITE (*,*) 'of the selected boundary vector using'
           WRITE (*,*) '<a href="surfpt.html">SURFPT</a> and <a href="sincpt.html">SINCPT</a>:'
           WRITE (*,*) '   Distance (mm):     ', DIST*(10**6)

           END
       
     When this program was executed using gfortran on a PC Linux
     64 bit environment, the output was:

           Observation Reference frame:  MGS_MOC_NA
           Boresight surface intercept coordinates:
              Radius    (km) :     3384.9404101592791
              Latitude  (deg):    -48.479579821639035
              Longitude (deg):    -123.43645396290199
           Boundary vector surface intercept coordinates using <a href="surfpt.html">SURFPT</a>:
              Radius    (km) :     3384.9411359300038
              Latitude  (deg):    -48.477481877892437
              Longitude (deg):    -123.47407986665237
              Emit time using
              boresight LT(s):     119296864.18105948
           Boundary vector surface intercept coordinates using <a href="sincpt.html">SINCPT</a>:
              Radius    (km) :     3384.9411359139663
              Latitude  (deg):    -48.477481924252693
              Longitude (deg):    -123.47407904898704
              Emit time using
              boundary LT(s) :     119296864.18105946
           Distance between surface points
           of the selected boundary vector using
           <a href="surfpt.html">SURFPT</a> and <a href="sincpt.html">SINCPT</a>:
              Distance (mm):       32.139879867352690
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     S.C. Krening  (JPL)
     B.V. Semenov  (JPL)
     W.L. Taber    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.0, 23-SEP-2013 (SCK) (WLT) (BVS)</PRE>
<h4>Link to routine PXFRM2 source file <a href='../../../src/spicelib/pxfrm2.f'>pxfrm2.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:47 2014</pre>

</body>
</html>

