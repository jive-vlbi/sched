C$Procedure      SPKE01 ( S/P Kernel, evaluate, type 1 )
 
      SUBROUTINE SPKE01 ( ET, RECORD, STATE )
 
C$ Abstract
C
C     Evaluate a single SPK data record from a segment of type 1
C     (Difference Lines).
C
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     SPK
C
C$ Keywords
C
C     EPHEMERIS
C
C$ Declarations
 
      DOUBLE PRECISION      ET
      DOUBLE PRECISION      RECORD   ( * )
      DOUBLE PRECISION      STATE    ( 6 )
 
C$ Brief_I/O
C
C     Variable  I/O  Description
C     --------  ---  --------------------------------------------------
C     ET         I   Target epoch.
C     RECORD     I   Data record.
C     STATE      O   State (position and velocity).
C
C$ Detailed_Input
C
C     ET          is a target epoch, at which a state vector is to
C                 be computed.
C
C     RECORD      is a data record which, when evaluated at epoch ET,
C                 will give the state (position and velocity) of some
C                 body, relative to some center, in some inertial
C                 reference frame.
C
C$ Detailed_Output
C
C     STATE       is the state. Units are km and km/sec.
C
C$ Parameters
C
C     None.
C
C$ Exceptions
C
C     None.
C
C$ Files
C
C     None.
C
C$ Particulars
C
C     The exact format and structure of type 1 (difference lines)
C     segments are described in the SPK Required Reading file.
C
C     Difference lines (DL's) are generated by JPL navigation
C     system programs P and PV. Each data record is equivalent
C     to the (slightly rearranged) 'P' portion of a NAVIO PV file
C     data record.
C
C     SPKE01 is a specialized version of Fred Krogh's subroutine DAINT.
C     Only the calling sequence has been changed.
C
C     Because the original version was undocumented, only Fred 
C     knows how this really works.
C
C$ Examples
C
C     None.
C
C$ Restrictions
C
C     Unknown.
C
C$ Literature_References
C
C     NAIF Document 168.0, "S- and P- Kernel (SPK) Specification and
C     User's Guide"
C
C$ Author_and_Institution
C
C     F.T. Krogh      (JPL)
C     I.M. Underwood  (JPL)
C
C$ Version
C
C-    SPICELIB Version 1.1.0, 14-FEB-1997 (WLT) 
C     
C        The goto's were removed and loop and if structures 
C        revealed.  We still don't know exactly what's going 
C        on, but at least the bones of this routine have been 
C        cleaned off and are ready for assembly. (WLT)
C
C-    SPICELIB Version 1.0.4, 30-OCT-1996 (WLT)
C
C        Removed redundant SAVE statements from the declaration
C        section.  Thanks to Steve Schlaifer for finding this
C        error.
C
C-    SPICELIB Version 1.0.3, 10-MAR-1992 (WLT)
C
C        Comment section for permuted index source lines was added
C        following the header.
C
C-    SPICELIB Version 1.0.2, 23-AUG-1991 (HAN)
C
C        SPK01 was removed from the Required_Reading section of the
C        header. The information in the SPK01 Required Reading file
C        is now part of the SPK Required Reading file.
C
C-    SPICELIB Version 1.0.1, 22-MAR-1990 (HAN)
C
C        Literature references added to the header.
C
C-    SPICELIB Version 1.0.0, 31-JAN-1990 (IMU) (FTK)
C
C-&
 
C$ Index_Entries
C
C     evaluate type_1 spk segment
C
C-&


C
C     SPICELIB functions
C
      LOGICAL               RETURN

C
C     Local variables
C
C     The names below are original to the routine. They correspond
C     roughly to the original memos written by Fred Krogh to explain
C     how all this stuff really works.
C
      DOUBLE PRECISION      TL
      DOUBLE PRECISION      G        (   15 )
      
      DOUBLE PRECISION      REFPOS   (    3 )
      DOUBLE PRECISION      REFVEL   (    3 )
      
      DOUBLE PRECISION      DT       ( 15,3 )
      INTEGER               KQMAX1
      INTEGER               KQ       (    3 )

      DOUBLE PRECISION      FC       (   14 )


      DOUBLE PRECISION      SUM
      DOUBLE PRECISION      DELTA
      DOUBLE PRECISION      TP
      DOUBLE PRECISION      WC       (   13 )
      DOUBLE PRECISION      W        (   17 )

      INTEGER               MQ2
      INTEGER               KS1
      INTEGER               KS
      INTEGER               KQQ
      INTEGER               I
      INTEGER               J
      INTEGER               JX

C
C     Save everything between calls.
C 
      SAVE
      DATA                  FC (  1 )    / 1.D0 /

C
C     If the RETURN function is set, don't even bother with this.
C
      IF ( RETURN () ) THEN
         RETURN
      END IF

C
C     Unpack the contents of the MDA array.
C
C        Name    Dimension  Description
C        ------  ---------  -------------------------------
C        TL              1  Final epoch of record
C        G              15  Stepsize function vector
C        REFPOS          3  Reference position vector
C        REFVEL          3  Reference velocity vector
C        DT         15,NTE  Modified divided difference arrays
C        KQMAX1          1  Maximum integration order plus 1
C        KQ            NTE  Integration order array
C
C     For our purposes, NTE is always 3.
C
      CALL MOVED ( RECORD( 1),  1, TL )
      CALL MOVED ( RECORD( 2), 15, G  )
C     
C     Collect the reference position and velocity.
C     
      REFPOS(1) =  RECORD(17)
      REFVEL(1) =  RECORD(18)
       
      REFPOS(2) =  RECORD(19)
      REFVEL(2) =  RECORD(20)
      
      REFPOS(3) =  RECORD(21)
      REFVEL(3) =  RECORD(22)

      CALL MOVED ( RECORD(23), 45, DT )
      
      KQMAX1    = INT ( RECORD(68) )
      KQ(1)     = INT ( RECORD(69) )
      KQ(2)     = INT ( RECORD(70) )
      KQ(3)     = INT ( RECORD(71) )

C     
C     Next we set up for the computation of the various differences
C     
      DELTA     = ET     - TL
      TP        = DELTA 
      MQ2       = KQMAX1 - 2
      KS        = KQMAX1 - 1
   
C
C     This is clearly collecting some kind of coefficients.  
C     The problem is that we have no idea what they are...
C     
C     The G coefficients are supposed to be some kind of step size 
C     vector. 
C     
C     TP starts out as the delta t between the request time 
C     and the time for which we last had a state in the MDL file. 
C     We then change it from DELTA  by the components of the stepsize 
C     vector G.  
C
      DO J = 1, MQ2
         FC(J+1) = TP    / G(J)
         WC(J)   = DELTA / G(J)
         TP      = DELTA + G(J)
      END DO
   
C
C     Collect KQMAX1 reciprocals. 
C   
      DO J = 1, KQMAX1
         W(J) = 1.0D0/DBLE(J)
      END DO
      
C
C     Compute the W(K) terms needed for the position interpolation
C     (Note,  it is assumed throughout this routine that KS, which 
C     starts out as KQMAX1-1 (the ``maximum integration'') 
C     is at least 2.
C
      JX  = 0
      KS1 = KS - 1
      
      DO WHILE ( KS .GE. 2 )

         JX  = JX+1
         
         DO  J = 1, JX
            W(J+KS) = FC(J+1)*W(J+KS1) - WC(J)*W(J+KS)
         END DO
         
         KS  = KS1
         KS1 = KS1 - 1
         
      END DO
      
C
C     Perform position interpolation: (Note that KS = 1 right now.
C     We don't know much more than that.)
C
      DO  I = 1, 3
      
         KQQ = KQ(I)
         SUM = 0.0D0
         
         DO J = KQQ, 1, -1 
            SUM = SUM + DT(J,I)*W(J+KS)
         END DO
         
         STATE(I) = REFPOS(I)  +  DELTA * ( REFVEL(I) + DELTA*SUM )
         
      END DO
   
C
C     Again we need to compute the W(K) coefficients that are 
C     going to be used in the velocity interpolation. 
C     (Note, at this point, KS = 1, KS1 = 0.)
C      
      DO  J = 1, JX
         W(J+KS) = FC(J+1)*W(J+KS1) - WC(J)*W(J+KS)
      END DO   

      KS = KS - 1

C
C     Perform velocity interpolation:
C
      DO  I = 1, 3
      
         KQQ = KQ(I)
         SUM = 0.0D0
         
         DO J = KQQ, 1, -1
            SUM = SUM + DT(J,I)*W(J+KS)
         END DO
         
         STATE(I+3) = REFVEL(I) + DELTA*SUM
         
      END DO

C
C     That's all folks.  We don't know why we did anything, but 
C     at least we can tell structurally what we did.
C      

      RETURN
      END


