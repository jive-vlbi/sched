C$Program BRIEF ( BRIEF SPK or binary PCK summary )
 
      PROGRAM BRIEF
      IMPLICIT NONE
 
C$ Abstract
C
C     BRIEF is a command-line utility program that displays a contents
C     and time coverage summary for one or more binary SPK or binary
C     PCK files.
C
C     For more information see BRIEF User's Guide.
C
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     BRIEF User's Guide
C     SPK Required Reading
C     PCK Required Reading
C
C$ Keywords
C
C     FILES
C     UTILITY
C
C$ Parameters
C
C     See these include files.
C
      INCLUDE              'brief.inc'
      INCLUDE              'object.inc'
 
C
C$ Exceptions
C
C     1) If a file to be summarized is in transfer format, the error
C        SPICE(TRANSFERFORMAT) is signaled.
C
C     2) If a file to be summarized is a binary EK, the error
C        SPICE(EKFILE) is signaled.
C
C     3) If a file to be summarized is not a DAF, binary EK, or
C        transfer format file, the error SPICE(BADARCHITECTURE) is
C        signaled.
C
C     4) If a file to be summarized is a CK file, the error
C        SPICE(CKFILE) is signaled.
C
C     5) If a file to be summarized is a DAF but not an SPK, binary
C        PCK, of a CK file, the error SPICE(BADKERNELTYPE) is signaled.
C
C     6) If any of the UTC command lines options was provided but
C        an LSK file wasn't, an error related to time conversion is
C        signaled by the routines in the calling tree of the program.
C
C     7) If any operation on the objects storing summary information
C        fails, an error is signaled by the routines in the calling
C        tree of the program.
C
C     8) If no binary SPK or PCK files were provided on the command
C        line and/or list file, the error SPICE(NOFILES) is signaled.
C
C     9) If the list file specified with -f does not exists, the error
C        SPICE(BADLISTFILENAME) is signaled.
C
C     10) If the file specified with -f is a kernel, the error
C        SPICE(NOTATEXTFILE) is signaled.
C
C     11) If SPKs and PCKs are provided in the same run, the error
C        SPICE(NOCANDOSPKSPCKS) is signaled.
C
C     12) If -f is not followed by a file name, the error
C        SPICE(NOLISTFILENAME) is signaled.
C
C     13) If TPARSE fails to parse time provided with -from, the error
C         SPICE(BADFROMTIME) is signaled.
C
C     14) If -from is not followed by a time string, the error
C        SPICE(NOFROMTIME) is signaled.
C
C     13) If TPARSE fails to parse time provided with -to, the error
C        SPICE(BADTOTIME) is signaled.
C
C     14) If -to is not followed by a time string, the error
C        SPICE(NOTOTIME) is signaled.
C
C     13) If TPARSE fails to parse time provided with -at, the error
C        SPICE(BADATTIME) is signaled.                   )
C
C     14) If -at is not followed by a time string, the error
C        SPICE(NOATTIME) is signaled.
C
C$ Files
C
C     See User's Guide.
C
C$ Particulars
C
C     See User's Guide.
C
C$ Examples
C
C     See User's Guide.
C
C$ Restrictions
C
C     See User's Guide.
C
C$ Literature_References
C
C     None.
C
C$ Author_and_Institution
C
C     N.J. Nachman   (JPL)
C     B.V. Semenov   (JPL)
C     W.L. Taber     (JPL)
C     E.D. Wright    (JPL)
C
C$ Version
C
C-    BRIEF Version 4.0.0, 08-SEP-2010 (BVS)
C
C        Added sorted-by-time tabular output (new option -s).
C
C        Moved WINRM parameter definition to brief.inc.
C
C-    BRIEF Version 3.0.0, 14-JAN-2008 (BVS)(NJB)(EDW)
C
C        New capabilities including: summarizing binary PCK files;
C        loading text kernels; summarizing SPK files provided in
C        meta-kernels; displaying times as UTC (-utc), UTC/DOY
C        (-utcdoy), and ET seconds (-etsec); detecting unsupported
C        kernel types (CK, EK, transfer format, etc.); processing
C        reversed ID range and time boundaries.
C
C        Report format changes including: new format of the version
C        string; shorter usage message for blank command line; modified
C        help message for -h; more legible "No data" reports for object
C        and time constraints; PCK-specific wording for PCK summary
C        reports.
C
C        Previous functionality fixes including: eliminating empty
C        reports when no files were provided; processing TABs in list
C        files; accepting negative numbers in ID range assignments;
C        processing body filters specifying the same body in different
C        ways; reporting "No data" for time constraints; restricting
C        help display to only times when -h is provided.
C
C        Bug fixes including: hanging up when no value was provided
C        after -from, -to, -at, or -f; logic expression error in the
C        assignment FROMTO = HAVFRM .AND. HAVTO .AND. FROM .LE. TO
C        (caused failure on IFORT).
C
C        Internal buffer size increases including: MAXBOD to 100,000
C        (from 20,000); CMDSIZ to 25,000 (from 4,000).
C
C        Completely rewrite of the User's Guide.
C
C-    BRIEF Version 2.4.0, 11-NOV-2005 (BVS)
C
C        Removed copyright note from usage display for old
C        MAC environments.
C
C-    BRIEF Version 2.3.1, 28-OCT-2005 (EDW)
C
C        Edited the DISPLY and OBJFND subroutine to
C        remove a duplicate argument (used as both input
C        and output) from an OBJNXT call. Optimized versions
C        of such calls can fail on some platforms.
C
C-    BRIEF Version 2.3.0, 13-MAY-2004 (NJB)
C
C        Added subroutine-scope SAVE statement to support use of CSPICE
C        under cygwin.  Also added SAVE statement to subroutine DISPLY.
C
C-    BRIEF Version 2.2.0, 25-JUN-2002 (BVS)
C
C        Increased the number of bodies (MAXBOD) to 20,000.
C        Cleaned up version strings in this section.
C
C-    BRIEF Version 2.1.5, 08-OCT-1999 (WLT)
C
C        The environment lines were expanded so that the supported
C        environments are now explicitly given.  New
C        environments are WIN-NT
C
C-    BRIEF Version 2.1.4, 21-SEP-1999 (NJB)
C
C        A bogus environment line was deleted.  Some
C        typos were corrected.
C
C-    BRIEF Version 2.1.3, 28-JUL-1999 (WLT)
C
C        The environment lines were expanded so that the supported
C        environments are now explicitly given.  New
C        environments are PC-DIGITAL, SGI-O32 and SGI-N32.
C
C-    BRIEF Version 2.1.2, 18-MAR-1999 (WLT)
C
C        The environment lines were expanded so that the supported
C        environments are now explicitly given.  Previously,
C        environments such as SUN-SUNOS and SUN-SOLARIS were implied
C        by the environment label SUN.
C
C-    BRIEF Version 2.1.1, 03-APR-1998 (NJB)
C
C        Added type declarations for the functions BIGGER and INC.
C        This was done to enable porting to the PC/Linux/Fort77
C        environment.
C
C-    BRIEF Version 2.1.0, 21-JUL-1997 (WLT)
C
C        Added a header and modified the program so that it will
C        print out the version of SPICELIB it was linked against.
C
C-    BRIEF Version 2.0.0, 14-MAR-1996 (WLT)
C
C        The program was completely re-written from Mike Spencer's
C        original version.  Only the name is the same.
C
C-&
 
C
C     Passed Functions
C
      INTEGER               BIGGER
      EXTERNAL              BIGGER
 
      LOGICAL               IDMCH
      EXTERNAL              IDMCH
 
      INTEGER               INC
      EXTERNAL              INC
 
      EXTERNAL              WRITIT
 
 
 
C
C     Spicelib Functions
C
      INTEGER               CARDD
      INTEGER               INTMAX
      INTEGER               INTMIN
      INTEGER               OBJACT
      INTEGER               POS
      INTEGER               RTRIM
 
      LOGICAL               BEINT
      LOGICAL               EXISTS
      LOGICAL               IDSET
      LOGICAL               WNINCD
 
C
C     Parameters
C
 
C
C     Other Parameters
C
      INTEGER               ARGLEN
      PARAMETER           ( ARGLEN = 80 )
 
 
C
C     Local variables
C
 
C
C     GETFAT arguments
C
      CHARACTER*(ARGLEN)    ARCH
      CHARACTER*(ARGLEN)    KERTYP
 
C
C     Command line and parsing variables.
C
      CHARACTER*(CMDSIZ)    PASS1
      CHARACTER*(CMDSIZ)    PASS2
 
      INTEGER               BEG
      INTEGER               END
      INTEGER               START
      INTEGER               SAVBEG
      INTEGER               SAVEND
C
C     Control Flags
C
C
C     The block of character strings declared below are
C     for the recognized options the user can supply
C     on the command line.
C
C
C     FNONLY is the string used for the number onlys
C             command line flag.
C
C     FOBNAM is the string used for the order by
C             body name command line flag.
C
C     FTDSP  is the string used for the tabular display
C             command line flag.
C
C     FCNTR  is the string used for the include centers
C             command line flag.
C
C     FHELP  is the string used for the help command line flag.
C
C     FVRSN  is the string used for the version command line flag.
C
C     FALL   is the string used for the combine all files
C             command line flag.
C
C     FGROUP is the string used for grouping lines by coverage
C            in tabular output.
C
C     FSORT  is the string used for sorting lines by times for
C            each body in tabular output.
C
C     FSBBOD is the select by body id flag.
C
C     FSBCEN is the select by center id flag.
C
C     FSEC   is the flag used to indicate that coverages should
C            be rounded inward to the nearest second.
C
C     FMIN   is the flag used to indicate that coverages should
C            be rounded inward to the nearest minute.
C
C     FHOUR  is the flag used to indicate that coverages should
C            be rounded inward to the nearest hour.
C
C     FDAY   is the flag used to indicate that coverages should
C            be rounded inward to the nearest day.
C
C     FAT    is the flag to restrict the summary to only those
C            objects that have coverage at a specific epoch.
C
C     FFROM  is the flag to indicate the lower bound of an interval
C            that the coverage for an object must contain
C
C     FTO    is the flag to indicate the upper bound of an interval
C            that the coverage for an object must contain
C
C     FSFILE is the flag to indicate that a file of SPK's to read
C            is available.
C
C     FTUTC  is the flag to indicate that times must be displayed as
C            calendar UTC.
C
C     FTDOY  is the flag to indicate that times must be displayed as
C            DOY UTC.
C
C     FTSEC  is the flag to indicate that times must be displayed as
C            ET seconds.
C
 
 
      INTEGER               FSIZE
      PARAMETER           ( FSIZE = 8 )
 
      CHARACTER*(FSIZE)     FNONLY
      CHARACTER*(FSIZE)     FOBNAM
      CHARACTER*(FSIZE)     FTDSP
      CHARACTER*(FSIZE)     FCNTR
      CHARACTER*(FSIZE)     FHELP
      CHARACTER*(FSIZE)     FVRSN
      CHARACTER*(FSIZE)     FALL
      CHARACTER*(FSIZE)     FGROUP
      CHARACTER*(FSIZE)     FSORT
 
      CHARACTER*(FSIZE)     FSBBOD
      CHARACTER*(FSIZE)     FSBCEN
      CHARACTER*(FSIZE)     FSEC
      CHARACTER*(FSIZE)     FMIN
      CHARACTER*(FSIZE)     FHOUR
      CHARACTER*(FSIZE)     FDAY
      CHARACTER*(FSIZE)     FAT
      CHARACTER*(FSIZE)     FFROM
      CHARACTER*(FSIZE)     FTO
      CHARACTER*(FSIZE)     FSFILE
 
      CHARACTER*(FSIZE)     FTUTC
      CHARACTER*(FSIZE)     FTDOY
      CHARACTER*(FSIZE)     FTSEC
 
C
C     Parsed Control Values.
C
      LOGICAL               ALL
      LOGICAL               AT
      LOGICAL               CNTR
      LOGICAL               FROMTO
      LOGICAL               HAVFIL
      LOGICAL               HAVFRM
      LOGICAL               HAVTO
      LOGICAL               HELP
      LOGICAL               NONLY
      LOGICAL               OBNAM
      LOGICAL               ROUND
      LOGICAL               TDSP
      LOGICAL               GDSP
      LOGICAL               SDSP
      LOGICAL               TIMAT
      LOGICAL               ULIST
      LOGICAL               VRSN
      LOGICAL               SFILE
 
      DOUBLE PRECISION      INTVAL
      DOUBLE PRECISION      FROM
      DOUBLE PRECISION      TO
      DOUBLE PRECISION      WHEN
 
      INTEGER               OBJSIZ
 
C
C     The next block of variables are used to determine how
C     objects will be represented in the output.  This is
C     discussed in more detail below when the format strings
C     are defined.
C
      INTEGER               FMTSIZ
      PARAMETER           ( FMTSIZ = 32 )
 
      INTEGER               NUM
      INTEGER               O
      INTEGER               T
      INTEGER               C
 
      CHARACTER*(FMTSIZ)    FRMAT ( 2, 2, 2, 2 )
      CHARACTER*(FMTSIZ)    FMTPIC
 
 
 
C
C     The items below are used for the explicitly specified
C     list of bodies to summarize.  The enumeration IDCODE
C     through MATCHS are the components associated with
C     each item of the explicit list.
C
C
C     IDCODE
C     BEGNAM
C     ENDNAM
C     MATCHS
C
 
      INTEGER               BEGNAM
      INTEGER               ENDNAM
      INTEGER               ID1
      INTEGER               ID2
      INTEGER               REFTO
      INTEGER               MATCHS
      PARAMETER           ( ID1    = 1 )
      PARAMETER           ( ID2    = ID1    + 1 )
      PARAMETER           ( BEGNAM = ID2    + 1 )
      PARAMETER           ( ENDNAM = BEGNAM + 1 )
      PARAMETER           ( REFTO  = ENDNAM + 1 )
      PARAMETER           ( MATCHS = REFTO  + 1 )
 
 
      INTEGER               USESIZ
      PARAMETER           ( USESIZ = MATCHS )
C
C     The next two parameters are simply utility parameters
C     and shouldn't be messed with.
C
      INTEGER               MTAUSE
      PARAMETER           ( MTAUSE = USESIZ + 1 )
 
      INTEGER               RMUSE
      PARAMETER           ( RMUSE  = USESIZ*MAXUSE + MAXUSE )
C
C     The actual object variables are below.
C
      INTEGER               BODLST ( LBCELL:RMUSE )
      INTEGER               BODY   ( MATCHS )
      INTEGER               BOD    ( 2 )
      INTEGER               NBOD
      INTEGER               REF
 
C
C     The objects encountered in reading through the files.
C
      INTEGER               WDSIZE
      PARAMETER           ( WDSIZE = 64 )
 
      CHARACTER*(WDSIZE)    TKV
 
      CHARACTER*(WDSIZE)    OBJNAM
      CHARACTER*(WDSIZE)    OBJNM
      CHARACTER*(WDSIZE)    OBJNMG
      INTEGER               OBJ   ( 2 )
      INTEGER               OBJG  ( 2 )
      INTEGER               OBJCT ( 3 )
      INTEGER               OBJCTG( 3 )
      INTEGER               OBJECT( 3 )
      INTEGER               OBJLIS( LBCELL: 4*MAXBOD )
C
C     Help Text Variables
C
 
      INTEGER               LNSIZE
      PARAMETER           ( LNSIZE = 80 )
 
      INTEGER               NUTEXT
      PARAMETER           ( NUTEXT  = 21 )
 
      INTEGER               NHTEXT
      PARAMETER           ( NHTEXT  = 50 )
 
      INTEGER               FILSIZ
      PARAMETER           ( FILSIZ = 255 )
 
      CHARACTER*(LNSIZE)    UTEXT ( NUTEXT )
      CHARACTER*(LNSIZE)    HTEXT ( NHTEXT )
      CHARACTER*(FILSIZ)    STRING
      CHARACTER*(LNSIZE)    LINE
 
      CHARACTER*(FILSIZ)    SRCFIL
C
C     Window and Window Table Variables.
C
      CHARACTER*(WDSIZE)    WINSYM ( LBCELL : MAXBOD  )
      INTEGER               WINPTR ( LBCELL : MAXBOD  )
      DOUBLE PRECISION      WINVAL ( LBCELL : WINRM   )
 
      DOUBLE PRECISION      FILWIN ( LBCELL : LRGWIN )
      DOUBLE PRECISION      SEGWIN ( LBCELL : 2      )
      DOUBLE PRECISION      TMPWIN ( LBCELL : LRGWIN )
 
C
C     DAF Variables
C
 
      INTEGER               ND
      PARAMETER           ( ND = 2 )
 
      INTEGER               NISPK
      PARAMETER           ( NISPK = 6 )
 
      INTEGER               NIPCK
      PARAMETER           ( NIPCK = 5 )
 
      INTEGER               IC     ( 6 )
      INTEGER               HANDLE
 
      DOUBLE PRECISION      DC     ( 2 )
      DOUBLE PRECISION      SEGSUM ( 6 )
C
C     Segment summary components
C
      INTEGER               ID
      INTEGER               CENT
      INTEGER               FRAME
      INTEGER               CLASS
      INTEGER               FCENT
      INTEGER               CLSSID
C
C     Utility Variables
C
      CHARACTER*(LNSIZE)    ERROR
 
      INTEGER               FRST
      INTEGER               LAST
 
      INTEGER               B
      INTEGER               E
      INTEGER               GAP
      INTEGER               HI
      INTEGER               I
      INTEGER               J
      INTEGER               JG
      INTEGER               ITEM
      INTEGER               LOW
      INTEGER               N
      INTEGER               NOBJ
      INTEGER               PTR
      INTEGER               SIZE
      INTEGER               VALUE
 
      LOGICAL               FND
      LOGICAL               OK
      LOGICAL               KEEP
      LOGICAL               FOUND
      LOGICAL               FIRST
      LOGICAL               EOF
 
C
C     String indicating the output time type.
C
      CHARACTER*(FMTSIZ)    TIMTYP
 
C
C     Counter of how many SPKs and PCKs were processed.
C
      INTEGER               NDONE
 
C
C     TAB character
C
      CHARACTER*(1)         TABCHR
 
C
C     Flags indicating whether at least one SPK and and at least
C     one PCK have been processed.
C
      LOGICAL               GOTSPK
      LOGICAL               GOTPCK
 
C
C     Count and index of SPKs loaded via meta-kernels.
C
      INTEGER               SCOUNT
      INTEGER               SINDEX
 
C
C     KDATA outputs
C
      CHARACTER*(FMTSIZ)    FILTYP
      CHARACTER*(FILSIZ)    SOURCE
 
C
C     Strings to hold output from and to ETs
C
      CHARACTER*(WDSIZE)    ETSTR1
      CHARACTER*(WDSIZE)    ETSTR2
 
C
C     Saved variables
C
C     The SAVE statement that appears here causes f2c to create local
C     variables with static duration. This enables the CSPICE version
C     of brief to run under cygwin.
C
      SAVE
 
 
C
C     SPICELIB error handling.
C
      CALL CHKIN  ( 'BRIEF' )
      CALL ERRACT ( 'SET', 'ABORT')
 
C
C     "patterns" that can be used to display names of objects are:
C
C     Pattern 1 (p1)    Name (xxxx)
C     Pattern 2 (p2)    xxxx
C     Pattern 3 (p3)    xxxx Name
C
C     Where xxxx stands for the numeric code for the object.
C     Note: if a name cannot be found for an object pattern 2
C     is automatically used.
C
C     The "names" of objects are made by a combination of one or
C     possibly two body names.  The format used to create the
C     name of the object is driven by the options that are
C     in force from the command line.
C
C     Here's where the various format parameters go and the
C     corresponding formats.  These formats will be passed
C     to the display module along with the values of
C     n, c, o, and t. The display module has the responsibility
C     of taking apart the format and constructing appropriate
C     names.
C
C             n  c  o  t
C
      FRMAT ( 1, 1, 1, 1 ) = 'p1'
      FRMAT ( 2, 1, 1, 1 ) = 'p2'
      FRMAT ( 1, 2, 1, 1 ) = 'p1 w.r.t. p1'
      FRMAT ( 2, 2, 1, 1 ) = 'p2 w.r.t. p2'
      FRMAT ( 1, 1, 2, 1 ) = 'p1'
      FRMAT ( 2, 1, 2, 1 ) = 'p2'
      FRMAT ( 1, 2, 2, 1 ) = 'p1 w.r.t. p1'
      FRMAT ( 2, 2, 2, 1 ) = 'p2 w.r.t. p2'
 
      FRMAT ( 1, 1, 1, 2 ) = 'p3'
      FRMAT ( 2, 1, 1, 2 ) = 'p2'
      FRMAT ( 1, 2, 1, 2 ) = 'p3 w.r.t. p3'
      FRMAT ( 2, 2, 1, 2 ) = 'p2 w.r.t. p2'
      FRMAT ( 1, 1, 2, 2 ) = 'p1'
      FRMAT ( 2, 1, 2, 2 ) = 'p2'
      FRMAT ( 1, 2, 2, 2 ) = 'p1 w.r.t. p1'
      FRMAT ( 2, 2, 2, 2 ) = 'p2 w.r.t. p2'
 
C
C     Usage text.
C
      UTEXT(  1 ) = '   BRIEF is a command-line utility progr'
     .//            'am that displays a summary for'
      UTEXT(  2 ) = '   one or more binary SPK or binary PCK '
     .//            'files. The program usage is:'
      UTEXT(  3 ) = ' '
      UTEXT(  4 ) = '      % brief [-options] file [file ...]'
      UTEXT(  5 ) = ' '
      UTEXT(  6 ) = '   The most useful options are shown bel'
     .//            'ow. For the complete set of'
      UTEXT(  7 ) = '   options, run BRIEF with the -h option'
     .//            '. The order of options is not'
      UTEXT(  8 ) = '   significant. The case of option keys '
     .//            'is significant: they must be'
      UTEXT(  9 ) = '   lowercase as shown below.'
      UTEXT( 10 ) = ' '
      UTEXT( 11 ) = '      -c           display centers of mo'
     .//            'tion/relative-to frames'
      UTEXT( 12 ) = '      -t           display summary in a '
     .//            'tabular format'
      UTEXT( 13 ) = '      -a           treat all files as a '
     .//            'single file'
      UTEXT( 14 ) = '      -utc         display times in UTC '
     .//            'calendar date format (needs LSK)'
      UTEXT( 15 ) = '      -utcdoy      display times in UTC '
     .//            'day-of-year format (needs LSK)'
      UTEXT( 16 ) = '      -etsec       display times as ET s'
     .//            'econds past J2000'
      UTEXT( 17 ) = ' '
      UTEXT( 18 ) = '   An LSK file must be provided on the c'
     .//            'ommand line to display times in'
      UTEXT( 19 ) = '   UTC formats. FK file(s) must be provi'
     .//            'ded on the command line to'
      UTEXT( 20 ) = '   display names of any frames that are '
     .//            'not built into the Toolkit.'
      UTEXT( 21 ) = ' '
 
C
C     Help text.
C
      HTEXT(  1 ) = '   BRIEF is a command-line utility progr'
     .//            'am that displays a summary for'
      HTEXT(  2 ) = '   one or more binary SPK or binary PCK '
     .//            'files. The program usage is:'
      HTEXT(  3 ) = ' '
      HTEXT(  4 ) = '      % brief [-options] file [file ...]'
      HTEXT(  5 ) = ' '
      HTEXT(  6 ) = '   File names and options can be specifi'
     .//            'ed in any order. Text kernels'
      HTEXT(  7 ) = '   needed for time conversions and/or bo'
     .//            'dy/frame ID-to-name conversions can'
      HTEXT(  8 ) = '   be specified in addition to the SPK o'
     .//            'r PCK file(s) to be summarized.'
      HTEXT(  9 ) = '   SPK files and PCK files cannot be sum'
     .//            'marized at the same time.'
      HTEXT( 10 ) = ' '
      HTEXT( 11 ) = '   Options are shown below. The order of'
     .//            ' options is not significant.'
      HTEXT( 12 ) = '   The case of option keys is significan'
     .//            't: they must be lowercase as'
      HTEXT( 13 ) = '   shown below.'
      HTEXT( 14 ) = ' '
      HTEXT( 15 ) = '      -t           display summary in a '
     .//            'tabular format'
      HTEXT( 16 ) = '      -a           treat all files as a '
     .//            'single file'
      HTEXT( 17 ) = '      -c           display centers of mo'
     .//            'tion/relative-to frames'
      HTEXT( 18 ) = ' '
      HTEXT( 19 ) = '      -utc         display times in UTC '
     .//            'calendar date format (needs LSK)'
      HTEXT( 20 ) = '      -utcdoy      display times in UTC '
     .//            'day-of-year format (needs LSK)'
      HTEXT( 21 ) = '      -etsec       display times as ET s'
     .//            'econds past J2000'
      HTEXT( 22 ) = ' '
      HTEXT( 23 ) = '      -sec         display times "rounde'
     .//            'd inward" to second'
      HTEXT( 24 ) = '      -min         display times "rounde'
     .//            'd inward" to minute'
      HTEXT( 25 ) = '      -hour        display times "rounde'
     .//            'd inward" to hour'
      HTEXT( 26 ) = '      -day         display times "rounde'
     .//            'd inward" to day'
      HTEXT( 27 ) = ' '
      HTEXT( 28 ) = '      -s           display summary sorte'
     .//            'd by start time for each body/frame'
      HTEXT( 29 ) = '      -g           display summary group'
     .//            'ed by coverage'
      HTEXT( 30 ) = '      -n           display bodies/frames'
     .//            ' using only numeric id-codes'
      HTEXT( 31 ) = '      -o           display summary order'
     .//            'ed by body/frame name'
      HTEXT( 32 ) = ' '
      HTEXT( 33 ) = '      -[bod]       display summary for b'
     .//            'ody [bod]'
      HTEXT( 34 ) = '      -sb[bod]     display summary for b'
     .//            'ody [bod]'
      HTEXT( 35 ) = '      -sc[cen]     display summary for c'
     .//            'enter of motion/relative-to frame [cen]'
      HTEXT( 36 ) = '      -at [time]   display summary if co'
     .//            'verage contains epoch [time]'
      HTEXT( 37 ) = '      -from [beg]  display summary if co'
     .//            'verage contains interval [beg]:[end]'
      HTEXT( 38 ) = '      -to [end]    display summary if co'
     .//            'verage contains interval [beg]:[end]'
      HTEXT( 39 ) = ' '
      HTEXT( 40 ) = '      -f [list]    summarize kernels lis'
     .//            'ted in the [list] file'
      HTEXT( 41 ) = ' '
      HTEXT( 42 ) = '      -h           display help'
      HTEXT( 43 ) = '      -v           display version'
      HTEXT( 44 ) = ' '
      HTEXT( 45 ) = '   An LSK file must be provided on the c'
     .//            'ommand line to display times in'
      HTEXT( 46 ) = '   UTC formats. FK file(s) must be provi'
     .//            'ded on the command line to'
      HTEXT( 47 ) = '   display names of any frames that are '
     .//            'not built into the Toolkit.'
      HTEXT( 48 ) = ' '
      HTEXT( 49 ) = '   See the BRIEF User''s Guide for more '
     .//            'information.'
      HTEXT( 50 ) = ' '
 
C
C     Command line keys.
C
      FNONLY  = '-n'
      FOBNAM  = '-o'
      FTDSP   = '-t'
      FCNTR   = '-c'
      FHELP   = '-h'
      FVRSN   = '-v'
      FALL    = '-a'
      FSBBOD  = '-sb'
      FSBCEN  = '-sc'
      FSEC    = '-sec'
      FMIN    = '-min'
      FHOUR   = '-hour'
      FDAY    = '-day'
      FAT     = '-at'
      FFROM   = '-from'
      FTO     = '-to'
      FGROUP  = '-g'
      FSORT   = '-s'
      FSFILE  = '-f'
      FTUTC   = '-utc'
      FTDOY   = '-utcdoy'
      FTSEC   = '-etsec'
 
C
C     Initial values.
C
      NONLY  = .FALSE.
      OBNAM  = .FALSE.
      TDSP   = .FALSE.
      GDSP   = .FALSE.
      SDSP   = .FALSE.
      CNTR   = .FALSE.
      HELP   = .FALSE.
      VRSN   = .FALSE.
      HAVFIL = .FALSE.
      ALL    = .FALSE.
      ULIST  = .FALSE.
      ROUND  = .FALSE.
      TIMAT  = .FALSE.
      HAVFRM = .FALSE.
      HAVTO  = .FALSE.
      FROMTO = .FALSE.
      AT     = .FALSE.
      SFILE  = .FALSE.
 
      OBJSIZ =  2
      INTVAL =  86400.0D0
 
      TIMTYP = 'ETCAL'
 
      NDONE  =  0
 
      TABCHR = CHAR(9)
 
      GOTSPK = .FALSE.
      GOTPCK = .FALSE.
 
      SRCFIL = ' '
 
      PASS2 = ' '
      PASS1 = ' '
 
C
C     Initialize the list of objects that we will search for.
C
      CALL OBJINL ( USESIZ, MAXUSE, BODLST )
 
C
C     Construct and display program version.
C
      CALL TKVRSN ( 'TOOLKIT', TKV )
      LINE = 'BRIEF -- Version'
      CALL SUFFIX ( VERSN, 1, LINE )
      CALL SUFFIX ( '-- Toolkit Version', 1, LINE )
      CALL SUFFIX ( TKV,              1, LINE )
 
      CALL WRITIT ( ' '  )
      CALL WRITIT ( LINE )
      CALL WRITIT ( ' '  )
 
C
C     Get command line.
C
      CALL GETCML (PASS1)
 
C
C     If command line is blank, display usage and stop.
C
      IF ( PASS1 .EQ. ' ' ) THEN
         DO I = 1, NUTEXT
            CALL WRITIT ( UTEXT(I) )
         END DO
         STOP
      END IF
 
 
C
C     Do first scan of the command line for files. Load those of them
C     that appear to be text kernels. Make a note of SPKs, binary PCKs
C     and list file.
C
      START  = 1
      CALL FNDNWD ( PASS1, START, BEG, END )
 
      DO WHILE ( BEG .NE. 0  )
 
C
C        Check if this word starts with "-". If it doesn't, consider it
C        to be a file name.
C
         IF ( PASS1(BEG:BEG) .NE. '-' ) THEN
 
C
C           Check if this file exists.
C
            IF ( EXISTS( PASS1(BEG:END) ) ) THEN
 
C
C              Get this file's architecture and type.
C
               CALL GETFAT ( PASS1(BEG:END), ARCH, KERTYP )
 
C
C              If it's not a DAF, a DAS, a transfer format, or an
C              obsolete type 1 text EK, load it into the POOL as
C              ZZLDKER would.
C
               IF ( ARCH .NE. 'XFR' .AND.
     .              ARCH .NE. 'DEC' .AND.
     .              ARCH .NE. 'TE1' .AND.
     .              ARCH .NE. 'DAF' .AND.
     .              ARCH .NE. 'DAS'      ) THEN
 
                  CALL FURNSH( PASS1(BEG:END) )
 
               END IF
 
C
C              If it's a PCK or an SPK set corresponding flags.
C
               IF ( ARCH .EQ. 'DAF' .AND. KERTYP .EQ. 'SPK' ) THEN
                  GOTSPK = .TRUE.
               END IF
 
               IF ( ARCH .EQ. 'DAF' .AND. KERTYP .EQ. 'PCK' ) THEN
                  GOTPCK = .TRUE.
               END IF
 
            END IF
 
         ELSE IF ( PASS1(BEG:END) .EQ. FSFILE ) THEN
 
C
C           If we have a list file, save it's name as we will need to
C           scan it for text kernels and PCKs/SPKs as well.
C
            START  = END + 1
            CALL FNDNWD ( PASS1, START, BEG, END )
 
            IF ( BEG .GT. 0 ) THEN
               SFILE = .TRUE.
               SRCFIL = PASS1(BEG:END)
            ELSE
               END = START - 1
            END IF
 
         END IF
 
C
C        Find next word.
C
         START = END + 1
         CALL FNDNWD ( PASS1, START, BEG, END )
 
      END DO
 
C
C     If a list file was provided, scan it for text kernels, SPKs and
C     binary PCKs.
C
      IF ( SFILE ) THEN
 
C
C        Check if list files exists.
C
         IF ( .NOT. EXISTS( SRCFIL ) ) THEN
            CALL SETMSG ( 'List file ''#'' provided with -f option  '//
     .                    'does not exist.'                          )
            CALL ERRCH  ( '#', SRCFIL                                )
            CALL SIGERR ( 'SPICE(BADLISTFILENAME)'                   )
         END IF
 
C
C        Check if an SPK OR another kernel was provided in with -f.
C        Complain and stop if so.
C
         CALL GETFAT ( SRCFIL, ARCH, KERTYP )
         IF ( ARCH .NE. '?' ) THEN
            CALL SETMSG ( 'The file ''#'' provided with -f option ' //
     .                    'is a kernel file of architecture '        //
     .                    '''#'' and type ''#''. Only plain text '   //
     .                    'files containing lists of kernels should '//
     .                    'be provided with this option.'            )
            CALL ERRCH  ( '#', SRCFIL                                )
            CALL ERRCH  ( '#', ARCH                                  )
            CALL ERRCH  ( '#', KERTYP                                )
            CALL SIGERR ( 'SPICE(NOTATEXTFILE)'                      )
         END IF
 
C
C        Read non-blank lines from the list file until EOF.
C
         CALL RDNBL ( SRCFIL, PASS2, EOF )
 
         DO WHILE ( .NOT. EOF )
 
C
C           Remove TABs with spaces on the current line.
C
            CALL REPLCH( PASS2, TABCHR, ' ', PASS2 )
 
C
C           Scan line for words.
C
            START = 1
            CALL FNDNWD ( PASS2, START, BEG, END )
 
            DO WHILE ( BEG .NE. 0 )
 
C
C              Assume this word is a file name. Check if this file
C              exists.
C
               IF ( EXISTS( PASS2(BEG:END) ) ) THEN
 
C
C                 Get this file's architecture and type.
C
                  CALL GETFAT ( PASS2(BEG:END), ARCH, KERTYP )
 
C
C                 If it's not a DAF, a DAS, a transfer format, or an
C                 obsolete type 1 text EK, load it into the POOL as
C                 ZZLDKER would.
C
                  IF ( ARCH .NE. 'XFR' .AND.
     .                 ARCH .NE. 'DEC' .AND.
     .                 ARCH .NE. 'TE1' .AND.
     .                 ARCH .NE. 'DAF' .AND.
     .                 ARCH .NE. 'DAS'      ) THEN
 
                     CALL FURNSH( PASS2(BEG:END) )
 
                  END IF
 
C
C                 If it's a PCK or an SPK set corresponding flags.
C
                  IF ( ARCH .EQ. 'DAF' .AND. KERTYP .EQ. 'SPK' ) THEN
                     GOTSPK = .TRUE.
                  END IF
 
                  IF ( ARCH .EQ. 'DAF' .AND. KERTYP .EQ. 'PCK' ) THEN
                     GOTPCK = .TRUE.
                  END IF
 
               END IF
 
C
C              Get next word from the line.
C
               START = END + 1
               CALL FNDNWD ( PASS2, START, BEG, END )
 
            END DO
 
C
C           Get next non-blank line.
C
            CALL RDNBL ( SRCFIL, PASS2, EOF )
 
         END DO
 
C
C        Close list file.
C
         CALL CLTEXT ( SRCFIL )
 
      END IF
 
C
C     Get the count of that SPKs were loaded via meta-kernels that were
C     provided on the command line and/or in the list file.
C
      CALL KTOTAL( 'SPK', SCOUNT )
      SINDEX = 0
 
C
C     Reset SPK flag is this count is not 0.
C
      IF ( SCOUNT .NE. 0 ) THEN
         GOTSPK = .TRUE.
      END IF
 
C
C     Check if both SPKs and PCKs were given to the program. If so,
C     signal an error.
C
      IF ( GOTSPK .AND. GOTPCK ) THEN
         CALL SETMSG ( 'The program cannot summarize binary SPK ' //
     .                 'and PCK files in the same run.'           )
         CALL SIGERR ( 'SPICE(NOCANDOSPKSPCKS)'                   )
      END IF
 
C
C     Scan command line again to process options and accumulate all
C     file names in separate string.
C
      PASS2 = ' '
      START = 1
      CALL FNDNWD ( PASS1, START, BEG, END )
 
      DO WHILE ( BEG .GT. 0 )
 
C
C        All options begin with a '-'. If this item doesn't it is
C        presumed to be a file.
C
         IF ( PASS1(BEG:BEG) .NE. '-' ) THEN
 
            CALL SUFFIX ( PASS1(BEG:END) , 1, PASS2 )
 
            HAVFIL = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FNONLY ) THEN
C
C           Display numbers only.
C
            NONLY  = .TRUE.
            OBNAM  = .FALSE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FSFILE ) THEN
 
C
C           Get file names from a list file.
C
            START  = END + 1
            CALL FNDNWD ( PASS1, START, BEG, END )
 
            IF ( BEG .GT. 0 ) THEN
               SFILE  = .TRUE.
               SRCFIL =  PASS1(BEG:END)
            ELSE
               CALL SETMSG ( 'No file name was following '       //
     .                       'the -f option.'                     )
               CALL SIGERR ( 'SPICE(NOLISTFILENAME)'              )
            END IF
 
         ELSE IF ( PASS1(BEG:END) .EQ. FTUTC ) THEN
C
C           Display time as calendar UTC.
C
            TIMTYP = 'UTCCAL'
 
         ELSE IF ( PASS1(BEG:END) .EQ. FTDOY ) THEN
C
C           Display times as DOY UTC.
C
            TIMTYP = 'UTCDOY'
 
         ELSE IF ( PASS1(BEG:END) .EQ. FTSEC ) THEN
C
C           Display times as ET seconds.
C
            TIMTYP = 'ETSEC'
 
         ELSE IF ( PASS1(BEG:END) .EQ. FOBNAM ) THEN
C
C           Sort by the name of the object.
C
            OBNAM  = .NOT. NONLY
 
 
         ELSE IF ( PASS1(BEG:END) .EQ. FTDSP ) THEN
C
C           Present output with a tabular display.
C
            TDSP  = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FGROUP ) THEN
C
C           Group similar coverages in a tabular display.
C
            GDSP  = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FSORT ) THEN
C
C           Sort coverages by start time in a tabular display.
C
            SDSP  = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FCNTR ) THEN
C
C           Combine bodies and centers to make a single object.
C
            CNTR   = .TRUE.
            OBJSIZ = 3
 
         ELSE IF ( PASS1(BEG:END) .EQ. FHELP ) THEN
C
C           Print the help.
C
            HELP   = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FVRSN ) THEN
C
C           Show the version.
C
            VRSN  = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FALL ) THEN
C
C           Combine files.
C
            ALL   = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FFROM ) THEN
C
C           Filter by coverage over interval FROM:TO.
C
            START = END + 1
 
            CALL FNDNWD ( PASS1, START,   BEG,  END    )
 
            IF ( BEG .GT. 0 ) THEN
               CALL TPARSE ( PASS1(BEG:END), FROM, ERROR  )
               IF ( ERROR .EQ. ' ' ) THEN
                  HAVFRM = .TRUE.
               ELSE
                  CALL SETMSG ( '''From'' time ''#'' provided with '//
     .                          'the -from option is not a valid '  //
     .                          'time string.'                       )
                  CALL ERRCH  ( '#', PASS1(BEG:END)                  )
                  CALL SIGERR ( 'SPICE(BADFROMTIME)'                 )
               END IF
            ELSE
               CALL SETMSG ( 'No ''from'' time was following '      //
     .                       'the -from option.'                     )
               CALL SIGERR ( 'SPICE(NOFROMTIME)'                     )
            END IF
 
         ELSE IF ( PASS1(BEG:END) .EQ. FTO   ) THEN
C
C           Filter by coverage over interval FROM:TO.
C
            START = END + 1
 
            CALL FNDNWD ( PASS1, START,   BEG, END    )
 
            IF ( BEG .GT. 0 ) THEN
               CALL TPARSE ( PASS1(BEG:END), TO,  ERROR  )
               IF ( ERROR .EQ. ' ' ) THEN
                  HAVTO = .TRUE.
               ELSE
                  CALL SETMSG ( '''To'' time ''#'' provided with '  //
     .                          'the -to option is not a valid '    //
     .                          'time string.'                       )
                  CALL ERRCH  ( '#', PASS1(BEG:END)                  )
                  CALL SIGERR ( 'SPICE(BADTOTIME)'                   )
               END IF
            ELSE
               CALL SETMSG ( 'No ''to'' time was following '        //
     .                       'the -to option.'                       )
               CALL SIGERR ( 'SPICE(NOTOTIME)'                       )
            END IF
 
         ELSE IF ( PASS1(BEG:END) .EQ. FAT   ) THEN
C
C           Filter by coverage over a specific epoch.
C
            START = END + 1
 
            CALL FNDNWD ( PASS1, START,   BEG,  END    )
 
            IF ( BEG .GT. 0 ) THEN
               CALL TPARSE ( PASS1(BEG:END), WHEN, ERROR  )
               IF ( ERROR .EQ. ' ' ) THEN
                  AT = .TRUE.
               ELSE
                  CALL SETMSG ( '''At'' time ''#'' provided with '  //
     .                          'the -at option is not a valid '    //
     .                          'time string.'                       )
                  CALL ERRCH  ( '#', PASS1(BEG:END)                  )
                  CALL SIGERR ( 'SPICE(BADATTIME)'                   )
               END IF
            ELSE
               CALL SETMSG ( 'No ''at'' time was following '        //
     .                       'the -at option.'                       )
               CALL SIGERR ( 'SPICE(NOATTIME)'                       )
            END IF
 
         ELSE IF ( PASS1(BEG:END) .EQ. FSEC ) THEN
C
C           Round inward to the nearest second.
C
            ROUND  = .TRUE.
            INTVAL = MIN ( INTVAL, 1.0D0 )
 
         ELSE IF ( PASS1(BEG:END) .EQ. FMIN ) THEN
C
C           Round inward to the nearest minute.
C
            ROUND  = .TRUE.
            INTVAL = MIN ( INTVAL, 60.0D0 )
 
         ELSE IF ( PASS1(BEG:END) .EQ. FHOUR ) THEN
C
C           Round inward to the nearest hour.
C
            ROUND  = .TRUE.
            INTVAL = MIN ( INTVAL, 3600.0D0 )
 
         ELSE IF ( PASS1(BEG:END) .EQ. FDAY ) THEN
C
C           Round inward to the nearest day.
C
            ROUND  = .TRUE.
            INTVAL = MIN ( INTVAL, 86400.0D0 )
 
         ELSE IF ( BEG .EQ. END ) THEN
C
C           '-' by itself is no an option.
C
            CALL WRITIT ( '''-'' by itself is not a recognized option.')
            BEG  = LEN(PASS1)
 
         ELSE
C
C           This is a restriction flag. Find out the object that we
C           want to restrict relative to.
C
            SAVBEG = BEG
            SAVEND = END
            IF (       PASS1(BEG:BEG+2) .EQ. FSBCEN
     .           .AND. BEG+2            .LT. END    ) THEN
               REF = 2
               BEG = BEG + 3
            ELSE IF (      PASS1(BEG:BEG+2) .EQ. FSBBOD
     .               .AND. BEG+2           .LT. END    ) THEN
 
               REF = 1
               BEG = BEG + 3
            ELSE
               REF = 1
               BEG = BEG + 1
            END IF
 
C
C           Items that begin with '-' that are not one of
C           the previous items are regarded as a request
C           to summarize only for particular items.  However,
C           we need to recognize this item.  If we don't recognize
C           it we say so.
C
            IF ( BEINT ( PASS1(BEG:END) ) ) THEN
 
               CALL NPARSI   ( PASS1(BEG:END), VALUE, ERROR, PTR )
 
               ULIST        = .TRUE.
               BODY(ID1)    = VALUE
               BODY(ID2)    = VALUE
               BODY(BEGNAM) = BEG
               BODY(ENDNAM) = END
               BODY(REFTO ) = REF
               BODY(MATCHS) = 0
 
               CALL OBJADD ( BODY, BODLST, BOD )
 
            ELSE IF (       PASS1(BEG:BEG) .EQ. '['
     .                .AND. PASS1(END:END) .EQ. ']'
     .                .AND. POS  ( PASS1(1:END), ':', BEG ) .GT. 0
     .                .AND. END - BEG .GE. 3  ) THEN
 
C
C              Here's the deal, the integer range should be specified
C              as [low:hi].  We allow either end to be left out
C              to indicate no restriction on that end of the interval.
C
               LOW   = INTMIN ()
               HI    = INTMAX ()
 
               B     = BEG + 1
               OK    = .FALSE.
 
               CALL LX4SGN ( PASS1, B, E, SIZE )
 
               IF ( SIZE .GT. 0 ) THEN
 
                  CALL NPARSI ( PASS1(B:E), LOW, ERROR, PTR )
                  B = E + 2
 
                  IF ( B .EQ. END ) THEN
                     OK = .TRUE.
                  ELSE
                     E  = END - 1
 
                     IF ( BEINT ( PASS1(B:E) ) ) THEN
                        CALL NPARSI ( PASS1(B:E), HI, ERROR, PTR )
                        OK = .TRUE.
                     END IF
 
                  END IF
 
C
C              There was not an initial integer for a lower
C              bound of the numeric range.  See if there's an upper
C              bound..
C
               ELSE
 
                  B = BEG+2
                  E = END-1
 
                  IF ( BEINT( PASS1(B:E) ) ) THEN
                     CALL NPARSI ( PASS1(B:E), HI, ERROR, PTR )
                     OK = .TRUE.
                  END IF
 
               END IF
 
               IF ( .NOT. OK ) THEN
 
                  CALL WRITIT ( ''''//PASS1(SAVBEG:SAVEND)//''' '//
     .                          'is not recognized.' )
 
               ELSE
                  ULIST = .TRUE.
                  BODY(ID1)    = MIN( LOW, HI )
                  BODY(ID2)    = MAX( LOW, HI )
                  BODY(BEGNAM) = BEG
                  BODY(ENDNAM) = END
                  BODY(MATCHS) = 0
                  BODY(REFTO ) = REF
                  CALL OBJADD ( BODY, BODLST, BOD )
               END IF
 
            ELSE
 
C
C              Restriction is given as a name. Depending on whether
C              this run summarizes SPKs and PCKs, map it to ID using
C              BODN2C or FRINFO. (Note that GOTSPK and GOTPCK cannot be
C              both .TRUE. at this point but they can both be .FALSE.;
C              if they are both .FALSE. the program will eventually
C              fall through to signaling exception that no files were
C              provided.)
C
               IF ( GOTSPK ) THEN
 
C
C                 See if it is a name that we can recognize 'as is'.
C
                  CALL BODN2C( PASS1(BEG:END), VALUE, FND )
                  IF ( .NOT. FND ) THEN
C
C                    If not, replace underscores with blanks and try
C                    again.
C
                     CALL REPLCH( PASS1(BEG:END), '_', ' ',
     .                            PASS1(BEG:END) )
                     CALL BODN2C( PASS1(BEG:END), VALUE, FND )
                  END IF
 
               END IF
 
               IF ( GOTPCK ) THEN
 
C
C                 Map frame name to ID. If frame is unknown, FRMNAM will
C                 return 0.
C
                  CALL NAMFRM( PASS1(BEG:END), VALUE )
                  IF ( VALUE .NE. 0 ) THEN
                     FND = .TRUE.
                  ELSE
                     FND = .FALSE.
                  END IF
 
C
C                 If this restriction is on the body, we need the frame
C                 class ID rather than the frame ID.
C
                  IF ( REF .EQ. 1 ) THEN
                     CALL FRINFO ( VALUE, FCENT, CLASS, CLSSID, FND )
                     VALUE = CLSSID
                  END IF
 
               END IF
 
C
C              Set restriction or report bad option only if some
C              files will be summarized.
C
               IF ( GOTSPK .OR. GOTPCK ) THEN
 
                  IF ( FND ) THEN
                     ULIST        = .TRUE.
                     BODY(ID1)    = VALUE
                     BODY(ID2)    = VALUE
                     BODY(BEGNAM) = BEG
                     BODY(ENDNAM) = END
                     BODY(MATCHS) = 0
                     BODY(REFTO ) = REF
                     CALL OBJADD ( BODY, BODLST, BOD )
                  ELSE
                     CALL WRITIT ( ''''//PASS1(SAVBEG:SAVEND)//''' '//
     .                             'is not recognized.' )
                  END IF
 
               END IF
 
            END IF
 
         END IF
C
C        Locate the next word.
C
         START = END + 1
         CALL FNDNWD ( PASS1, START, BEG, END )
 
      END DO
 
C
C     If only version display was requested, stop because it has
C     already been displayed.
C
      IF ( VRSN ) THEN
         STOP
      END IF
 
C
C     If help display was requsted, display help text and stop.
C
      IF ( HELP ) THEN
 
         DO I = 1, NHTEXT
            CALL WRITIT ( HTEXT(I) )
         END DO
         STOP
 
      END IF
 
C
C     Reset rounding flag if time should be output in any format
C     other than calendar ET (default).
C
      IF ( TIMTYP .NE. 'ETCAL' ) THEN
         ROUND  = .FALSE.
      END IF
 
C
C     Determine what the user wants us to do for time filtering.
C     "-from" and "-to" together give us a range (whether or not they
C     are specified in the right order). "-from" or "-to" by itself is
C     equivalent to "-at". "-at" takes precedence over any combination
C     of "-from" and "-to".
C
      IF      (        HAVFRM .AND.       HAVTO ) THEN
 
         IF ( FROM .GT. TO ) THEN
            CALL SWAPD ( FROM, TO )
         END IF
         FROMTO = .TRUE.
 
      ELSE IF (        HAVFRM .AND. .NOT. HAVTO ) THEN
 
         TO     = FROM
         FROMTO = .TRUE.
 
      ELSE IF (  .NOT. HAVFRM .AND.       HAVTO ) THEN
 
         FROM   = TO
         FROMTO = .TRUE.
 
      END IF
 
      IF ( AT ) THEN
 
         FROM   = WHEN
         TO     = WHEN
         FROMTO = .TRUE.
 
      END IF
 
C
C     The following are used as indexes into the 4-dimensional
C     array used to hold the "formats" for the names of objects.
C
      NUM = 1
      O   = 1
      T   = 1
      C   = 1
 
      IF ( NONLY ) THEN
         NUM = 2
      END IF
 
      IF ( OBNAM ) THEN
         O = 2
      END IF
 
      IF ( TDSP ) THEN
         T = 2
      END IF
 
      IF ( CNTR ) THEN
         C = 2
      END IF
 
      FMTPIC = FRMAT ( NUM, C, O, T )
 
C
C     Initialize the cells.
C
      CALL SSIZEC ( MAXBOD, WINSYM )
      CALL SSIZEI ( MAXBOD, WINPTR )
      CALL SSIZED ( WINRM,  WINVAL )
 
      CALL SSIZED ( LRGWIN, FILWIN )
      CALL SSIZED ( 2,      SEGWIN )
      CALL SSIZED ( LRGWIN, TMPWIN )
 
      CALL OBJINL ( OBJSIZ, MAXBOD, OBJLIS )
 
C
C     Now run through the files specified on the command line and/or
C     the list file and collect summary information.
C
      START  = 1
      CALL FNDNWD ( PASS2, START, BEG, END )
 
C
C     If we didn't have anything in the PASS2 string, we must have a
C     list of files in a file of SPK names.  Read the first line of
C     that file.
C
      IF ( BEG .EQ. 0 .AND. SFILE ) THEN
         PASS2 = ' '
 
         CALL RDNBL ( SRCFIL, PASS2, EOF )
         CALL REPLCH( PASS2, TABCHR, ' ', PASS2 )
 
         IF ( .NOT. EOF ) THEN
            CALL FNDNWD ( PASS2, 1, BEG, END )
         END IF
 
      END IF
 
C
C     Process files one by one until we run out of file names.
C
      DO WHILE ( BEG .NE. 0  )
 
C
C        Get this file's architecture and type.
C
         CALL GETFAT ( PASS2(BEG:END), ARCH, KERTYP )
 
C
C        Is this a DAF file?
C
         IF ( ARCH .NE. 'DAF' ) THEN
 
C
C           Apparently not. Depending on the file architecture, either
C           signal an error or do nothing (i.e. proceed to the next
C           file).
C
            IF ( ARCH .EQ. 'XFR' .OR. ARCH .EQ. 'DEC' ) THEN
 
C
C              Signal an error, reporting that this is a transfer file.
C
               CALL SETMSG ( 'Kernel ''#'' is in transfer format. ' //
     .                       'It must be converted to binary '      //
     .                       'format to be summarized using BRIEF.' )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL SIGERR ( 'SPICE(TRANSFERFORMAT)'                )
 
            ELSE IF ( ARCH .EQ. 'DAS' .AND. KERTYP .EQ. 'EK' ) THEN
 
C
C              Signal an error, reporting that this is an EK file.
C
               CALL SETMSG ( 'Kernel ''#'' is a binary EK and, '    //
     .                       'therefore, cannot be summarized '     //
     .                       'using BRIEF. Use SPACIT or '          //
     .                       'INSPEKT to summarize this file.'      )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL ERRCH  ( '#',  ARCH                             )
               CALL ERRCH  ( '#',  KERTYP                           )
               CALL SIGERR ( 'SPICE(EKFILE)'                        )
 
            ELSE IF ( ARCH .EQ. 'DAS' .OR. ARCH .EQ. 'TE1' ) THEN
 
C
C              Signal an error, reporting that this is a file with
C              a wrong architecture.
C
               CALL SETMSG ( 'Kernel ''#'' is not a binary SPK or ' //
     .                       'PCK file and, therefore, cannot be '  //
     .                       'summarized using BRIEF. It is a '     //
     .                       '''#/#'' file.'                        )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL ERRCH  ( '#',  ARCH                             )
               CALL ERRCH  ( '#',  KERTYP                           )
               CALL SIGERR ( 'SPICE(BADARCHITECTURE)'               )
 
            ELSE
 
C
C              Do nothing for all other architectures -- KPL, ASC, TXT,
C              and ?,  -- assuming that this file either has already
C              been loaded (if its name came from the command line) or
C              can be ignored (if its name came from the list file).
C
 
            END IF
 
         ELSE
 
C
C           This file is a DAF file. Report an error for all DAFs that
C           are not SPKs or PCKs.
C
            IF ( KERTYP .EQ. 'CK' ) THEN
 
               CALL SETMSG ( 'Kernel ''#'' is a CK and, therefore, '//
     .                       'cannot be summarized using BRIEF. '   //
     .                       'Use CKBRIEF to summarize this file.'  )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL SIGERR ( 'SPICE(CKFILE)'                        )
 
            ELSE IF ( KERTYP .NE. 'SPK' .AND. KERTYP .NE. 'PCK' ) THEN
 
               CALL SETMSG ( 'Kernel ''#'' is a DAF-based binary '  //
     .                       '''#'' file; kernel must be SPK or '   //
     .                       'PCK in order for BRIEF to summarize ' //
     .                       'it.'               )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL ERRCH  ( '#',  KERTYP                           )
               CALL SIGERR ( 'SPICE(BADKERNELTYPE)'                 )
 
            END IF
 
         END IF
 
C
C        Collect summary info and display it only for binary SPKs and
C        PCKs.
C
         IF (    ARCH   .EQ. 'DAF'   .AND.
     .        (( KERTYP .EQ. 'SPK' ) .OR. ( KERTYP .EQ. 'PCK' )) ) THEN
 
C
C           Open the next file. Start forward search and find next
C           segment.
C
            CALL DAFOPR (PASS2(BEG:END),  HANDLE)
            CALL DAFBFS (HANDLE       )
            CALL DAFFNA (FND          )
 
            DO WHILE (FND)
 
               CALL SCARDD (0, SEGWIN)
 
C
C              Unpack segment descriptor and set body, center, and
C              frame IDs. For PCKs frame ID is not applicable, so force
C              it to 1 (J2000) to avoid '*' in summary display.
C
               CALL DAFGS  (SEGSUM)
 
               IF      ( KERTYP .EQ. 'SPK' ) THEN
 
                  CALL DAFUS  (SEGSUM, ND, NISPK, DC, IC)
                  ID        = IC(1)
                  CENT      = IC(2)
                  FRAME     = IC(3)
 
               ELSE IF ( KERTYP .EQ. 'PCK' ) THEN
 
                  CALL DAFUS  (SEGSUM, ND, NIPCK, DC, IC)
                  ID        = IC(1)
                  CENT      = IC(2)
                  FRAME     = 1
 
               END IF
 
               OBJECT(1) = ID
               OBJECT(2) = CENT
 
C
C              If we are summarizing from a list of input bodies,
C              find out if this body is in the list to summarize.
C
               IF ( ULIST ) THEN
 
C
C                 Use the "object search by function" to see if
C                 we've got the current ID in the list of bodies
C                 to restrict the summary to.
C
                  KEEP = IDSET  ( ID, CENT )
                  CALL   OBJSBF ( IDMCH, 1, BODLST, BOD, KEEP )
C
C                 We will need the object BOD in a bit to update
C                 the number of times we've encountered this
C                 body-center pair.
C
               ELSE
                  KEEP = .TRUE.
               END IF
 
C
C              If this segment is a keeper, construct the window
C              for the segment.
C
               IF ( KEEP ) THEN
 
                  CALL WNINSD (DC(1), DC(2), SEGWIN)
 
C
C                 Determine the class of the reference frame
C                 attached to this body.  We report only 2,
C                 inertial (1) and non-inertial (2).  If at any
C                 time the reference frame for this object is
C                 non-inertial we never go back to inertial.
C
                  CLASS     = 0
                  CALL FRINFO ( FRAME, FCENT, CLASS, CLSSID, FOUND )
 
                  IF ( CLASS .NE. 1 ) THEN
                     CLASS = 2
                  END IF
 
                  OBJECT(OBJSIZ) = CLASS
 
C
C                 See if we already have this "object".  If not
C                 add it to the list of objects and increment the
C                 count of objects.
C
                  CALL OBJFND ( OBJECT, 1, OBJLIS, OBJ, FOUND )
 
                  IF ( .NOT. FOUND ) THEN
                     CALL OBJADD ( OBJECT, OBJLIS, OBJ )
                  ELSE
 
C
C                    Update the reference frame information.
C
                     CALL OBJCF2 ( BIGGER, CLASS, OBJ, OBJSIZ, OBJLIS )
 
                  END IF
 
C
C                 Construct the "name" we will use to represent
C                 this "object" in the symbol table of windows.
C
                  CALL MAKNAM ( OBJECT, OBJSIZ, OBNAM, KERTYP, OBJNAM )
 
C
C                 Look up the window of coverage already stored for
C                 this object.
C
                  CALL SYGETD ( OBJNAM, WINSYM,    WINPTR, WINVAL,
     .                          N,      FILWIN(1), FND )
 
                  IF (.NOT. FND) THEN
                     N = 0
                  END IF
 
                  CALL SCARDD (N,      FILWIN)
C
C                 Union the current segment interval with the current
C                 window for this object, put the result back into
C                 the table of windows.
C
                  CALL WNUNID (SEGWIN, FILWIN, TMPWIN)
 
                  N = CARDD(TMPWIN)
 
                  CALL SYPUTD (OBJNAM, TMPWIN(1), N,
     .                         WINSYM, WINPTR, WINVAL)
C
C                 Update the BODLST if we are using a list to
C                 filter the summary.
C
                  IF ( ULIST ) THEN
 
                     IF ( FROMTO ) THEN
 
                        IF ( WNINCD ( FROM, TO, TMPWIN ) ) THEN
 
C
C                          This block used to call OBJCF1 on the BOD
C                          object returned by an earlier call to
C                          OBJSBF. This resulted in only that one
C                          object being "tagged" as matching the
C                          current body/center, producing unnecessary
C                          "There is no data for:" reports for other
C                          matching restrictions. The loop below checks
C                          every object for match and "tags" all those
C                          that do match.
C
                           NBOD = OBJACT ( BODLST )
                           SIZE = BODLST ( RMPOBJ ) - 1
                           DO I = 1, NBOD
                              CALL OBJNTH( BODLST, I, BOD, FOUND )
                              IF ( FOUND .AND.
     .                             IDMCH(BODLST(BOD(1)+1), SIZE) ) THEN
                                 CALL OBJCF1( INC, BOD, MATCHS, BODLST)
                              END IF
                           END DO
 
                        END IF
 
                     ELSE
 
C
C                       This block used to call OBJCF1 on the BOD
C                       object returned by an earlier call to OBJSBF.
C                       This resulted in only that one object being
C                       "tagged" as matching the current body/center,
C                       producing unnecessary "There is no data for:"
C                       reports for other matching restrictions. The
C                       loop below checks every object for match and
C                       "tags" all those that do match.
C
                        NBOD = OBJACT ( BODLST )
                        SIZE = BODLST ( RMPOBJ ) - 1
                        DO I = 1, NBOD
                           CALL OBJNTH( BODLST, I, BOD, FOUND )
                           IF ( FOUND .AND.
     .                          IDMCH(BODLST(BOD(1)+1), SIZE) ) THEN
                              CALL OBJCF1 ( INC, BOD, MATCHS, BODLST )
                           END IF
                        END DO
 
                     END IF
 
                  END IF
 
               END IF
 
C
C              Find the next segment in the kernel.
C
               CALL DAFFNA (FND)
 
            END DO
 
            CALL DAFCLS (HANDLE)
 
            NDONE = NDONE + 1
 
            IF ( .NOT. ALL ) THEN
 
C
C              If the use specified time restrictions, we filter
C              the collected objects so that we limit them
C              to those that have coverage during the times specified.
C
               IF ( AT .OR. FROMTO ) THEN
 
                  CALL FILTEM ( KERTYP, OBNAM,  OBJLIS, FROM, TO,
     .                          FILWIN, TMPWIN,
     .                          WINSYM, WINPTR, WINVAL )
 
 
               END IF
C
C              If the intervals are supposed to be rounded inward,
C              now is the time to do it.
C
               IF ( ROUND ) THEN
 
                  CALL RNDEM ( KERTYP, OBNAM,  OBJLIS, OBJSIZ, INTVAL,
     .                         FILWIN, WINSYM, WINPTR, WINVAL )
 
               END IF
 
C
C              That's the end of the filtering.  Now display
C              what we've got.
C
               CALL WRITIT ( ' ' )
               CALL WRITIT ( 'Summary for: ' // PASS2(BEG:END) )
               CALL WRITIT ( ' ' )
 
               IF ( ULIST ) THEN
 
 
C
C                 If any objects are not represented in this
C                 file say so.
C
                  NBOD  = OBJACT ( BODLST )
                  FIRST = .TRUE.
 
                  DO I = 1, NBOD
 
                     CALL OBJNTH ( BODLST, I, BOD,       FND )
                     CALL OBJGET ( BOD,    BODLST, BODY      )
 
                     IF ( BODY(MATCHS) .EQ. 0 ) THEN
 
                        B    = BODY(BEGNAM)
                        E    = BODY(ENDNAM)
                        FRST = BODY(ID1)
                        LAST = BODY(ID2)
                        ITEM = BODY(REFTO)
C
C                       See if we had a range.
C
                        IF ( FRST .EQ. LAST ) THEN
 
                           IF      ( GOTSPK ) THEN
                              IF ( ITEM .EQ. 1 ) THEN
                                 STRING = '  for body ''' // PASS1(B:E)
     .                                    // ''''
                              ELSE
                                 STRING = '  w.r.t. center ''' //
     .                                    PASS1(B:E) // ''''
                              END IF
                           ELSE IF ( GOTPCK ) THEN
                              IF ( ITEM .EQ. 1 ) THEN
                                 STRING = '  for frame ''' // PASS1(B:E)
     .                                    // ''''
                              ELSE
                                 STRING = '  w.r.t. frame ''' //
     .                                    PASS1(B:E) // ''''
                              END IF
                           ELSE
                              IF ( ITEM .EQ. 1 ) THEN
                                 STRING = '  for ID ''' // PASS1(B:E)
     .                                    // ''''
                              ELSE
                                 STRING = '  w.r.t. ID ''' //
     .                                    PASS1(B:E) // ''''
                              END IF
                           END IF
 
                        ELSE
 
                           IF      ( GOTSPK ) THEN
                              IF ( ITEM .EQ. 1 ) THEN
                                 STRING = '  for bodies in ''' //
     .                                    PASS1(B:E) // ''' ID range'
                              ELSE
                                 STRING = '  w.r.t. centers in ''' //
     .                                    PASS1(B:E) // ''' ID range'
                              END IF
                           ELSE IF ( GOTPCK ) THEN
                              IF ( ITEM .EQ. 1 ) THEN
                                 STRING = '  for frames in ''' //
     .                                    PASS1(B:E) // ''' ID range'
                              ELSE
                                 STRING = '  w.r.t. frames in ''' //
     .                                    PASS1(B:E) // ''' ID range'
                              END IF
                           ELSE
                              IF ( ITEM .EQ. 1 ) THEN
                                 STRING = '  for IDs in ''' //
     .                                    PASS1(B:E) // ''' ID range'
                              ELSE
                                 STRING = '  w.r.t. IDs in ''' //
     .                                    PASS1(B:E) // ''' ID range'
                              END IF
                           END IF
 
                        END IF
 
                        IF      ( AT )     THEN
 
                           CALL ETCAL( FROM, ETSTR1 )
                           CALL SUFFIX( ' covering ET ''' //
     .                                  ETSTR1(:RTRIM(ETSTR1)) //
     .                                  '''', 0, STRING )
 
                        ELSE IF ( FROMTO ) THEN
 
                           CALL ETCAL( FROM, ETSTR1 )
                           CALL ETCAL( TO,   ETSTR2 )
                           CALL SUFFIX( ' covering from ET ''' //
     .                                  ETSTR1(:RTRIM(ETSTR1)) //
     .                                  ''' to ET ''' //
     .                                  ETSTR2(:RTRIM(ETSTR2)) //
     .                                  '''', 0, STRING )
 
                        END IF
 
                        IF ( FIRST ) THEN
                           FIRST = .FALSE.
                           CALL WRITIT ( 'There is no data: ' )
                        END IF
 
                        CALL WRITIT ( STRING )
 
                     END IF
                  END DO
 
                  IF ( .NOT. FIRST ) THEN
                     CALL WRITIT ( ' ' )
                  END IF
 
               END IF
 
C
C              Compress object list and get the number of objects that
C              we still have in it.
C
               CALL    OBJCMP ( OBJLIS )
               NOBJ =  OBJACT ( OBJLIS )
 
C
C              If the number of objects is zero, check if filtering by
C              time and body have occurred and finish "No data ..."
C              reporting.
C
               IF ( NOBJ .EQ. 0 .AND. .NOT. ULIST ) THEN
 
                  CALL WRITIT ( 'There is no data: ' )
 
                  IF      ( AT )     THEN
 
                     CALL ETCAL( FROM, ETSTR1 )
                     CALL WRITIT ( '  covering ET ''' //
     .                             ETSTR1(:RTRIM(ETSTR1)) // '''' )
                     CALL WRITIT ( ' ' )
 
                  ELSE IF ( FROMTO ) THEN
 
                     CALL ETCAL( FROM, ETSTR1 )
                     CALL ETCAL( TO,   ETSTR2 )
                     CALL WRITIT ( '  covering from ET ''' //
     .                             ETSTR1(:RTRIM(ETSTR1)) //
     .                             ''' to ET ''' //
     .                             ETSTR2(:RTRIM(ETSTR2)) // '''' )
                     CALL WRITIT ( ' ' )
 
                  END IF
 
               END IF
 
C
C              We are going to sort the object list.  We just rip off
C              the Shell sort algorithm to accomplish this.
C
               GAP  =  NOBJ / 2
 
               DO WHILE ( GAP .GT. 0 )
 
                  DO I = GAP+1, NOBJ
 
                     J = I - GAP
 
                     DO WHILE ( J .GT. 0 )
                        JG = J + GAP
 
                        CALL OBJNTH ( OBJLIS, J,  OBJ,  FOUND )
                        CALL OBJNTH ( OBJLIS, JG, OBJG, FOUND )
 
                        CALL OBJGET ( OBJ,    OBJLIS, OBJCT  )
                        CALL OBJGET ( OBJG,   OBJLIS, OBJCTG )
                        CALL MAKNAM ( OBJCT,  OBJSIZ, OBNAM, KERTYP,
     .                                OBJNM )
                        CALL MAKNAM ( OBJCTG, OBJSIZ, OBNAM, KERTYP,
     .                                OBJNMG )
 
                        IF ( LLE ( OBJNM, OBJNMG ) ) THEN
                           J = 0
                        ELSE
                           CALL OBJSET ( OBJG, OBJCT,  OBJLIS )
                           CALL OBJSET ( OBJ,  OBJCTG, OBJLIS )
                        END IF
 
                        J = J - GAP
                     END DO
 
                  END DO
 
                  GAP = GAP / 2
 
               END DO
 
C
C              display what we have so far and re-initialize
C              the window table.
C
               CALL DISPLY ( FMTPIC, TDSP,   GDSP, SDSP, OBNAM, OBJLIS,
     .                       WINSYM, WINPTR, WINVAL, TIMTYP, KERTYP )
 
               CALL SCARDC ( 0,      WINSYM)
               CALL SCARDI ( 0,      WINPTR)
               CALL SCARDD ( 0,      WINVAL)
               CALL SCARDD ( 0,      FILWIN)
               CALL SCARDD ( 0,      SEGWIN)
               CALL SCARDD ( 0,      TMPWIN)
               CALL OBJINL ( OBJSIZ, MAXBOD, OBJLIS )
 
               NBOD = OBJACT ( BODLST )
 
               DO I = 1, NBOD
                  CALL OBJNTH( BODLST, I, BOD, FOUND )
                  CALL OBJMOD( BOD, MATCHS, 0, BODLST )
               END DO
 
            END IF
 
         END IF
 
C
C        Get the next file.
C
         START = END + 1
         CALL FNDNWD ( PASS2, START, BEG, END )
 
C
C        If we ran out of file names in the PASS2 list, we
C        look in the source file for the next file (if there
C        is such a file).
C
         IF ( BEG .EQ. 0 .AND. SFILE ) THEN
 
            PASS2 = ' '
 
            CALL RDNBL ( SRCFIL, PASS2, EOF )
            CALL REPLCH( PASS2, TABCHR, ' ', PASS2 )
 
            IF ( .NOT. EOF ) THEN
               CALL FNDNWD ( PASS2, 1, BEG, END )
            ELSE
               SFILE = .FALSE.
            END IF
 
         END IF
 
C
C        If we didn't find the next file in the list file, look for it
C        among SPKs loaded via meta-kernels.
C
         IF ( BEG .EQ. 0 .AND. SCOUNT .NE. 0 ) THEN
            SINDEX = SINDEX + 1
            CALL KDATA ( SINDEX, 'SPK',
     .                   PASS2, FILTYP, SOURCE, HANDLE, FOUND )
            IF ( FOUND ) THEN
               CALL FNDNWD ( PASS2, 1, BEG, END )
               GOTSPK = .TRUE.
            END IF
         END IF
 
      END DO
 
C
C     Check if any SPKs and PCKs files were processed. If not, signal
C     an error.
C
      IF ( NDONE .EQ. 0 ) THEN
         CALL SETMSG ( 'No binary SPK or PCK files to summarize '  //
     .                 'were provided to the program.'             )
         CALL SIGERR ( 'SPICE(NOFILES)'                            )
      END IF
 
C
C     Display summary for all files as treated as one.
C
      IF ( ALL ) THEN
 
         CALL WRITIT ( ' ' )
         CALL WRITIT ('Summary for all files.' )
         CALL WRITIT ( ' ' )
 
C
C        Reset KERTYP based on GOTSPK and GOTPCK.
C
         IF      ( GOTSPK ) THEN
            KERTYP = 'SPK'
         ELSE IF ( GOTPCK ) THEN
            KERTYP = 'PCK'
         ELSE
            KERTYP = 'UNK'
         END IF
 
C
C        If the use specified time restrictions, we filter
C        the collected objects so that we limit them
C        to those that have coverage during the times specified.
C
         IF ( AT .OR. FROMTO ) THEN
 
            CALL FILTEM ( KERTYP, OBNAM,  OBJLIS, FROM, TO,
     .                    FILWIN, TMPWIN,
     .                    WINSYM, WINPTR, WINVAL )
 
         END IF
 
         IF ( ROUND ) THEN
C
C           Round all of the intervals of all windows.
C
            CALL RNDEM ( KERTYP, OBNAM,  OBJLIS, OBJSIZ, INTVAL, FILWIN,
     .                   WINSYM, WINPTR, WINVAL )
 
 
         END IF
C
C        That's the end of the filtering.  Now display
C        what we've got.
C
         IF ( ULIST ) THEN
 
C
C           If any objects are not represented in this
C           file say so.
C
            FIRST = .TRUE.
            NBOD  =  OBJACT ( BODLST )
 
            DO I = 1, NBOD
 
               CALL OBJNTH ( BODLST, I, BOD, FND  )
               CALL OBJGET ( BOD,    BODLST, BODY )
 
               IF ( BODY(MATCHS) .EQ. 0 ) THEN
 
                  B    = BODY(BEGNAM)
                  E    = BODY(ENDNAM)
                  FRST = BODY(ID1)
                  LAST = BODY(ID2)
                  ITEM = BODY(REFTO)
C
C                 See if we had a range.
C
                  IF ( FRST .EQ. LAST ) THEN
 
                     IF      ( GOTSPK ) THEN
                        IF ( ITEM .EQ. 1 ) THEN
                           STRING = '  for body ''' // PASS1(B:E)
     .                              // ''''
                        ELSE
                           STRING = '  w.r.t. center ''' //
     .                              PASS1(B:E) // ''''
                        END IF
                     ELSE IF ( GOTPCK ) THEN
                        IF ( ITEM .EQ. 1 ) THEN
                           STRING = '  for frame ''' // PASS1(B:E)
     .                              // ''''
                        ELSE
                           STRING = '  w.r.t. frame ''' //
     .                              PASS1(B:E) // ''''
                        END IF
                     ELSE
                        IF ( ITEM .EQ. 1 ) THEN
                           STRING = '  for ID ''' // PASS1(B:E)
     .                              // ''''
                        ELSE
                           STRING = '  w.r.t. ID ''' //
     .                              PASS1(B:E) // ''''
                        END IF
                     END IF
 
                  ELSE
 
                     IF      ( GOTSPK ) THEN
                        IF ( ITEM .EQ. 1 ) THEN
                           STRING = '  for bodies in ''' // PASS1(B:E)
     .                              // ''' ID range'
                        ELSE
                           STRING = '  w.r.t. centers in ''' //
     .                              PASS1(B:E) // ''' ID range'
                        END IF
                     ELSE IF ( GOTPCK ) THEN
                        IF ( ITEM .EQ. 1 ) THEN
                           STRING = '  for frames in ''' // PASS1(B:E)
     .                              // ''' ID range'
                        ELSE
                           STRING = '  w.r.t. frames in ''' //
     .                              PASS1(B:E) // ''' ID range'
                        END IF
                     ELSE
                        IF ( ITEM .EQ. 1 ) THEN
                           STRING = '  for IDs in ''' // PASS1(B:E)
     .                              // ''' ID range'
                        ELSE
                           STRING = '  w.r.t. IDs in ''' //
     .                              PASS1(B:E) // ''' ID range'
                        END IF
                     END IF
 
                  END IF
 
                  IF      ( AT )     THEN
 
                     CALL ETCAL( FROM, ETSTR1 )
                     CALL SUFFIX( ' covering ET ''' //
     .                            ETSTR1(:RTRIM(ETSTR1)) //
     .                            '''', 0, STRING )
 
                  ELSE IF ( FROMTO ) THEN
 
                     CALL ETCAL( FROM, ETSTR1 )
                     CALL ETCAL( TO,   ETSTR2 )
                     CALL SUFFIX( ' covering from ET ''' //
     .                            ETSTR1(:RTRIM(ETSTR1)) //
     .                            ''' to ET ''' //
     .                            ETSTR2(:RTRIM(ETSTR2)) //
     .                            '''', 0, STRING )
 
                  END IF
 
                  IF ( FIRST ) THEN
                     FIRST = .FALSE.
                     CALL WRITIT ( 'There is no data: ' )
                  END IF
 
                  CALL WRITIT ( STRING )
 
               END IF
            END DO
 
            IF ( .NOT. FIRST ) THEN
               CALL WRITIT ( ' ' )
            END IF
 
         END IF
 
 
C
C        Compress object list and get the number of objects that
C        we still have in it.
C
         CALL    OBJCMP ( OBJLIS )
         NOBJ =  OBJACT ( OBJLIS )
 
C
C        If the number of objects is zero, check if filtering by
C        time and body have occurred and finish "No data ..."
C        reporting.
C
         IF ( NOBJ .EQ. 0 .AND. .NOT. ULIST ) THEN
 
            CALL WRITIT ( 'There is no data: ' )
 
            IF      ( AT )     THEN
 
               CALL ETCAL( FROM, ETSTR1 )
               CALL WRITIT ( '  covering ET ''' //
     .                       ETSTR1(:RTRIM(ETSTR1)) // '''' )
               CALL WRITIT ( ' ' )
 
            ELSE IF ( FROMTO ) THEN
 
               CALL ETCAL( FROM, ETSTR1 )
               CALL ETCAL( TO,   ETSTR2 )
               CALL WRITIT ( '  covering from ET ''' //
     .                       ETSTR1(:RTRIM(ETSTR1)) //
     .                       ''' to ET ''' //
     .                       ETSTR2(:RTRIM(ETSTR2)) // '''' )
               CALL WRITIT ( ' ' )
 
            END IF
 
         END IF
 
C
C        We are going to sort the object list.  We just rip off
C        the Shell sort algorithm to accomplish this.
C
         GAP  =  NOBJ / 2
 
         DO WHILE ( GAP .GT. 0 )
 
            DO I = GAP+1, NOBJ
 
               J = I - GAP
 
               DO WHILE ( J .GT. 0 )
                  JG = J + GAP
 
                  CALL OBJNTH ( OBJLIS, J,  OBJ,  FOUND )
                  CALL OBJNTH ( OBJLIS, JG, OBJG, FOUND )
 
                  CALL OBJGET ( OBJ,    OBJLIS, OBJCT  )
                  CALL OBJGET ( OBJG,   OBJLIS, OBJCTG )
                  CALL MAKNAM ( OBJCT,  OBJSIZ, OBNAM, KERTYP, OBJNM  )
                  CALL MAKNAM ( OBJCTG, OBJSIZ, OBNAM, KERTYP, OBJNMG )
 
                  IF ( LLE ( OBJNM, OBJNMG ) ) THEN
                     J = 0
                  ELSE
                     CALL OBJSET ( OBJG, OBJCT,  OBJLIS )
                     CALL OBJSET ( OBJ,  OBJCTG, OBJLIS )
                  END IF
 
                  J = J - GAP
               END DO
 
            END DO
 
            GAP = GAP / 2
 
         END DO
 
 
C
C        display what we have.
C
         CALL DISPLY ( FMTPIC, TDSP,   GDSP, SDSP, OBNAM, OBJLIS,
     .                 WINSYM, WINPTR, WINVAL, TIMTYP, KERTYP )
 
      END IF
 
C
C     Check out.
C
      CALL CHKOUT  ( 'BRIEF' )
 
C
C     Return with success status.
C
      CALL BYEBYE( 'SUCCESS' )
 
      END
 
 
C
C     Miscellaneous functions that don't deserve to have their own
C     source files.
C
      INTEGER FUNCTION INC ( A )
      INTEGER               A
      INC = A + 1
      RETURN
      END
 
      INTEGER FUNCTION BIGGER ( A, B )
      INTEGER               A
      INTEGER               B
 
      BIGGER = MAX ( A, B )
      RETURN
      END
 
 
      LOGICAL FUNCTION MCHBOC ( OBJECT, SIZE, ID, CENT )
      IMPLICIT NONE
 
      LOGICAL               IDMCH
      LOGICAL               IDSET
      INTEGER               OBJECT ( * )
      INTEGER               SIZE
      INTEGER               ID
      INTEGER               CENT
      INTEGER               REFTO
      PARAMETER           ( REFTO = 5 )
      INTEGER               REF ( 2 )
      SAVE                  REF
 
      MCHBOC = .FALSE.
 
      RETURN
 
      ENTRY IDMCH ( OBJECT, SIZE )
 
         IDMCH =        OBJECT(1) .LE. REF(OBJECT(REFTO))
     .            .AND. OBJECT(2) .GE. REF(OBJECT(REFTO))
 
         RETURN
 
      ENTRY IDSET ( ID, CENT )
 
 
         REF(1) = ID
         REF(2) = CENT
         IDSET  = .TRUE.
 
 
      RETURN
      END
