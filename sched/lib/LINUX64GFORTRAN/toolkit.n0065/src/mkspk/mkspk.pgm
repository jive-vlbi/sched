C$Procedure  MKSPK  ( Make SPK File of Type 5,8,9,10,12,13,15 or 17 )

      PROGRAM MKSPK
      
C$ Abstract
C
C     This program creates an SPK file of type 5, 8, 9, 10, 12, 13, 15
C     or 17 from a trajectory data provided in a text file in the form
C     of states, conic elements, equinoctial elements or NORAD two-line
C     element sets.
C
C     USAGE: mkspk  [-setup <setup file name>]
C                   [-input <input file name>]
C                   [-output <output file name>]
C                   [-append]
C                   [-u|-usage]
C                   [-h|-help]
C                   [-t|-template][<input data type> <output spk type>]
C     
C     If MKSPK is executed without -setup flag, a user will be
C     prompted for the name of setup file. 
C
C     If MKSPK is executed without -input and/or -output flags, then 
C     the  names of an input and/or output files must be provided in 
C     a setup file using corresponding keywords.
C
C     If output SPK file exists and MKSPK should be appending new 
C     data to it, then the -append flag or corresponding setup file 
C     keyword must be provided.
C
C     If MKSPK is executed with -u (-usage), -h (-help) or -t 
C     (-template) flag than usage, help or setup file template will
C     be displayed and the program will stop.
C
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     MKSPK User's Guide
C     SPK Required Reading
C     TIME Required Reading
C     POOL Required Reading
C
C$ Keywords
C
C     EPHEMERIS
C
C$ Declarations

      IMPLICIT       NONE
      
      INCLUDE        'mkspk.inc'

C$ Exceptions
C  
C     There are numerous exceptions handled by the program. Below is 
C     the list of exceptions handled in the main module. For the list
C     of exceptions handles by a particular modules, see the 
C     "Exceptions" section in the header of that module.
C
C     1) If input record parameters delimiter character
C        specified in setup file keyword is one of the characters
C        that can be used in a valid input time string and two
C        time tags (epoch and epoch of periapsis) are present in
C        an input record, then the error 'SPICE(CANTUSEPERIAPEPOCH)'
C        will be signaled.
C        
C     2) If start time required for the output SPK type 15
C        was not provided in the setup file keyword, then the
C        error 'SPICE(NOSTARTTIME4SPK15)' will be signaled.
C        
C     3) If stop time required for the output SPK type 15 was
C        not provided in the setup file keyword, then the error
C        'SPICE(NOSTOPTIME4SPK15)' will be signaled.
C        
C     4) If start time required for the output SPK type 17
C        was not provided in the setup file keyword, then the
C        error 'SPICE(NOSTARTTIME4SPK17)' will be signaled.
C           
C     5) If stop time required for the output SPK type 17 was
C        not provided in the setup file keyword, then the error
C        'SPICE(NOSTOPTIME4SPK17)' will be signaled.
C        
C     6) If total number of lines in the file is less than
C        then number of first lines to be ignored as specified in
C        setup file keyword, then the error 'SPICE(TOOFEWINPUTLINES)'
C        will be signaled.
C        
C     7) If the string found in the input file doesn't represent
C        a double precision number which it should, then the
C        error 'SPICE(NOTADPNUMBER)' will be signaled.
C        
C     8) If set of orbital elements specified in the keyword
C        of the setup file cannot be converted to standard SPICE
C        elements set, then the error 'SPICE(INCONSISTELEMENTS)'
C        or 'SPICE(INCOMPLETEELEMENTS)' will be signaled.
C        
C     9) If for SPK 8, 9, 12, 13 the epoch of the first input data 
C        file record is greater than the start time specified in the
C        setup file keyword, then the error 'SPICE(INCONSISTSTARTTIME)'
C        will be signaled.
C        
C     10) If for SPK 8, 9, 12, 13 the epoch of the first input data 
C        file record is greater than the stop time specified in the
C        setup file keyword, then the error 'SPICE(INCONSISTSTOPTIME)'
C        will be signaled.
C        
C     11) If for SPK 8, 9, 12, 13 the epoch of the last input data 
C        file record is smaller than the start time specified in the
C        setup file keyword, then the error 'SPICE(INCONSISTSTARTTIME)'
C        will be signaled.
C        
C     12) If the epoch of the last input data file record is
C        smaller than the stop time specified in the setup file
C        keyword, then the error 'SPICE(INCONSISTSTOPTIME)' will
C        be signaled.      
C
C     13) If the stop time specified in the setup file keyword is
C        smaller than the start time specified in the setup file
C        keyword, then the error 'SPICE(INVERSTARTSTOPTIME)' will 
C        be signaled.      
C
C     14) If the input data type is not applicable for output SPK
C        type or vice-versa, then the error 'SPICE(TYPESMISMATCH)' 
C        will be signaled.      
C
C     15) If appending to an existing file has not been requested  
C        using command line key or setup file keyword and output
C        file already exists, then the error 'SPICE(OUTPUTFILEEXISTS)' 
C        will be signaled.      
C
C     16) If appending to an existing file has been requested  
C        but existing output file is not an SPK, then the error 
C        'SPICE(OUTPUTISNOTSPK)' will be signaled.
C
C     17) If the time spacing between input data points was not 
C        constant for output types 8 and 12, then the 
C        'SPICE(UNEQUALTIMESTEP)' error will be signaled.
C
C     18) If the degree of Lagrange polynomial specified in the setup 
C        keyword is not a positive number or greater than MAXDEG, then 
C        the error 'SPICE(BADLAGRANGEDEGREE)' will be signaled.
C      
C     19) If the degree of Hermit polynomial specified in the setup 
C        keyword is not a positive number or greater than MAXDEG, then
C        the error 'SPICE(BADHERMITDEGREE)' will be signaled.
C      
C     20) If the input file contains records with duplicate time tags, 
C        then the error 'SPICE(DUPLICATETIMES)' will be signaled.
C      
C     21) If the input file contains records with times out of order, 
C        then the error 'SPICE(TIMESOUTOFORDER)' will be signaled.
C
C     22) If only one of the TLE-specific ID keywords is specified,
C        then the error 'SPICE(MISSINGTLEIDKEYWORD)' will be signaled.
C
C     23) If either the generic object ID or object name keyword is 
C         specified together with the TLE-specific ID keywords, then
C        the error 'SPICE(KEYWORDSMISMATCH1)' will be signaled.
C
C     24) If both the start time and TLE start pad keywords are 
C        specified, then the error 'SPICE(KEYWORDSMISMATCH2)' will 
C        be signaled.
C
C     25) If both the stop time and TLE stop pad keywords are 
C        specified, then the error 'SPICE(KEYWORDSMISMATCH3)' will 
C        be signaled.
C
C     26) If the stop time specified in the setup file keyword is
C        smaller than or equal to the start time specified in the setup
C        file keyword for a TLE run, then the error
C        'SPICE(INVERSTIMES2)' will be signaled.
C
C     27) If the segment ID string specified SEGMENT_ID keyword is
C        longer than 40 characters, then the error
C        'SPICE(SEGIDTOOLONG)' will be signaled.
C
C$ Files
C
C     The program requires:
C
C        -- input data to be provided in a text file; the name of 
C           an input text file can be provided in the corresponding
C           setup file keyword or on the command line after
C           corresponding key. (For a TL_ELEMENTS input / SPK 10 
C           output run, the input file must be in NORAD TLE format.)
C           
C        -- setup information to be provided via setup file which 
C           corresponds to the text kernel file format; the name 
C           of a setup file can be provided on the command line after
C           corresponding key or in response to the program prompt.
C      
C        -- Leapsecond Kernel (LSK) file to support time conversions;
C           the name of an LSK file must be provided in the 
C           corresponding setup file keyword.
C
C        -- Planetary Constant Kernel (PCK) file(s) if some planetary
C           constants are needed for requested output SPK type or 
C           input data conversion but weren't provided in special 
C           setup file keywords; the name of a PCK file(s) must be 
C           provided in the corresponding setup file keyword.
C
C        -- A geophysical constants file for the Earth (as PCK file)
C           if SPK of type 10 are processed; the name of a geophysical
C           constants file must be provided in the corresponding setup
C           file keyword.
C
C        -- Frame Definitions Kernel (FRAMES) file if trajectory 
C           data in an output SPK file will be stored with respect 
C           to a user defined frame; the name of an FRAMES file must 
C           be provided in the corresponding setup file keyword.
C
C     As an option the program can insert comments from a text file 
C     into the comment area of an output SPK file. The name of a 
C     external comment file can be provided in the corresponding 
C     setup file keyword.
C
C     The program can create (or append data to) only one SPK file
C     containing one or multiple segments of a specified type during
C     each run.
C
C$ Particulars
C     
C     None.
C
C$ Examples
C
C     To demonstrate the usage of the program, consider that we have 
C     an input file containing state vectors of the spacecraft with
C     the NAIF ID code -555 with relative to the Earth (NAIF ID -399)
C     in the 'J2000' inertial frame.
C
C     Let the structure of this file be:
C
C        Header 1 
C        Header 2 
C        X1, Y1, Z1, P1, P2, VX1, VY1, VZ1, EPOCH1
C        .........................................
C        .........................................  
C        .........................................
C        XN, YN, ZN, P1, P2, VXN, VYN, VZN, EPOCHN
C        
C     where 
C
C        Xi....EPOCHi      data lines;
C        Header i          header lines;
C        Xi, Yi, Zi        position components in km;
C        VXi, VYi, VZi     velocity components in km/sec;
C        EPOCHi            data record ET time in calendar format;
C        Pi                additional parameters that are not needed
C                          for output SPK data and should be ignored
C                          by the program;      
C
C     Consider that we also have in hand a generic SPICE LSK file 
C     "lsk.tls", a generic SPICE PCK file "pck.tpc", a PCK file 
C     "gravity.tgr" containing gravity constants and a text file 
C     "cmn.tcm" containing comments that we want to be inserted 
C     into the comment area of the output SPK file.
C
C     With these inputs we will create a setup file "cmd.tcm"
C     containing the following keywords to make MKSPK to interpret 
C     our input data correctly: 
C                                                     
C       INPUT_DATA_TYPE             = 'STATES'
C       OBJECT_ID                   = -555 
C       CENTER_ID                   = 399
C       REF_FRAME_NAME              = 'J2000'
C       DATA_ORDER                  = 'X Y Z SKIP SKIP Vx Vy Vz EPOCH'
C       INPUT_DATA_UNITS            = ( 'DISTANCES=km' )
C       TIME_WRAPPER                = '# (TDB)'
C       IGNORE_FIRST_LINE           = 2
C       DATA_DELIMITER              = ','
C       LINES_PER_RECORD            = 1
C       LEAPSECONDS_FILE            = 'lsk.tls'
C       PCK_FILE                    = ( 'pck.tpc', 'gravity.tgr' )
C       COMMENT_FILE                = 'cmd.tcm'
C       PRODUCER_ID                 = 'N.G.Khavenson, IKI RAS, Russia'
C       SEGMENT_ID                  = 'EXAMPLE'
C       
C     To generate an SPK file of type 5 we will need to add only
C     OUTPUT_SPK_TYPE keyword to our earlier set:
C
C        OUTPUT_SPK_TYPE            =  5 
C
C     to generate an SPK file of type 8 we will need to add the 
C     the OUTPUT_SPK_TYPE and POLYNOM_DEGREE keywords to our 
C     earlier set:
C
C        OUTPUT_SPK_TYPE            =  8  
C        POLYNOM_DEGREE             =  4
C
C     to generate an SPK file of type 15 we will need to add the 
C     the OUTPUT_SPK_TYPE, PRECESSION_TYPE, START_TIME and STOP_TIME 
C     keywords to our earlier set:
C
C        OUTPUT_SPK_TYPE            =  15  
C        START_TIME                 =  'start time'
C        STOP_TIME                  =  'stop time'   
C        PRECESSION_TYPE            =  'used type of precession'
C
C     When a set of keywords required for a particular output SPK type 
C     was added to a set of keywords defining input data, we can run
C     MKSPK for any of the above cases as follows:
C
C        > mkspk -setup cmd.tcm -input data.txt -output spk.bsp
C
C$ Restrictions
C
C     None.
C
C$ Literature_References
C
C     1) K.A. Ehricke, "Space flight, 1. Environment and celestial 
C        mechanics." Princeton, New Jersey - Toronto - New York - 
C        London, 1960.
C
C$ Author_and_Institution
C
C     N.G. Khavenson  (IKI RAS, Russia)
C     B.V. Semenov    (NAIF, JPL)
C     E.D. Wright     (NAIF, JPL)
C
C$ Version
C
C-    Version 6.0.0, 06-JAN-2014 (BVS)
C
C        Updated for additional TLE-specific setup keywords to allow
C        user specified TLE time pad. Increased TLE segment buffer size
C        to 50,000 and changed TLE processing logic to sort input TLEs
C        and eliminate duplicate sets. (All these changes are in
C        TLE2SPK.)
C
C        BUG FIX: fixed to process TLE lines with spacecraft code
C        left-padded with zeros to five digits. (This change is in
C        TLE2SPK.)
C
C        BUG FIX: fixed to adjust longitude of the ascending node and
C        argument of periapse for the time of the nearest periapsis for
C        elliptic orbit cases for type 15 inputs that are not at the
C        time of periapsis.
C
C-    Version 5.1.1, 18-MAY-2010 (BVS)
C
C        Removed spurious "C$" marker from the header.
C
C-    Version 5.1.0, 06-MAR-2009 (BVS)
C
C        Bug fix: added adjustment of the descriptor end time to 
C        prevent an error signaled by SPKW08 and SPKW12 due to 
C        round off in computed time step.
C
C-    Version 5.0.0, 16-JAN-2008 (BVS)
C
C        Added capability to accept time tags given as ET seconds past
C        J2000; the TIME_WRAPPER setup keyword must be set to 
C        '# ETSECONDS' to do that. Changed the format of the displayed 
C        version line.
C
C-    Version 4.4.0, 26-SEP-2006 (BVS)
C
C        Fixed the bug causing the 8th input equinoctial element
C        (DMPN/DT) be assigned to the 8th (DMPN/DT) and 9th (DNOD/DT)
C        equinoctial elements stored in the output SPK file when the
C        first six equinoctial elements were derived from input states
C        or classical elements.
C
C-    Version 4.3.0, 20-DEC-2004 (BVS)
C
C        Added truncation of segment ID set by default to prevent SPKW*
C        routines from signaling an error when the input file name, to
C        which the segment ID is set, is longer than 40 characters.
C
C-    Version 4.2.4, 26-APR-2004 (EDW)
C
C        Updated TLE parser to confirm correct numerical ranges on 
C        expected values. TLE2SPK signals an error if a TLE parse fails.
C
C        Replaced all LDPOOL calls with FURNSH.
C
C-    Version 4.1.0 beta, 31-MAY-2001 (BVS)
C
C        Changed time START/STOP time bracketing and segment breakdown
C        algorithms to "pad" (if possible) beginning and end of each
C        segment with appropriate number of states to insure that 
C        interpolation over segment boundary is continuous and smooth.
C        Added checks for duplicate and out-of-order input times.
C
C-    Version 4.0.0 beta, 22-MAR-2001 (BVS)
C
C        Added capability to append to an existing SPK file. Added 
C        check for equal time spacing in the input for output types 8
C        and 12.
C
C-    Version 3.0.2 beta, 03-NOV-2000 (EDW)
C
C        Added a BYEBYE( 'SUCCESS' ) call at program's end.
C
C-    Version 3.0.1 beta, 27-JAN-2000 (BVS)
C
C        Added clean input/output type consistency check. Added check 
C        for odd polynomial degree for types 12/13.
C
C-    Version 3.0.0 beta, 20-JAN-2000 (BVS)
C
C        Modified to handle SPK types 12 and 13 (Hermite types.)  
C
C-    Version 2.0.0 beta, 23-NOV-1999 (NGK)
C
C        Modified to handle TLE/SPK type 10. Added check to verify 
C        that for the input type EQ_ELEMENTS to output type is 17.  
C
C-    Version 1.0.7 beta, 13-MAY-1999 (BVS)
C
C        Removed checks of start and stop time provided in a setup 
C        file against first and last epochs of the data for SPK types
C        5, 15 and 17. Changed logic to assign correct start time 
C        of the first segment and stop time of the last segment for 
C        output files of type 5. These changes allowed generation of 
C        type 5, 15 or 17 SPK file from an input containing a single 
C        record and arbitrary coverage start and stop times specified 
C        in a setup file.
C        
C-    Version 1.0.6 beta, 30-MAR-1999 (NGK)(BVS)
C
C        First official release.
C        
C-    Version 1.0.6 pre-release, 29-MAR-1999 (NGK)
C        
C        The codes of EQEL calculations were corrected and
C        examples section was adjusted.
C
C-    Version 1.0.5 pre-release, 21-MAR-1999 (BVS)
C
C        The logic in the following program blocks was adjusted:
C
C           -- addition of the comments to the comment area of the 
C              output SPK file; (changed comment buffer full up 
C              schema, eliminated addition of the producer ID as a 
C              separate item, added separator lines and product  
C              creation time.)
C
C           -- parsing of the input in the case when number of 
C              input lines per record is specified (EPOCFL=3). 
C
C           -- reassigning last records of previous segment to the 
C              first records of the next segment for output types 
C              8 and 9; (now copies DEG+1 records instead of 1)
C
C           -- setting default SEGMENT_ID; (now is set the input file 
C              name rather than producer ID;
C
C           -- value of the token identifying input data items to 
C              be ignored; (changed to SKIP instead of NULL)
C
C           -- REDBUF calling sequence; (rearranged arguments to 
C              correspond to the new calling sequence)
C
C        Modified header and some comments in the code.
C
C-    Version 1.0.4 pre-release, 15-FEB-1999 (NGK)
C
C        Modified writing of the comments, included checking of the
C        start/stop time against each other, added cleaning of a
C        non-printing characters from the comments.
C
C-    Version 1.0.3 pre-release, 13-JAN-1999 (BVS)
C
C        Modified error, warning and progress messages in all modules.
C        Changed welcome message.
C
C-    Version 1.0.2 pre-release, 30-DEC-1998 (NGK)
C
C
C-    Version 1.0.2 pre-release, 15-NOV-1998 (NGK)
C
C
C-    Version 1.0.1 pre-release, 11-OCT-1998 (NGK)
C
C
C-    Version 1.0.0 pre-release, 3-DEC-1997 (NGK) 
C
C-&
C
C$ Index_Entries
C
C     Make SPK file of types 5, 8, 9, 10, 12, 13, 15 and 17.
C
C-&

C
C     SPICELIB functions.
C
      DOUBLE PRECISION      PI
      DOUBLE PRECISION      TWOPI
      DOUBLE PRECISION      VSEP

      INTEGER               POS 
      INTEGER               CPOS 
      INTEGER               POSR 
      INTEGER               NCPOS
      INTEGER               ISRCHC 
      INTEGER               ISRCHI
      INTEGER               FRSTNB
      INTEGER               RTRIM 
      INTEGER               FRSTNP

      LOGICAL               ODD
      LOGICAL               EXISTS
      LOGICAL               EQSTR

C
C     Local parameters.
C

C
C     Program version.
C
      CHARACTER*(*)         VER
      PARAMETER           ( VER = '6.0.0, January 6, 2014' )

C
C     Dimension of a single state vector.
C 
      INTEGER               DIMSTA
      PARAMETER           ( DIMSTA = 6 )             

C
C     The lower bound for the CELL 'data type'.
C 
      INTEGER               LBCELL
      PARAMETER           ( LBCELL = -5 )

C
C     Time step equality tolerance for type 8 and 12 input
C     verification (is one millisecond a good guess?)
C 
      DOUBLE PRECISION      TSTOL
      PARAMETER           ( TSTOL = 0.001D0 )

C
C     Local variables.
C
C     String sizes FILSIZ, BUFLEN, LINLEN, DLMSIZ, VALUEL, SHRTLN
C     defined in include file.
C    

C
C     Setup, input, output, comment file names.
C     
      CHARACTER*( FILSIZ )  CMDFIL
      CHARACTER*( FILSIZ )  INPFN
      CHARACTER*( FILSIZ )  OUTFN
      CHARACTER*( FILSIZ )  CMTFN

C
C     String processing parameters. Dimension MXCMNT is defined in 
C     the include file. 
C                                        
      CHARACTER*( BUFLEN )  BUFFER 
      CHARACTER*( BUFLEN )  BUFAUX
      CHARACTER*( LINLEN )  LINE
      CHARACTER*( LINLEN )  WRKCHR
      CHARACTER*( LINLEN )  HTIME
      CHARACTER*( FILSIZ )  CMNBUF ( LBCELL:MXCMNT )
      CHARACTER*( LINLEN )  ERRSTR ( 2 )
      
C
C     Array of reserved delimiters that may appear in a time string.
C     Dimension TMDNMB is defined in the include file.
C 
      CHARACTER*( DLMSIZ )  TIMDLM ( TMDNMB )

C
C     Array of acceptable in DATA_ORDER parameters and number of it.
C     Dimension MXNVAL is defined in the include file.
C 
      CHARACTER*( VALUEL )  DOVAL  ( MXNVAL )
      INTEGER               NVAL

C
C     Parameter IDs array and number of actual elements in it.
C
      INTEGER               PARAM  ( MXNVAL )
      INTEGER               NPARAM  

C
C     Epoch string processing type flag.
C
      INTEGER               EPOCFL

C
C     Setup keyword values.
C
      CHARACTER*( SHRTLN )  PRIDVL
      CHARACTER*( SHRTLN )  INDTVL
      CHARACTER*( SHRTLN )  FRNMVL
      CHARACTER*( SHRTLN )  SGIDVL
      CHARACTER*( SHRTLN )  TMWRVL
      CHARACTER*( SHRTLN )  APPCHR
      CHARACTER*( 1 )       DELMVL
      INTEGER               OUTTVL
      INTEGER               NLNREC
      INTEGER               OBIDVL
      INTEGER               CNIDVL
      INTEGER               PLDGVL
      INTEGER               EPLNVL
      INTEGER               NFLNVL
      DOUBLE PRECISION      CNGMVL
      DOUBLE PRECISION      CNJ2VL
      DOUBLE PRECISION      CNERVL ( 3 )
      
C
C     Input and comment file units.
C      
      INTEGER               INPUNT
      INTEGER               CMNUNT     

C
C     End of input data file flag.
C
      LOGICAL               EOF

C
C     Binary PCK and SPK file handle.
C
      INTEGER               HANDLE  

C
C     Indexes of last buffered epoch.
C
      INTEGER               JLEPOC

C
C     Array for storing parsed input data.
C
      DOUBLE PRECISION      DVL    ( MXNVAL )

C
C     Distance/angle unit conversion coefficients.
C
      DOUBLE PRECISION      ANGCOF
      DOUBLE PRECISION      DSTCOF

C      
C     Frame transformation matrices.
C
      DOUBLE PRECISION      XFRM   ( 6, 6 )
      DOUBLE PRECISION      TIPM   ( 3, 3 )
      DOUBLE PRECISION      MPOL   ( 3, 3 )
      DOUBLE PRECISION      MWOR   ( 3, 3 )

C
C     SPKWxx and CONICS/OSCELT subroutine arguments. Dimension MAXSTA
C     is defined in the include file.
C
      DOUBLE PRECISION      STATE  ( DIMSTA, MAXSTA )
      DOUBLE PRECISION      EPOCH  ( MAXSTA )      
      DOUBLE PRECISION      ELTS   ( 8 )
      DOUBLE PRECISION      EQEL   ( 9 )
      DOUBLE PRECISION      TP     ( 3 )
      DOUBLE PRECISION      PA     ( 3 )
      DOUBLE PRECISION      PV     ( 3 )
      DOUBLE PRECISION      RAPOL
      DOUBLE PRECISION      DEPOL
      DOUBLE PRECISION      P     
      DOUBLE PRECISION      E    
      DOUBLE PRECISION      J2FLG
      DOUBLE PRECISION      ETBEG
      DOUBLE PRECISION      ETEND
      DOUBLE PRECISION      ETFST
      DOUBLE PRECISION      ETLST
      DOUBLE PRECISION      TIMSTP
      DOUBLE PRECISION      REQUAT
      DOUBLE PRECISION      WRKEL
      DOUBLE PRECISION      MEANM

      DOUBLE PRECISION      M0
      DOUBLE PRECISION      TA
      DOUBLE PRECISION      HSTATE ( 6 )
      DOUBLE PRECISION      COSINC
      DOUBLE PRECISION      Z
      DOUBLE PRECISION      DNODE
      DOUBLE PRECISION      DPERI

C
C     "Ignore first input line" flag.
C
      LOGICAL               FLFLAG

C
C     "End of segment" flag.
C
      LOGICAL               EOSGMR

C
C     "One time execution" flag.
C
      LOGICAL               ONERUN

C
C     "Comment file existence" flag.
C
      LOGICAL               CMNTFL 

C
C     "Processing START/STOP times" flag.
C
      LOGICAL               STATFL
      LOGICAL               STOTFL

C
C     "Bracket input epoch array by START/STOP time" flag.
C
      LOGICAL               STAEPO
      LOGICAL               STOEPO

C
C     "Retrieve north polar vector RA and DEC from PCK file" flag.
C
      LOGICAL               RAKEY
      LOGICAL               DEKEY

C
C     "SETELM Error" flag.
C
      LOGICAL               ERRFLG
      
C
C     Append to existing output file flag.
C
      LOGICAL               APPFLG

C
C     Time tags are given as ET seconds past J2000 flag.
C
      LOGICAL               ETTAGS

C
C     File architecture and type.
C
      CHARACTER*(WDSIZE)    ARCH
      CHARACTER*(WDSIZE)    TYPE

C
C     Input/output type "match" algorithm arrays.
C
      CHARACTER*(WDSIZE)    ITYPES ( ITYPNM )
      INTEGER               OTYPES ( OTYPNM )
      LOGICAL               IOTYPE ( ITYPNM, OTYPNM )
      INTEGER               ITPIDX
      INTEGER               OTPIDX

C
C     Miscellaneous variables.
C   
      INTEGER               FIRST
      INTEGER               I
      INTEGER               J
      INTEGER               K
      INTEGER               L
      INTEGER               M
      INTEGER               N
      INTEGER               NEOR
      INTEGER               NL
      INTEGER               NPAR
      INTEGER               NPOS
      INTEGER               PAR
      INTEGER               PTR
      INTEGER               PADSTS
      INTEGER               RECIDX

      CHARACTER*( SHRTLN )  ASTRLN
      CHARACTER*( SHRTLN )  TSTAMP
      CHARACTER*( LINLEN )  ERROR     
      CHARACTER*( VALUEL )  VERSTR     

      DOUBLE PRECISION      TVEC ( 6 )
      DOUBLE PRECISION      TSTEP
      DOUBLE PRECISION      TMPDP      
      LOGICAL               FOUND

C
C     Variables for TLE-specific setups.
C
      INTEGER               TLIDVL ( 2 )
      CHARACTER*(WDSIZE)    COVTYP ( 2 )
      DOUBLE PRECISION      COVVAL ( 2 )
      DOUBLE PRECISION      PADBEG
      DOUBLE PRECISION      PADEND
      LOGICAL               FOUND1
      LOGICAL               FOUND2
      LOGICAL               FOUND3
      LOGICAL               FOUND4

      SAVE
      
C
C     Three arrays below are needed to check whether input data type
C     matches output SPK type and vice-versa.
C
C     Supported input data types -- must be "in sync" with parameters 
C     specified in MKSPK.INC.
C
      DATA ( ITYPES(I), I =  1, ITYPNM )
     .     /
     .      INSTTP,  INELTP,  INEQTP,  INTLTP 
     .     /

C
C     Supported output SPK data types -- must be "in sync" with
C     parameters specified in MKSPK.INC.
C
      DATA ( OTYPES(I), I =  1, OTYPNM )
     .     /
     .       5, 
     .       8, 
     .       9, 
     .      10, 
     .      12, 
     .      13, 
     .      15, 
     .      17
     .     /

C
C     This array defines whether input data type is appropriate for 
C     output SPK type.
C
      DATA ( ( IOTYPE(I,J), I = 1, ITYPNM ), J = 1, OTYPNM )
     .     /
     .      .TRUE.,  .TRUE.,  .FALSE., .FALSE.,
     .      .TRUE.,  .TRUE.,  .FALSE., .FALSE.,
     .      .TRUE.,  .TRUE.,  .FALSE., .FALSE.,
     .      .FALSE., .FALSE., .FALSE., .TRUE.,
     .      .TRUE.,  .TRUE.,  .FALSE., .FALSE.,
     .      .TRUE.,  .TRUE.,  .FALSE., .FALSE.,
     .      .TRUE.,  .TRUE.,  .FALSE., .FALSE.,
     .      .TRUE.,  .TRUE.,  .TRUE.,  .FALSE.
     .     /

C
C     Logical flag initial values.
C
      DATA CMNTFL         / .FALSE. /
      DATA RAKEY          / .FALSE. /
      DATA DEKEY          / .FALSE. / 
      DATA ONERUN         / .TRUE.  /
      DATA STAEPO         / .TRUE.  /
      DATA STOEPO         / .TRUE.  /
      DATA EOSGMR         / .FALSE. /
      DATA ETTAGS         / .FALSE. /

C
C     Delimiters that may appear in a time string. WARNING! If you 
C     need to change this list, make sure that the changes are in sync
C     with complete list of supported delimiter values stored in the 
C     parameter ALLDLM in the SETUP module.
C
      DATA TIMDLM         / ',' , ' ' / 
      
C     
C     DATA_ORDER parameter values.
C
      DOVAL(1)  =  'EPOCH'
      DOVAL(2)  =  'X'                   
      DOVAL(3)  =  'Y' 
      DOVAL(4)  =  'Z'
      DOVAL(5)  =  'VX'
      DOVAL(6)  =  'VY' 
      DOVAL(7)  =  'VZ'
      DOVAL(8)  =  'A' 
      DOVAL(9)  =  'E' 
      DOVAL(10) =  'RP'
      DOVAL(11) =  'T'
      DOVAL(12) =  'P'                                  
      DOVAL(13) =  'INC'
      DOVAL(14) =  'PER'
      DOVAL(15) =  'NOD'
      DOVAL(16) =  'MEAN'
      DOVAL(17) =  'EXAN'
      DOVAL(18) =  'TRAN'
      DOVAL(19) =  'EPOCHP'
      DOVAL(20) =  'TAU' 
      DOVAL(21) =  'EQ_A'
      DOVAL(22) =  'EQ_H'
      DOVAL(23) =  'EQ_K'
      DOVAL(24) =  'EQ_ML'
      DOVAL(25) =  'EQ_P'
      DOVAL(26) =  'EQ_Q'
      DOVAL(27) =  'DPER/DT'
      DOVAL(28) =  'DMPN/DT'
      DOVAL(29) =  'DNOD/DT'
      DOVAL(30) =  'SKIP'
      NVAL      =  30

C      
C     Default values of the distance/angle unit conversion 
C     coefficients: KM and RADIANS.
C 
      ANGCOF = 1.D0
      DSTCOF = 1.D0
      
C
C     Comment area separator line.
C
      ASTRLN = '****************************************' //
     .         '****************************************'

C
C     Standard SPICE error handling.
C
      CALL CHKIN  ( 'MKSPK' )

C
C     Display only short and long error messages.
C
      CALL ERRPRT ( 'SET', 'NONE, SHORT, LONG, TRACEBACK' )

C
C     Display "welcome" message.
C
      CALL TKVRSN ( 'TOOLKIT', VERSTR                                )

      CALL TOSTDO ( ' '                                              )
      CALL TOSTDO ( 'MKSPK -- Version ' // VER // 
     .              ' -- Toolkit Version ' // VERSTR(:RTRIM(VERSTR)) )
      CALL TOSTDO ( ' '                                              )

C
C     Get command line arguments.
C
      CALL CMLARG ( CMDFIL, INPFN, OUTFN, APPFLG )

C
C     Load setup file into the kernel pool.
C
      CALL TOSTDO ( 'Loading setup file ... '                        )

      CALL CLPOOL
      CALL FURNSH ( CMDFIL )

      CALL TOSTDO ( ' '                                              )
      CALL TOSTDO ( 'Processing setup file keyword values ... '      ) 
                                
C
C     Get setup file parameters required for all output SPK types.
C     (COMMENT FILE NAME and SEGMENT ID are optional but they are 
C     applicable for all output SPK types.)
C
      CALL SETUPC ( 'INPUT FILE NAME',        INPFN , FOUND  ) 
      CALL SETUPC ( 'OUTPUT FILE NAME',       OUTFN , FOUND  ) 
      CALL SETUPA ( 'LOAD LSK FILE',                  FOUND  ) 
      CALL SETUPA ( 'LOAD PCK FILE',                  FOUND  )
      CALL SETUPI ( 'CENTER ID',              CNIDVL, FOUND  )
      CALL SETUPC ( 'REFERENCE FRAME NAME',   FRNMVL, FOUND  )
      CALL SETUPC ( 'INPUT DATA TYPE',        INDTVL, FOUND  )
      CALL SETUPI ( 'OUTPUT SPK TYPE',        OUTTVL, FOUND  )
      CALL SETUPC ( 'PRODUCER ID',            PRIDVL, FOUND  )      
      CALL SETUPC ( 'COMMENT FILE NAME',      CMTFN , CMNTFL )       

      CALL SETUPC ( 'SEGMENT ID',             SGIDVL, FOUND  )
      IF ( FOUND ) THEN
C
C        Check that segment ID length is no greater than 40 characters
C        to catch this error before it gets to SPKW* routines.
C
         IF ( RTRIM(SGIDVL) .GT. 40 ) THEN
            CALL SETMSG ( 'The segment ID string ''#'' specified ' //
     .                    'in the ''#'' keyword is longer than '   //
     .                    '40 characters. '                        )
            CALL ERRCH  ( '#', SGIDVL                              )
            CALL ERRCH  ( '#', KSEGID                              )
            CALL SIGERR ( 'SPICE(SEGIDTOOLONG)'                    )
         END IF

      ELSE
C
C        If segment ID was not provided, set it to be the input file 
C        name truncated at 40 characters.
C
         SGIDVL = INPFN(:40)
      END IF 
      
C
C     The first thing to do is to check whether input data type 
C     matches output SPK type. First we find indexes of the types in 
C     the "registry" arrays.
C
      ITPIDX = ISRCHC ( INDTVL(:RTRIM(INDTVL)), ITYPNM, ITYPES )
      OTPIDX = ISRCHI ( OUTTVL,                 OTYPNM, OTYPES )
      
      IF ( ITPIDX .NE. 0 .AND. OTPIDX .NE. 0 ) THEN
      
C
C        Both types are "registered" in the corresponding arrays. 
C        Let's see if they match.
C
         IF ( .NOT. IOTYPE( ITPIDX, OTPIDX  ) ) THEN
         
            CALL SETMSG ( 'SPK type # cannot be created from '       //
     .                    '''#'' input. See MKSPK User''s Guide for '//
     .                    'the list of legitimate input/output '     //
     .                    'type pairs.'                              )
            CALL ERRINT ( '#', OUTTVL                                )
            CALL ERRCH  ( '#', INDTVL                                )
            CALL SIGERR ( 'SPICE(TYPESMISMATCH)'                     )
            
         END IF
         
      ELSE
      
C
C        We should have checked whether input/output types are 
C        supported ones earlier, in SETUP. If we didn't -- it's a bug.
C
         CALL SETMSG ( 'Please, contact NAIF.'  )
         CALL SIGERR ( 'SPICE(MKSPKBUG3)'       )
         
      END IF
      
C
C     Continue collecting setup information. We will need to look for
C     different sets of additional items for TLEs vs other types.
C
      IF ( INDTVL (:RTRIM ( INDTVL )) .EQ. INTLTP ) THEN

C
C        Output SPK type is 10. We continue to get setup file
C        parameters required for TLEs.
C
C        Get input TLE and output SPK object IDs.
C
         CALL SETUPI ( 'TLE INPUT OBJECT ID', TLIDVL(1), FOUND1 )
         CALL SETUPI ( 'TLE SPK OBJECT ID',   TLIDVL(2), FOUND2 )

C
C        Did we get neither of IDs, one of IDs, or both IDs?
C
         IF      ( .NOT. FOUND1 .AND. .NOT. FOUND2 ) THEN

C
C           If neither the input TLE ID nor the output SPK object ID
C           were explicitly provided, try to get the old-style object
C           ID (which will be the ID to look for in the TLE file) and
C           derive SPK object ID from it as was done in the program
C           versions before 6.0.0. Since the OBJECT_ID keyword was a
C           required keyword, this call signals an error if neither ID
C           nor name were found.
C
            CALL SETUPI ( 'OBJECT ID', TLIDVL(1), FOUND  )

            TLIDVL(2) = -100000 - TLIDVL(1)

         ELSE IF ( ( .NOT. FOUND1 .AND.       FOUND2 ) .OR.
     .             (       FOUND1 .AND. .NOT. FOUND2 )      ) THEN

C
C           If only one of TLE IDs was explicitly provided, report an
C           error.
C
            CALL SETMSG ( 'Both keywords, ''#'' and ''#'', must ' //
     .                    'be provided in the setup file '        //
     .                    'to explicitly specify '                //
     .                    'the IDs to look for in the input TLE ' //
     .                    'and to use in the output SPK file. '   //
     .                    'Only ''#'' was provided for this run.' )
            CALL ERRCH  ( '#', KTLTID                             )
            CALL ERRCH  ( '#', KTLSID                             )
            IF ( FOUND1 ) THEN
               CALL ERRCH  ( '#', KTLTID                          )
            ELSE
               CALL ERRCH  ( '#', KTLSID                          )
            END IF
            CALL SIGERR ( 'SPICE(MISSINGTLEKEYWORD)'              )
            
         ELSE

C
C           If both the input TLE ID and the output SPK object ID were
C           explicitly provided, check that neither old-style object ID
C           keyword nor the old style name keywords were provided. If
C           either of them was provided, signal an error.
C
            CALL SETUPI ( 'OBJECT ID CHECK',        I, FOUND1 )
            CALL SETUPI ( 'OBJECT NAME CHECK',      I, FOUND2 )

            IF ( FOUND1 .OR. FOUND2 ) THEN
               CALL SETMSG ( 'The keyword ''#'' cannot be '       //
     .                       'provided together with the '        //
     .                       '''#'' and ''#'' keywords.'          )
               IF ( FOUND1 ) THEN
                  CALL ERRCH  ( '#', KOBJID                       )
               ELSE
                  CALL ERRCH  ( '#', KOBJNM                       )
               END IF
               CALL ERRCH  ( '#', KTLTID                          )
               CALL ERRCH  ( '#', KTLSID                          )
               CALL SIGERR ( 'SPICE(KEYWORDSMISMATCH1)'           )
            END IF

         END IF

C
C        Get begin and end times and begin and end TLE pads.
C
         CALL SETUPD ( 'START TIME',             ETBEG,  FOUND1 )
         CALL SETUPD ( 'STOP TIME',              ETEND,  FOUND2 )

         CALL SETUPD ( 'TLE COVERAGE START PAD', PADBEG, FOUND3 )
         CALL SETUPD ( 'TLE COVERAGE STOP PAD',  PADEND, FOUND4 )

C
C        Assign start time or pad. Note that both are optional and 
C        cannot be provided together.
C
         IF ( FOUND1 .AND. FOUND3 ) THEN

            CALL SETMSG ( 'The keywords ''#'' and ''#'' cannot '  //
     .                    'be provided at the same time.'         )
            CALL ERRCH  ( '#', KSTATM                             )
            CALL ERRCH  ( '#', KTLBPD                             )
            CALL SIGERR ( 'SPICE(KEYWORDSMISMATCH2)'              )

         ELSE IF ( FOUND1 ) THEN

            COVTYP ( 1 ) = 'TIME'
            COVVAL ( 1 ) = ETBEG

         ELSE IF ( FOUND3 ) THEN

            COVTYP ( 1 ) = 'PAD'
            COVVAL ( 1 ) = PADBEG

         ELSE

            COVTYP ( 1 ) = 'PAD'
            COVVAL ( 1 ) = DTLEPD

         END IF

C
C        Check that stop time and stop pad are not provided together.
C
         IF ( FOUND2 .AND. FOUND4 ) THEN

            CALL SETMSG ( 'The keywords ''#'' and ''#'' cannot '  //
     .                    'be provided at the same time.'         )
            CALL ERRCH  ( '#', KSTOTM                             )
            CALL ERRCH  ( '#', KTLEPD                             )
            CALL SIGERR ( 'SPICE(KEYWORDSMISMATCH3)'              )

         ELSE IF ( FOUND2 ) THEN

            COVTYP ( 2 ) = 'TIME'
            COVVAL ( 2 ) = ETEND

         ELSE IF ( FOUND4 ) THEN

            COVTYP ( 2 ) = 'PAD'
            COVVAL ( 2 ) = PADEND

         ELSE

            COVTYP ( 2 ) = 'PAD'
            COVVAL ( 2 ) = DTLEPD

         END IF

C
C        One more sanity check. If begin and end time were given, check
C        that begin is less than end.
C     
         IF ( FOUND1 .AND. FOUND2 ) THEN

            IF ( ETEND .LE. ETBEG ) THEN
         
               CALL SETMSG ( 'The stop time specified in setup file '//
     .                       'keyword ''#'' is less than or equal '  //
     .                       'to the start time specified in the '   //
     .                       'setup file keyword ''#''.'             )
               CALL ERRCH  ( '#', KSTOTM                             )
               CALL ERRCH  ( '#', KSTATM                             )
               CALL SIGERR ( 'SPICE(INVERSTIMES2)'                   )
            
            END IF  

         END IF

C
C        All done with additional TLE setups.
C

      ELSE 

C
C        Output SPK type is not 10. We continue to get setup file
C        parameters required for other output SPK types.
C
C        Get SPK object ID.
C
         CALL SETUPI ( 'OBJECT ID',              OBIDVL, FOUND  )   

C
C        Get the count of top lines to skip and distance and angle
C        units conversion coefficients.
C
         CALL SETUPI ( 'IGNORE FIRST LINES',     NFLNVL, FLFLAG )
         CALL SETUPD ( 'DISTANCE COEFFICIENT',   DSTCOF, FOUND  )
         CALL SETUPD ( 'ANGLE COEFFICIENT',      ANGCOF, FOUND  )

C
C        Get start and stop time; check whether the stop time is
C        greater than the start time.
C
         CALL SETUPD ( 'START TIME',             ETBEG , STATFL )
         CALL SETUPD ( 'STOP TIME',              ETEND , STOTFL )
      
         IF ( STATFL .AND. STOTFL ) THEN

            IF ( ETEND .LT. ETBEG ) THEN
         
               CALL SETMSG ( 'The stop time specified in setup file '//
     .                       'keyword ''#'' is smaller than the '    //
     .                       'start time specified in the setup '    //
     .                       'file keyword ''#''.'                   )
               CALL ERRCH  ( '#', KSTOTM                             )
               CALL ERRCH  ( '#', KSTATM                             )
               CALL SIGERR ( 'SPICE(INVERSTARTSTOPTIME)'             )
            
            END IF  

         END IF

C
C        Get data order, parse it and check it with respect to the
C        input data/output SPK types.
C
         CALL SETUPC ( 'DATA ORDER',             LINE,   FOUND  )
         CALL PARSDO ( LINE, DOVAL, NVAL, PARAM, NPARAM ) 
         CALL CHCKDO ( INDTVL, OUTTVL, PARAM, NPARAM, DOVAL )

C
C        Get data delimiter and time wrapper values. If the time
C        wrapper has the special value indicating that time tags are
C        given as ET seconds past J2000, set corresponding logical
C        flag.
C
         CALL SETUPC ( 'DATA DELIMITER',         DELMVL, FOUND  )
         CALL SETUPC ( 'TIME WRAPPER',           TMWRVL, FOUND  )

         IF ( EQSTR( TMWRVL, '#' // ETTMWR ) .OR.
     .        EQSTR( TMWRVL, ETTMWR // '#' )      ) THEN
            ETTAGS = .TRUE.
         END IF

C
C        Get length of input EPOCH string.
C       
         CALL SETUPI ( 'TIME STRING LENGTH',     EPLNVL, FOUND  )

         IF ( .NOT. FOUND ) THEN

C
C           Length of EPOCH string was not defined in the setup file,
C           we need to check what input data delimiter value is and 
C           whether the number of lines which each input record  
C           occupies was specified in the setup file and set the 
C           EPOCH flag correspondingly.
C
            IF ( ISRCHC ( DELMVL, 2, TIMDLM ) .NE . 0 ) THEN

C
C              Delimiter is one of the symbols that can appear in a 
C              time string. Check whether there is a second EPOCH  
C              string (epoch of periapsis) is present in the input 
C              records. 
C
               IF ( ISRCHI ( 19, NPARAM, PARAM ) .NE. 0  ) THEN

C
C                 It is not allowed to include EPOCHP in set of input 
C                 data if input data delimiter delimiters in one of the 
C                 symbols that can appear in a time string.
C 
                  CALL SETMSG ( 'When input record parameters '       //
     .                          'delimiter character (''#'') '        //
     .                          'specified in setup file keyword '    //
     .                          '''#'' is one of the characters that '//
     .                          'can be used in a valid input time '  //
     .                          'string, two time tags cannot be '    //
     .                          'present in an input record and '     //
     .                          'therefore epoch of periapsis cannot '//
     .                          'be included in the list of '         //
     .                          'parameters in the ''#'' keyword. '    )
                  CALL ERRCH  ( '#', DELMVL                            )
                  CALL ERRCH  ( '#', KDATDL                            )
                  CALL ERRCH  ( '#', KDATOR                            )
                  CALL SIGERR ( 'SPICE(CANTUSEPERIAPEPOCH)'            )
               
               ELSE

C
C                 Get number of lines which each input data record 
C                 occupies. If it's not present SETUPI will fail with 
C                 an error message.
C
                  CALL SETUPI ( 'LINES PER RECORD', NLNREC, FOUND ) 
                  EPOCFL = 3
            
               END IF

            ELSE

C
C              Delimiter is not one of the symbols that can be used in a
C              time string. Epoch value may appear in any location in 
C              the DATA_ORDER.
C
               EPOCFL = 2

            END IF 

         ELSE

C
C           We received length of EPOCH string value.
C
            EPOCFL = 1

         END IF 

C     
C        Get setup file parameters specific for given output SPK type.
C
         IF ( OUTTVL .EQ. 5 ) THEN

C
C           For output SPK type 5 we always needed GM.
C
            CALL SETUPD ( 'CENTER BODY GM', CNGMVL, FOUND )

            IF ( .NOT. FOUND ) THEN              
               CALL BODVAR ( CNIDVL, 'GM', N, CNGMVL )         
            ELSE
               CNGMVL = CNGMVL * DSTCOF * DSTCOF * DSTCOF
            END IF

C
C           For Type 5 SPKs we set the number of "padding" states to 1
C           assuming that if START and/or STOP times were provided
C           in the setup file and either of them happen to be between
C           two input states, we will grab one state before START or
C           after STOP to make sure that interpolated position and
C           velocity is as close to the input data as possible.
C
            PADSTS = 1
         
         ELSE IF ( OUTTVL .EQ. 8 ) THEN

C
C           For output SPK type 8 we need GM only if the input type is 
C           not STATES.
C
            IF ( .NOT. (INDTVL(:RTRIM( INDTVL )) .EQ. INSTTP)) THEN   

               CALL SETUPD ( 'CENTER BODY GM',         CNGMVL, FOUND )

               IF ( .NOT. FOUND ) THEN             
                  CALL BODVAR ( CNIDVL, 'GM', N, CNGMVL )               
               ELSE                        
                  CNGMVL = CNGMVL * DSTCOF * DSTCOF * DSTCOF
               END IF 

            END IF
                                                
C
C           We also need polynomial degree which must be a positive 
C           number.
C                                               
            CALL SETUPI ( 'POLYNOMIAL DEGREE',   PLDGVL, FOUND )
            IF ( PLDGVL .LE. 0 .OR. PLDGVL .GT. MAXDEG ) THEN
               CALL SETMSG ( 'The degree of Lagrange polynomial '    //
     .                       'specified in the setup keyword ''#'' ' //
     .                       'must be a positive number less than '  //
     .                       '#. It was #.'                          )
               CALL ERRCH  ( '#', KPLDEG                             )
               CALL ERRINT ( '#', MAXDEG + 1                         )
               CALL ERRINT ( '#', PLDGVL                             )
               CALL SIGERR ( 'SPICE(BADLAGRANGEDEGREE)'              )
            END IF

C
C           For Type 8 SPKs we set the number of "padding" states to
C           the specified polynomial degree. If START and/or STOP times
C           were provided in the setup file and either of them happen
C           to be between two input states, we will grab PLDGVL states
C           before START or after STOP to make sure that interpolated
C           position and velocity is as close to the input data as
C           possible. (Well, PLDGVL is overkill, and we could have
C           gotten away with 1/2 of it, but it would make the algorithm
C           handling START/STOP boundary processing more complex.)
C
            PADSTS = PLDGVL
         
         ELSE IF ( OUTTVL .EQ. 9 ) THEN

C      
C           For output SPK type 9 we need GM only if input type is not 
C           STATES.
C
            IF ( .NOT. (INDTVL(:RTRIM( INDTVL )) .EQ. INSTTP)) THEN   

               CALL SETUPD ( 'CENTER BODY GM', CNGMVL, FOUND )

               IF ( .NOT. FOUND ) THEN             
                  CALL BODVAR ( CNIDVL, 'GM', N, CNGMVL )
               ELSE            
                  CNGMVL = CNGMVL * DSTCOF * DSTCOF * DSTCOF
               END IF 

            END IF
                                                
C
C           We also need polynomial degree which must be a positive
C           number.
C                                               
            CALL SETUPI ( 'POLYNOMIAL DEGREE', PLDGVL, FOUND )
            IF ( PLDGVL .LE. 0 .OR. PLDGVL .GT. MAXDEG ) THEN
               CALL SETMSG ( 'The degree of Lagrange polynomial '    //
     .                       'specified in the setup keyword ''#'' ' //
     .                       'must be a positive number less than '  //
     .                       '#. It was #.'                          )
               CALL ERRCH  ( '#', KPLDEG                             )
               CALL ERRINT ( '#', MAXDEG + 1                         )
               CALL ERRINT ( '#', PLDGVL                             )
               CALL SIGERR ( 'SPICE(BADLAGRANGEDEGREE)'              )
            END IF

C
C           Same as for type 8: for type 9 we set the number of
C           "padding" states to the specified polynomial degree.
C
            PADSTS = PLDGVL

         ELSE IF ( OUTTVL .EQ. 12 ) THEN

C
C           For output SPK type 12 we need GM only if the input type is 
C           not STATES.
C
            IF ( .NOT. (INDTVL(:RTRIM( INDTVL )) .EQ. INSTTP)) THEN   

               CALL SETUPD ( 'CENTER BODY GM',         CNGMVL, FOUND )

               IF ( .NOT. FOUND ) THEN             
                  CALL BODVAR ( CNIDVL, 'GM', N, CNGMVL )               
               ELSE                        
                  CNGMVL = CNGMVL * DSTCOF * DSTCOF * DSTCOF
               END IF 

            END IF
                                                
C
C           We also need polynomial degree which must be an odd number.
C                                               
            CALL SETUPI ( 'POLYNOMIAL DEGREE',   PLDGVL, FOUND )
            IF ( .NOT. ODD( PLDGVL ) ) THEN
               CALL SETMSG ( 'The degree of Hermit polynomial '      //
     .                       'specified in the setup keyword ''#'' ' //
     .                       'must be an odd number. It was #. '     )
               CALL ERRCH  ( '#', KPLDEG                             )
               CALL ERRINT ( '#', PLDGVL                             )
               CALL SIGERR ( 'SPICE(EVENHEMITDEGREE)'                )
            END IF
            IF ( PLDGVL .LE. 0 .OR. PLDGVL .GT. MAXDEG ) THEN
               CALL SETMSG ( 'The degree of Hermit polynomial '      //
     .                       'specified in the setup keyword ''#'' ' //
     .                       'must be a positive number less than '  //
     .                       '#. It was #.'                          )
               CALL ERRCH  ( '#', KPLDEG                             )
               CALL ERRINT ( '#', MAXDEG + 1                         )
               CALL ERRINT ( '#', PLDGVL                             )
               CALL SIGERR ( 'SPICE(BADHERMITDEGREE)'                )
            END IF

C
C
C           For Type 12 SPKs we set the number of "padding" states to
C           1/2 of the specified polynomial degree. If START and/or
C           STOP times were provided in the setup file and either of
C           them happen to be between two input states, we will grab
C           PLDGVL/2 states before START or after STOP to make sure
C           that interpolated position and velocity is as close to the
C           input data as possible. (Well, 1/2 of PLDGVL is overkill,
C           and we could have gotten away with 1/4 of it, but it would
C           make the algorithm handling START/STOP boundary processing
C           more complex.) ... and it cannot be zero.
C
            PADSTS = MAX( 1, PLDGVL / 2 )

         ELSE IF ( OUTTVL .EQ. 13 ) THEN

C      
C           For output SPK type 13 we need GM only if input type is not 
C           STATES.
C
            IF ( .NOT. (INDTVL(:RTRIM( INDTVL )) .EQ. INSTTP)) THEN   

               CALL SETUPD ( 'CENTER BODY GM', CNGMVL, FOUND )

               IF ( .NOT. FOUND ) THEN             
                  CALL BODVAR ( CNIDVL, 'GM', N, CNGMVL )
               ELSE            
                  CNGMVL = CNGMVL * DSTCOF * DSTCOF * DSTCOF
               END IF 

            END IF
                                                
C
C           We also need polynomial degree which must be an odd number.
C                                               
            CALL SETUPI ( 'POLYNOMIAL DEGREE',   PLDGVL, FOUND )
            IF ( .NOT. ODD( PLDGVL ) ) THEN
               CALL SETMSG ( 'The degree of Hermit polynomial '      //
     .                       'specified in the setup keyword ''#'' ' //
     .                       'must be an odd number. It was #. '     )
               CALL ERRCH  ( '#', KPLDEG                             )
               CALL ERRINT ( '#', PLDGVL                             )
               CALL SIGERR ( 'SPICE(EVENHEMITDEGREE)'                )
            END IF
            IF ( PLDGVL .LE. 0 .OR. PLDGVL .GT. MAXDEG ) THEN
               CALL SETMSG ( 'The degree of Hermit polynomial '      //
     .                       'specified in the setup keyword ''#'' ' //
     .                       'must be a positive number less than '  //
     .                       '#. It was #.'                          )
               CALL ERRCH  ( '#', KPLDEG                             )
               CALL ERRINT ( '#', MAXDEG + 1                         )
               CALL ERRINT ( '#', PLDGVL                             )
              CALL SIGERR ( 'SPICE(BADHERMITDEGREE)'                 )
            END IF

C
C           Same as for type 12: for Type 13 SPKs we set the number of
C           "padding" states to 1/2 of the specified polynomial degree.
C
            PADSTS = MAX( 1, PLDGVL / 2 )

         ELSE IF ( OUTTVL .EQ. 15 ) THEN

C
C           For output SPK type 15 we always need GM.
C
            CALL SETUPD ( 'CENTER BODY GM', CNGMVL, FOUND )

            IF ( .NOT. FOUND ) THEN              
               CALL BODVAR ( CNIDVL, 'GM', N, CNGMVL )                  
            ELSE
               CNGMVL = CNGMVL * DSTCOF * DSTCOF * DSTCOF
            END IF 

C
C           We also need START and STOP times to be provided in 
C           the setup file.
C
            IF ( .NOT. STATFL ) THEN

               CALL SETMSG ( 'Start time required for the output SPK '//
     .                       'type 15 was not provided in the setup ' //
     .                       'file keyword ''#''.'                     )
               CALL ERRCH  ( '#', KSTATM                               )
               CALL SIGERR ( 'SPICE(NOSTARTTIME4SPK15)'                )

            END IF

            IF ( .NOT. STOTFL ) THEN

               CALL SETMSG ( 'Stop time required for the output SPK ' //
     .                       'type 15 was not provided in the setup ' //
     .                       'file keyword ''#''.'                     )
               CALL ERRCH  ( '#', KSTOTM                               )
               CALL SIGERR ( 'SPICE(NOSTOPTIME4SPK15)'                 )

            END IF

C
C           We need J2, R equ, precession type, polar PV vector.
C
            CALL SETUPD ( 'J2',                  CNJ2VL, FOUND )

            IF ( .NOT. FOUND ) THEN
               CALL BODVAR ( CNIDVL, 'J2', N, CNJ2VL )
            END IF

            CALL SETUPD ( 'EQUATORIAL RADIUS', REQUAT, FOUND )

            IF ( .NOT. FOUND ) THEN
               CALL BODVAR ( CNIDVL, 'RADII', N, CNERVL (1) )
               REQUAT = CNERVL (1)        
            ELSE
               REQUAT = REQUAT * DSTCOF
            END IF 
         
            CALL SETUPD ( 'PRECESSION TYPE',     J2FLG,  FOUND )
         
            CALL SETUPD ( 'POLE RA',             RAPOL,  FOUND ) 
            RAKEY = .NOT. FOUND
            RAPOL = RAPOL * ANGCOF
         
            CALL SETUPD ( 'POLE DEC',            DEPOL,  FOUND )
            DEKEY = .NOT. FOUND
            DEPOL = DEPOL * ANGCOF

            IF ( .NOT. RAKEY .AND. .NOT. DEKEY ) THEN
         
C
C              Polar vector rectangular coordinates.
C
               PV (1) = DCOS ( RAPOL ) * DCOS ( DEPOL )
               PV (2) = DSIN ( RAPOL ) * DCOS ( DEPOL )
               PV (3) =                  DSIN ( DEPOL )
         
            END IF   

C
C           We don't need any padding states for type 15.
C
            PADSTS = 0

         ELSE IF ( OUTTVL .EQ. 17 ) THEN

C
C           For output SPK type 17 we need GM if input data type is not 
C           EQ_ELEMENTS.
C
            IF ( .NOT. (INDTVL(:RTRIM( INDTVL )) .EQ. INEQTP)) THEN   

               CALL SETUPD ( 'CENTER BODY GM',         CNGMVL, FOUND )

               IF ( .NOT. FOUND ) THEN             
                  CALL BODVAR ( CNIDVL, 'GM', N, CNGMVL )
               ELSE            
                  CNGMVL = CNGMVL * DSTCOF * DSTCOF * DSTCOF
               END IF 

            END IF

C
C           We also need START and STOP times to be provided in 
C           the setup file.
C
            IF ( .NOT. STATFL ) THEN

               CALL SETMSG ( 'Start time required for the output SPK '//
     .                       'type 17 was not provided in the setup ' //
     .                       'file keyword ''#''.'                     )
               CALL ERRCH  ( '#', KSTATM                               )
               CALL SIGERR ( 'SPICE(NOSTARTTIME4SPK17)'                )

            END IF

            IF ( .NOT. STOTFL ) THEN

               CALL SETMSG ( 'Stop time required for the output SPK ' //
     .                       'type 17 was not provided in the setup ' //
     .                       'file keyword ''#''.'                     )
               CALL ERRCH  ( '#', KSTOTM                               )
               CALL SIGERR ( 'SPICE(NOSTOPTIME4SPK17)'                 )

            END IF

C
C           We need POLE RA and DEC. Get it.
C
            CALL SETUPD ( 'POLE RA', RAPOL,  FOUND ) 
            RAKEY = .NOT. FOUND
            RAPOL = RAPOL * ANGCOF
         
            CALL SETUPD ( 'POLE DEC', DEPOL,  FOUND )
            DEKEY = .NOT. FOUND
            DEPOL = DEPOL * ANGCOF

C
C           We don't need any padding states for type 17.
C
            PADSTS = 0

         END IF 

      END IF

C
C     We are done with processing of setups; time to get to the real
C     business of making SPK :-). The first thing to do is to open SPK.
C     We can open it for appending or as a new file depending on what
C     user has asked us to do. User can request appending via command
C     line or setup file. See if appending was requested via command
C     line switch (this is the highest priority indication.)
C
      IF ( .NOT. APPFLG ) THEN

C
C        No, it wasn't. We need to check for setup file flag.   
C
         CALL SETUPC ( 'APPEND FLAG', APPCHR, FOUND  )

C
C        If setup file keyword was set to 'yes', re-set append flag
C        to indicate that append was requested.
C
         IF ( APPCHR .EQ. YESVAL ) THEN
            APPFLG = .TRUE.
         END IF 

      END IF

C
C     Check if append was requested.
C
      IF ( APPFLG ) THEN

C
C        Yup. But does the file already exist?
C
         IF ( EXISTS ( OUTFN ) ) THEN

C
C           Aha, it does exist. But is it actually an SPK file?
C
            CALL GETFAT ( OUTFN, ARCH, TYPE )
 
            IF ( ARCH .NE. 'DAF' .OR. TYPE .NE. 'SPK' ) THEN

C
C              If it's not an SPK, it's "no can do" :-)
C
               CALL SETMSG ( 'Output file ''#'', appending to which '//
     .                       'has been requested, is not an SPK '    //
     .                       'file. Its file architecture/type were '//
     .                       'detected to be ''#/#''.'               )
               CALL ERRCH  ( '#', OUTFN                              )
               CALL ERRCH  ( '#', ARCH                               )
               CALL ERRCH  ( '#', TYPE                               )
               CALL SIGERR ( 'SPICE(OUTPUTISNOTSPK)'                 )

            ELSE

C
C              The file is an SPK. Open it for appending.
C
               CALL SPKOPA ( OUTFN, HANDLE )

            END IF

         ELSE

C
C           Nope, it doesn't exist. Hmmm ... what can we do? Maybe 
C           open it as a new SPK file?
C
            CALL SPKOPN ( OUTFN, 'SPK' , 40000, HANDLE )
            APPFLG = .FALSE.

         END IF

      ELSE

C
C        Nope. We need to make a new file. What if the file already 
C        exists? Then we need to complain loud and clear ...
C
         IF ( EXISTS ( OUTFN ) ) THEN

            CALL SETMSG ( 'Output SPK file ''#'' already exists. '   //
     .                    'It must be a new file or, if appending '  //
     .                    'to this file is desired, appropriate '    //
     .                    'command line key or setup file keyword '  //
     .                    'must be specified.'                       )
            CALL ERRCH  ( '#', OUTFN                                 )
            CALL SIGERR ( 'SPICE(OUTPUTFILEEXISTS)'                  )

         END IF

C
C        The file doesn't exist. Open it as a new SPK file.
C
         CALL SPKOPN ( OUTFN, 'SPK' , 40000, HANDLE )

      END IF

C
C     Before we start processing of the data, we need to add comments 
C     the output SPK file.
C
      CALL TOSTDO ( ' '                                             )
      CALL TOSTDO ( 'Writing comments to the output SPK file  ... ' )

C
C     Set the maximum size of the comment line buffer.
C
      CALL SSIZEC ( MXCMNT, CMNBUF )
      L = 0
      
C
C     If the comment file was provided we copy its content to the
C     comment area.
C
      IF ( CMNTFL ) THEN 
         
C
C        We open the comment file, copy text from it to the comment
C        buffer line by line, clean non-printing characters from the
C        lines on the fly and dump the buffer to the comment area
C        when it's full. We repeat until all comments have been copied.
C
         CALL TXTOPR ( CMTFN, CMNUNT )              
         EOF = .FALSE. 

C
C        Insert top comment separator line.
C
         CMNBUF ( 1 ) = ASTRLN 
         CMNBUF ( 2 ) = ' ' 
         L = 2
            
         DO WHILE ( .NOT. EOF ) 
            
C
C           Get next comment line.
C
            CALL READLN ( CMNUNT, LINE, EOF )
            
            IF ( .NOT. EOF ) THEN

C
C              Replace non-printing characters with spaces.
C
               DO WHILE ( FRSTNP ( LINE ) .NE. 0 )     
                  M = FRSTNP( LINE )
                  LINE ( M:M ) = ' '
               END DO
                  
               IF ( L .LT. MXCMNT ) THEN 
               
C
C                 Store line in the buffer.
C
                  L = L + 1  
                  CMNBUF ( L ) = LINE (: RTRIM ( LINE ) )

               ELSE

C
C                 Buffer is full. Set the cardinality of the comment
C                 buffer and write it to SPK comment area. Reset
C                 counter.
C
                  CALL SCARDC ( L, CMNBUF )
                  CALL SPCACB ( HANDLE, CMNBUF )
   
                  L = 0

               END IF 
                  
            END IF 
               
         END DO 

C
C        Close comments file.
C
         CLOSE ( CMNUNT )

      END IF

C
C     Dump the rest of the buffer into the comment area.
C  
      IF ( L .NE. 0 ) THEN
         CALL SCARDC ( L, CMNBUF )
         CALL SPCACB ( HANDLE, CMNBUF )
         L = 0
      END IF
      
C
C     Add a header preceding contents of the setup file and containing
C     setup file name and current CPU time.
C
      CALL CPUTIM ( TVEC )
      TSTAMP = 'YYYY-MM-DDTHR:MN:SC'
      CALL DPFMT ( TVEC(1), '0YYY',  TSTAMP(1:4)   )
      CALL DPFMT ( TVEC(2), '0M',    TSTAMP(6:7)   )
      CALL DPFMT ( TVEC(3), '0D',    TSTAMP(9:10)  )
      CALL DPFMT ( TVEC(4), '0h',    TSTAMP(12:13) )
      CALL DPFMT ( TVEC(5), '0m',    TSTAMP(15:16) )
      CALL DPFMT ( TVEC(6), '0s',    TSTAMP(18:19) )
      
      CMNBUF ( 1 ) = ' ' 
      CMNBUF ( 2 ) = ASTRLN 
      CMNBUF ( 3 ) = 'MKSPK RUN DATE/TIME: ' // TSTAMP(:RTRIM(TSTAMP)) 
      CMNBUF ( 4 ) = 'MKSPK SETUP FILE:    ' // CMDFIL(:RTRIM(CMDFIL)) 
      CMNBUF ( 5 ) = 'MKSPK INPUT FILE:    ' // INPFN (:RTRIM(INPFN)) 
      CMNBUF ( 6 ) = 'MKSPK OUTPUT FILE:   ' // OUTFN (:RTRIM(OUTFN))
      IF ( APPFLG ) THEN
         CMNBUF ( 7 ) = 'OUTPUT FILE STATUS:  EXISTING FILE'
      ELSE
         CMNBUF ( 7 ) = 'OUTPUT FILE STATUS:  NEW FILE'
      END IF 
      CMNBUF ( 8 ) = ASTRLN 
      CMNBUF ( 9 ) = ' ' 
      L = 9

C
C     Now we will copy contents of the setup file to the comment area
C     using exactly the same procedure: open the setup file, copy
C     text from the file into the buffer line by line, clean
C     non-printing characters from the lines on the fly and dump the
C     buffer to the comment area when it's full. We repeat until all
C     setup lines have been copied.
C
      CALL TXTOPR ( CMDFIL, CMNUNT )              
      EOF = .FALSE. 
            
      DO WHILE ( .NOT. EOF ) 

C
C        Read next line.
C
         CALL READLN ( CMNUNT, LINE, EOF )
         
         IF ( .NOT. EOF ) THEN

C
C           Replace non-printing character with spaces.
C
            DO WHILE ( FRSTNP ( LINE ) .NE. 0 )     
               M = FRSTNP( LINE )
               LINE ( M:M ) = ' '
            END DO

            IF ( L .LT. MXCMNT ) THEN 

C
C              Store line on buffer.
C
               L = L + 1  
               CMNBUF ( L ) = LINE (: RTRIM ( LINE ) )
   
            ELSE
     
C
C              Buffer is full. Set the cardinality of the comment
C              buffer and write it to SPK comment area. Reset counter
C              and store the last line that we have obtained in the
C              first line of the buffer.
C
               CALL SCARDC ( L, CMNBUF )
               CALL SPCACB ( HANDLE, CMNBUF )
   
               L = 0

            END IF  
            
         END IF
               
      END DO 

      CLOSE ( CMNUNT )
      
C
C     Add "bottom of the comments" separator line.
C
      IF ( L .LE. MXCMNT - 2 ) THEN
      
         CMNBUF ( L + 1 ) = ' ' 
         CMNBUF ( L + 2 ) = ASTRLN 
         L = L + 2 
         
      ELSE
      
C
C        Dump current contents of the comment buffer, first. After
C        that stick separator at the top of the buffer.
C
         CALL SCARDC ( L, CMNBUF )
         CALL SPCACB ( HANDLE, CMNBUF )
      
         CMNBUF ( 1 ) = ' ' 
         CMNBUF ( 2 ) = ASTRLN 
         L = 2
         
      END IF

C
C     Dump the buffer one more time.
C        
      IF ( L .GT. 0 ) THEN

         CALL SCARDC ( L, CMNBUF )
         CALL SPCACB ( HANDLE, CMNBUF )

      END IF

C
C     Start processing input data.
C
      CALL TOSTDO ( ' '                                  )
      CALL TOSTDO ( 'Started processing input data ... ' )

      IF ( INDTVL (:RTRIM ( INDTVL )) .EQ. INTLTP ) THEN

C
C        Process two-line element data and make output SPK of type 10.
C
         CALL TLE2SPK ( INPFN,  TLIDVL, CNIDVL, FRNMVL, SGIDVL, HANDLE,
     .                  COVVAL, COVTYP)

      ELSE  

C
C        Process other than two-line element data. 
C        Open the input data file. 
C
         CALL TXTOPR ( INPFN, INPUNT ) 

         IF ( FLFLAG ) THEN

C
C           Ignore first NFLVAL lines of input file.
C
            DO NL = 1, NFLNVL 
           
               CALL READLN ( INPUNT, LINE, EOF )
           
               IF ( EOF ) THEN
           
                  CALL DAFCLS ( HANDLE )
                  CALL DELFIL ( OUTFN )
                  CALL SETMSG ( '# first lines of the input file '    //
     .                          '''#'' cannot be ignored as specified'//
     .                          ' in setup file keyword ''#'' '       //
     .                          'because the total number of lines '  //
     .                          'in the file is less than this '      //
     .                          'number.'                              )
                  CALL ERRINT ( '#', NFLNVL                            )
                  CALL ERRCH  ( '#', INPFN                             )
                  CALL ERRCH  ( '#', KIGNFL                            )
                  CALL SIGERR ( 'SPICE(TOOFEWINPUTLINES)'              )
                
               END IF
        
            END DO
         
         END IF            

C
C        Set key for reading text data into the lines buffer.
C
         EOF = .FALSE.

C
C        Reset indexes of the DATA_ORDER parameters, of the last 
C        element in STATE/EPOCH arrays and of the last line that were  
C        read from the input data file.
C
         I =  1
         J =  0
         RECIDX = 0
      
C
C        Reset other buffer parameters.
C
         K = 0 
         BUFFER ( : ) = ' '
         BUFAUX ( : ) = ' '
       
         DO WHILE ( .NOT. EOF ) 

C
C           Reading text data into the lines buffer until the end
C           of buffer.
C
            CALL REDBUF ( INPUNT, DELMVL, NLNREC, EPOCFL, 
     .                    BUFFER, K, BUFAUX, EOF ) 
                                 
C                       
C           Start to parse buffer string. Find position of the first
C           non-blank character in the buffer.
C  
            FIRST = FRSTNB ( BUFFER ) 

            DO WHILE ( FIRST .NE. 0 )
                          
C                         
C              Calculate the index N of data order element to which 
C              we will assign the value with we are about to pull from 
C              the buffer.              
C
               IF ( MOD ( I, NPARAM ) .EQ. 0 ) THEN
            
                  N = NPARAM
                                     
               ELSE
            
                  N = MOD ( I, NPARAM )
               
               END IF
            
C
C              Should we skip current value? 
C
               IF ( PARAM ( N ) .EQ. 30 ) THEN

C                  
C                 Yes, so skip it without parsing and reset FIRST to be
C                 beginning of the next value in the buffer.
C
                  NPOS = CPOS ( BUFFER, DELMVL//EORMRK, FIRST )
                             
               ELSE
            
C
C                 We know the begin character position of the value 
C                 which we need to parse (FIRST). Now we need to find 
C                 its end character position in the buffer (NPOS). 
C                 We do differently depending on the EPOCFL value  
C                 (which basically determines our parsing schema.)
C              
                  IF ( EPOCFL .EQ. 1 ) THEN

C
C                    The case when the length of EPOCH string was
C                    provided in the setup file which simplifies
C                    pulling times out of the buffer a lot -- we just
C                    grab substring from FIRST to the next delimiter
C                    which we start to search for from FIRST+"string
C                    length" initial position.
C        
                     IF ( PARAM ( N ) .EQ. 1 
     .                    .OR.
     .                    PARAM ( N ) .EQ. 19 )  THEN
C
C                       Position of the delimiter for time string value.
C                             
                        NPOS = POS ( BUFFER, DELMVL, FIRST + EPLNVL ) 
                             
                     ELSE
                                    
C
C                       Position of the delimiter for other then
C                       time string value.
C                                       
                        NPOS = POS ( BUFFER, DELMVL, FIRST )
                            
                     END IF 
  
                  END IF

                  IF ( EPOCFL .EQ. 2 ) THEN

C
C                    This case is when delimiter is the character that  
C                    can not be used in a time string. We just search  
C                    for position of the next delimiter starting from 
C                    FIRST.
C        
                     NPOS = POS ( BUFFER, DELMVL, FIRST )
                             
                  END IF   

                  IF ( EPOCFL .EQ. 3 ) THEN
                 
C                  
C                    Though case -- the delimiter is one of the 
C                    characters that can used in a time string. 
C                    Luckily, there is only one EPOCH string can 
C                    be present in each record in this situation.
C
                     IF ( PARAM ( N ) .EQ. 1 )  THEN
                  
C
C                       Our current value is EPOCH -- we need to find 
C                       next end-of-record delimiter position on the 
C                       buffer.
C
                        NEOR = POS ( BUFFER, EORMRK, FIRST ) 
                        NPAR = NPARAM 
                        PAR  = PARAM ( NPAR )

C
C                       Lets see if our epoch is the last parameter in 
C                       the record.
C                           
                        IF ( PAR .NE. 1 ) THEN

C
C                          No, it is not. Well, we need to search for
C                          delimiter position in reverse order until we
C                          find a delimiter that immediately follows our
C                          EPOCH value.
C
                           DO WHILE ( PAR .NE. 1 )
                     
C
C                             Search in reverse order for delimiter 
C                             from the last found position of the record
C                             marker.
C                      
                              NEOR = POSR ( BUFFER, DELMVL, NEOR ) - 1
                           
C
C                             If our delimiter is a space, we need to 
C                             advance even further back to make sure 
C                             that a call POSR on the next iteration 
C                             finds the space that precedes our current
C                             value rather than follows it. 
C                                                                
                              IF ( DELMVL .EQ. ' ' ) THEN

                                 IF ( BUFFER(NEOR:NEOR) .EQ. ' ' ) THEN

C
C                                   Skip white spaces.
C                         
                                    DO WHILE 
     .                                  ( BUFFER(NEOR : NEOR) .EQ. ' ' )
                        
                                       NEOR = NEOR - 1
                        
                                    END DO
                           
                                 END IF
                              
                              END IF
                         
                              NPAR = NPAR - 1
                              PAR = PARAM ( NPAR )
                              
                           END DO
                             
                           NPOS = NEOR + 1
                        
                        ELSE
                     
C
C                          Yes, the EPOCH is the last parameter in the 
C                          record. It means that NEOR is currently 
C                          pointing at the artificially inserted 
C                          end-or-record marker. We just reassign it to
C                          NPOS.
C
                           NPOS = NEOR

                        END IF
                             
                     ELSE

C
C                       Position of the delimiter for other then
C                       time string value.
C
                        NPOS = CPOS ( BUFFER, DELMVL//EORMRK, FIRST )
                             
                     END IF 

                  END IF 
                         
C                                  
C                 At this point we have determined where in the input 
C                 buffer our current value is. We pull it out, parse 
C                 it, store parsed value in the data buffer, change 
C                 data order index counter and shift to the next value 
C                 in the buffer.
C
                  WRKCHR = BUFFER ( FIRST : NPOS-1 ) 
                                              
C
C                 Is current value a time string or a number?
C
                  IF ( PARAM ( N ) .EQ. 1 
     .                 .OR.
     .                 PARAM ( N ) .EQ. 19 ) THEN

C
C                    Are times given as ET seconds past J2000?
C
                     IF ( ETTAGS ) THEN

C
C                       Yes. Parse them as DPs.
C                      
                        CALL NPARSD ( WRKCHR , DVL ( PARAM ( N ) ),
     .                                ERROR, PTR                      )

                        IF ( PTR .NE. 0 ) THEN 

C
C                          We can not parse this data value.
C                     
                           CALL DAFCLS ( HANDLE )
                           CALL DELFIL ( OUTFN )
                           CALL SETMSG ( 'The string ''#'' found in '//
     .                                   'the input file ''#'' '     //
     .                                   'doesn''t represent a '     //
     .                                   'double precision number '  //
     .                                   'which it should be to be ' //
     .                                   'a value of input '         //
     .                                   'parameter ''#''.'           )
                           CALL ERRCH  ( '#', WRKCHR                  )
                           CALL ERRCH  ( '#', INPFN                   )
                           CALL ERRCH  ( '#', DOVAL( PARAM(N) )       )
                           CALL SIGERR ( 'SPICE(NOTADPNUMBER)'        )
                                          
                        END IF 

                     ELSE
C
C                       No. Insert time string into the wrapper and
C                       pass it to the STR2ET.
C                      
                        CALL REPMC ( TMWRVL, '#', WRKCHR, HTIME ) 
                        CALL STR2ET( HTIME, DVL ( PARAM ( N ) ) )

                     END IF

                  ELSE 
                
C
C                    Parse an input number as DP.
C
                     CALL NPARSD ( WRKCHR , DVL ( PARAM ( N ) ),
     .                             ERROR, PTR                      )

                     IF ( PTR .NE. 0 ) THEN 

C
C                       We can not parse this data value.
C                     
                        CALL DAFCLS ( HANDLE )
                        CALL DELFIL ( OUTFN )
                        CALL SETMSG ( 'The string ''#'' found in '   //
     .                                'the input file ''#'' '        //
     .                                'doesn''t represent a double ' //
     .                                'precision number which it '   //
     .                                'should be to be a value of '  //
     .                                'input parameter ''#''.'         )
                        CALL ERRCH  ( '#', WRKCHR                      )
                        CALL ERRCH  ( '#', INPFN                       )
                        CALL ERRCH  ( '#', DOVAL( PARAM(N) )           )
                        CALL SIGERR ( 'SPICE(NOTADPNUMBER)'            )
                                          
                     END IF 
                  
                  END IF 

               END IF
            
C
C              Check whether we have accumulated a complete set of 
C              parameter for one data record (point). If so, start 
C              processing of the record.
C               
               IF ( MOD ( I, NPARAM ) .EQ. 0 ) THEN

                  J = J + 1
                  RECIDX = RECIDX + 1
                           
C                           
C                 We have accumulated full set of data to process
C                 input data for SPKW... We process accumulated set of 
C                 parameters depending on the input data type.
C
                  IF ( INDTVL (: RTRIM ( INDTVL ) ) .EQ. INELTP ) THEN 
                      
C
C                    Input data type is ELEMENTS. We need to convert
C                    whatever set of elements we have got on the 
C                    input the standard SPICE representation.
C                                                                     
                     CALL SETELM ( CNGMVL, DVL, DSTCOF, ANGCOF, PARAM, 
     .                             NPARAM, ELTS, ERRFLG, ERRSTR (1)   ) 
              
                     IF ( ERRFLG ) THEN
            
C
C                       We could not calculate standard SPICE conic
C                       elements from a given set. Signal and exit.
C
                        CALL DAFCLS ( HANDLE )
                        CALL DELFIL ( OUTFN )
                     
                        CALL SETMSG ( ERRSTR(1)(:RTRIM(ERRSTR(1)) )   //
     .                              ' Verify whether set of orbital ' //
     .                              'elements specified in the '      //
     .                              'keyword ''#'' of the setup '     //
     .                              'file ''#'' is correct and '      //
     .                              'whether it''s consistent with '  //
     .                              'actual values provided in the '  //
     .                              'input file ''#''. '              )
                        CALL ERRCH  ( '#', KDATOR                     )
                        CALL ERRCH  ( '#', CMDFIL                     )
                        CALL ERRCH  ( '#', INPFN                      )
                        CALL SIGERR ( ERRSTR (2)                      )

                     END IF
                                         
C
C                    Convert elements to state vector and accumulate
C                    in the STATE buffer.
C                       
                     CALL CONICS ( ELTS, DVL (1), STATE ( 1, J ) )
                       
C                      
C                    Accumulate epoch in EPOCH buffer.
C                  
                     EPOCH ( J ) = DVL (1) 
                  
                  ELSE IF (INDTVL (:RTRIM ( INDTVL )) .EQ. INSTTP ) THEN
                                                 
C
C                    Input type is STATES. We accumulate state vector
C                    in STATE buffer .
C                         
                     DO L = 1, 6
                     
                        STATE ( L, J ) = DVL ( L + 1 ) *  DSTCOF
                        
                     END DO 
                  
C
C                    Accumulate epoch in EPOCH buffer.
C                  
                     EPOCH ( J ) = DVL (1)
                  
C
C                    For output SPK types 15 and 17 we need to convert 
C                    state to SPICE conic elements that will be stored 
C                    in the output SPK file.
C
                     IF ( OUTTVL .EQ. 15 .OR. OUTTVL .EQ. 17 ) THEN 
                                
                        CALL OSCELT ( STATE ( 1, J ), EPOCH ( J ), 
     .                                CNGMVL, ELTS                ) 
                                         
                     END IF

                  ELSE 

C
C                    If input type is EQ_ELEMENTS we simply accumulate 
C                    epoch in EPOCH buffer and leave the rest 
C                    parameters in the DVAL array.
C
                     EPOCH ( J ) = DVL (1)
                  
                  END IF   

C                           
C                 Now we do additional processing depending on the 
C                 output SPK type. There are two cases here: SPK 
C                 type 15 for which we may need to compute the elements 
C                 for the time of periapsis amd SPK 8 and 12 for which 
C                 we need to verify equal spacing between data points.
C              
                  IF ( OUTTVL .EQ. 15 ) THEN

C                     
C                    If mean anomaly of the input elements is not zero,
C                    we need to re-compute the elements to be at the 
C                    time of periapsis.
C
                     IF ( ELTS (6) .NE. 0 ) THEN

                        IF ( ELTS (2) .LT. 1.D0 ) THEN     

C
C                          Case of elliptical orbit.
C
C                          Start with determining the time of the
C                          nearest periapse.
C                                                   
                           WRKEL = ( 1.D0 - ELTS (2) ) / ELTS (1)
                           MEANM = DSQRT ( ELTS (8) * WRKEL ) * WRKEL

                           M0 = ELTS (6)
                           IF ( M0 .GT. PI() ) THEN
                              M0 = M0 - TWOPI()
                           END IF

                           EPOCH ( J ) = ELTS (7) - M0 / MEANM 

C
C                          Like SPKE15, use brute-force to compute true
C                          anomaly of the input record.
C
                           CALL CONICS ( ELTS, EPOCH( J ), HSTATE )
                           TA = VSEP ( HSTATE, STATE ( 1, J ) )
                           TA = SIGN ( TA, M0 )

C
C                          Continue mimicking SPKE15 algorithm computing
C                          node and apsides delta angles.
C
                           COSINC = DCOS( ELTS( 3 ) )

                           P      = ELTS (1) * ( 1.D0 + ELTS (2) )

                           Z      = TA * 1.5D0 * CNJ2VL *(REQUAT/P)**2
                           DNODE  = -Z * COSINC
                           DPERI  =  Z * ( 2.5D0*COSINC**2 - 0.5D0 )

C
C                          Apply node and apsides delta angles to the
C                          elements as directed by the precession flag.
C                          If the flag is 3, do no adjustments. If the
C                          flag is not 1, adjust the argument of
C                          periapse. If the flag is not 2, adjust the
C                          longitude of the ascending node.
C
                           IF ( J2FLG .NE. 3.D0 ) THEN

                              IF ( J2FLG .NE. 1.D0 ) THEN
                                 ELTS( 5 ) = ELTS( 5 ) - DPERI
                              END IF
                           
                              IF ( J2FLG .NE. 2.D0 ) THEN
                                 ELTS( 4 ) = ELTS( 4 ) - DNODE
                              END IF

                           END IF

                        ELSE IF ( ELTS (2) .GT. 1.D0 ) THEN

C
C                          Case of hyperbolic orbit.
C
                           WRKEL = ( ELTS (2) - 1.D0 ) / ELTS (1)
                           MEANM = DSQRT ( ELTS (8) * WRKEL ) *  WRKEL
                           
                           EPOCH ( J ) =  ELTS (7) - ELTS (6) / MEANM 

                        ELSE

C
C                          Case of parabolic orbit.
C                          
                           MEANM = DSQRT ( ELTS (8) / 2.D0 / ELTS (1) )/
     .                             ELTS (1)
                           
                           EPOCH ( J ) =  ELTS (7) - ELTS (6) / MEANM 

                        END IF     

C
C                       Calculate state vector at epoch of periapsis.
C           
                        ELTS (6) = 0.D0
                        ELTS (7) = EPOCH ( J )

                        CALL CONICS ( ELTS, EPOCH( J ), STATE ( 1, J ) )
                                                 
                     END IF
                                          
                  ELSE IF ( OUTTVL .EQ.  8 .OR.
     .                      OUTTVL .EQ. 12      ) THEN

C
C                    For types 8 and 12 we need to verify time spacing
C                    between this data point and the previous one. It
C                    must the same (within tolerance) as the one before.
C
                     IF ( J .GT. 2 ) THEN

                        TMPDP = EPOCH(J) - EPOCH(J-1)

                        IF ( DABS( TMPDP - TSTEP ) .GT. TSTOL ) THEN

C
C                          Time step changed. Signal an error and exit.
C
                           CALL DAFCLS ( HANDLE )
                           CALL DELFIL ( OUTFN )
                     
                           CALL SETMSG ( 'Time spacing between input '//
     .                                   'data points #, #, and # is '//
     .                                   'not constant. It must be '  //
     .                                   'for output SPK types 8 and '//
     .                                   '12. UTC times of the data ' //
     .                                   'points are: ''#'', ''#'', ' //
     .                                   'and ''#''.'                 )
                           CALL ERRINT ( '#', RECIDX - 2              )
                           CALL ERRINT ( '#', RECIDX - 1              )
                           CALL ERRINT ( '#', RECIDX                  )
                           CALL TIMOUT ( EPOCH( J-2 ), 
     .                         'YYYY-MM-DDTHR:MN:SC.### ::RND', ERROR )
                           CALL ERRCH  ( '#', ERROR                   )
                           CALL TIMOUT ( EPOCH( J-1 ), 
     .                         'YYYY-MM-DDTHR:MN:SC.### ::RND', ERROR )
                           CALL ERRCH  ( '#', ERROR                   )
                           CALL TIMOUT ( EPOCH( J ), 
     .                         'YYYY-MM-DDTHR:MN:SC.### ::RND', ERROR )
                           CALL ERRCH  ( '#', ERROR                   )
                           CALL SIGERR ( 'SPICE(UNEQUALTIMESTEP)'     )

                        END IF

                     END IF

C
C                    Memorize current time step.
C
                     IF ( J .GT. 1 ) THEN
                        
                        TSTEP = EPOCH(J) - EPOCH(J-1)

                     END IF

                  END IF

C
C                 The next block is an initialization and check-out 
C                 for a few things that we couldn't get/check before 
C                 we have got at least one input record ( .... hm,
C                 for some SPK types it can be THE ONLY record we need.)
C
                  IF ( ONERUN ) THEN

C
C                    For output types 15 and 17 we need to compute 
C                    center body North Pole RA and DEC if they weren't 
C                    provided in the setup file.
C
                     IF ( (OUTTVL .EQ. 15 .OR. OUTTVL .EQ. 17) 
     .                    .AND.
     .                    ( RAKEY .OR. DEKEY )                 ) THEN

C
C                       First, get matrix from J2000 to the output
C                       reference frame at the time of our data point.
C                                     
                        CALL SXFORM ('J2000', FRNMVL, EPOCH( J ), XFRM )

                        DO L = 1, 3                           
                           DO M = 1, 3
                              MWOR ( L, M ) = XFRM ( L, M )
                           END DO
                        END DO   
    
C
C                       Now compute rotation matrix from J2000 to the 
C                       center body body-fixed IAU frame, extract pole 
C                       direction (Z), rotate it to the output 
C                       reference frame and compute its RA and DEC.
C
                        CALL BODMAT ( CNIDVL, EPOCH ( J ), TIPM )
                     
                        CALL MXMT ( MWOR, TIPM, MPOL )
                     
                        PV (1) = MPOL (1,3)
                        PV (2) = MPOL (2,3)
                        PV (3) = MPOL (3,3)
                     
                        CALL RECRAD ( PV, WRKEL, RAPOL, DEPOL )
                 
                     END IF   
                
C
C                    For output type 15 we need to compute P, E, TP, PA
C                    (refer to SPKW15 to see what they are :)
C
                     IF ( OUTTVL .EQ. 15 ) THEN

                        P = ELTS (1) * ( 1.D0 + ELTS (2) ) 
                        E = ELTS (2)
                        CALL UCRSS ( STATE (1, J), STATE (4, J), TP )
                        CALL VHAT  ( STATE (1 , J),              PA ) 

C
C                       We also set "end of segment data collection"
C                       flag because for output type 15 we need only
C                       one record ... and we have got it already.
C
                        EOSGMR = .TRUE.
                        JLEPOC = 1 
                                                           
                     END IF

C
C                    For output type 17 we need to compute re-assign 
C                    the equinoctial elements from the temporary buffer 
C                    DVAL or compute them from "plain" elements if we 
C                    have them from the input.
C
                     IF ( OUTTVL .EQ. 17 ) THEN 
                     
C                        
C                       Calculate equinoctial elements for output 
C                       type 17.
C
                        IF (INDTVL(: RTRIM ( INDTVL )) .EQ. INEQTP) THEN

C
C                          Input data type is EQ_ELEMENTS. 
C                 
                           EQEL (1) = DVL (21) * DSTCOF             
                           EQEL (2) = DVL (22)
                           EQEL (3) = DVL (23)
                           EQEL (4) = DVL (24) * ANGCOF
                           EQEL (5) = DVL (25)
                           EQEL (6) = DVL (26)
                           EQEL (7) = DVL (27) * ANGCOF
                           EQEL (8) = DVL (28) * ANGCOF
                           EQEL (9) = DVL (29) * ANGCOF

                        ELSE 
                        
C
C                          Input data type is not EQ_ELEMENTS.
C                          Convert conic elements to equinoctial.
C
                           EQEL (1) = ELTS (1) / ( 1.D0 - ELTS (2) )
                           EQEL (2) = ELTS (2) * 
     .                                DSIN ( ELTS (4) + ELTS (5) )
                           EQEL (3) = ELTS (2) *
     .                                DCOS ( ELTS (4) + ELTS (5) )
                           EQEL (4) = ELTS (4) + ELTS (5) + ELTS (6)
                           EQEL (5) = DTAN ( ELTS (3) / 2.D0 ) *
     .                                DSIN ( ELTS (4) )
                           EQEL (6) = DTAN ( ELTS (3) / 2.D0 ) *
     .                                DCOS ( ELTS (4) )
                           EQEL (7) = DVL (27) * ANGCOF
                           EQEL (8) = DVL (28) * ANGCOF
                           EQEL (9) = DVL (29) * ANGCOF 
                           
                        END IF

C
C                       Same as for type 15 -- we also set "end of
C                       segment data collection" flag because for
C                       output type 17 we need only one record ... and
C                       we have got it already.
C                                                           
                        EOSGMR = .TRUE.
                        JLEPOC = 1 
                          
                     END IF
                  
C
C                    For SPK types 8, 9, 12 and 13 we need to verify
C                    first data point epoch against start and stop
C                    times specified in the setup file. The
C                    corresponding SPKWxx routines will do it later, of
C                    course, but if we do this check now, user won't
C                    need to wait until the program "sucks" in all
C                    input data just to fail :-).
C
                     IF ( OUTTVL .EQ.  8 .OR. 
     .                    OUTTVL .EQ.  9 .OR.
     .                    OUTTVL .EQ. 12 .OR.
     .                    OUTTVL .EQ. 13      ) THEN
      
C
C                       Verify if START time is correctly defined 
C                       relatively first epoch of input data.
C                   
                        IF ( STATFL .AND. EPOCH (1) .GT. ETBEG ) THEN
                          
C
C                          Epoch of first point of input data is greater
C                          than START time defined in setup. Complain.
C
                           CALL DAFCLS ( HANDLE )
                           CALL DELFIL ( OUTFN )
                           CALL SETMSG ( 'The epoch of the first '    //
     .                                'input data file record is '    //
     .                                'greater than the start time '  //
     .                                'specified in the setup file '  //
     .                                'keyword ''#''.'                 )
                           CALL ERRCH  ( '#', KSTATM                   )
                           CALL SIGERR ( 'SPICE(INCONSISTSTARTTIME)'   )

                        END IF

C
C                       Verify if STOP time is correctly defined
C                       relatively first epoch of input data.
C
                        IF ( STOTFL .AND. EPOCH (1) .GT. ETEND ) THEN

C
C                          Epoch of first point of input data is greater
C                          than STOP time defined in setup. Complain.
C
                           CALL DAFCLS ( HANDLE )
                           CALL DELFIL ( OUTFN )
                           CALL SETMSG ( 'The epoch of the first '    //
     .                                'input data file record is '    //
     .                                'greater than the stop time '   //
     .                                'specified in the setup file '  //
     .                                'keyword ''#''.'                 )
                           CALL ERRCH  ( '#',  KSTOTM                  )
                           CALL SIGERR ( 'SPICE(INCONSISTSTOPTIME)'    )

                        END IF 
                  
                     END IF   
                  
                     ONERUN = .FALSE.

C                                      
C                    End of one time running part.
C
                  END IF
 
C
C                 The block in the following IF case essentially does
C                 time bracketing by comparing epoch of the current
C                 data record with the start and stop times provided in
C                 the setup file. (Note that at this point the EOSGMR
C                 is .TRUE. for output types 15 or 17, for which this
C                 bracketing is not relevant, and .FALSE. for all other
C                 types.)
C
                  IF ( .NOT. EOSGMR ) THEN

C
C                    While we are at it, let's check if our times are 
C                    increasing and non-duplicate. (Of course, SPKWxx
C                    will check for this too, but we can do a better 
C                    job by telling users which times exactly aren't 
C                    good before filling up all buffers and calling 
C                    SPKWxx.)
C
                     IF ( J .GT. 1 ) THEN

                        IF ( EPOCH( J ) .EQ. EPOCH( J - 1 ) ) THEN
                           CALL DAFCLS ( HANDLE )
                           CALL DELFIL ( OUTFN )
                           CALL TIMOUT ( EPOCH( J ), 
     .                          'YYYY-MM-DDTHR:MN:SC.### ::RND', ERROR )
                           CALL SETMSG ( 'The epoch of the input '    //
     .                          'data record No. # -- ''#'' -- is '   //
     .                          'the same as of the input data '      //
     .                          'record No. #. Duplicate time tags '  //
     .                          'are not allowed.'                     )
                           CALL ERRINT ( '#',  RECIDX - 1              )
                           CALL ERRCH  ( '#',  ERROR                   )
                           CALL ERRINT ( '#',  RECIDX                  )
                           CALL SIGERR ( 'SPICE(DUPLICATETIMES)'       )
                        END IF

                        IF ( EPOCH( J ) .LT. EPOCH( J - 1 ) ) THEN
                           CALL DAFCLS ( HANDLE )
                           CALL DELFIL ( OUTFN )
                           CALL SETMSG ( 'The epoch of the input '    //
     .                          'data record No. # -- ''#'' -- is '   //
     .                          'greater than the epoch of the input '//
     .                          'data record No. # -- ''#''. Times '  //
     .                          'out of order are not allowed.'        )
                           CALL ERRINT ( '#',  RECIDX - 1              )
                           CALL TIMOUT ( EPOCH( J - 1 ), 
     .                          'YYYY-MM-DDTHR:MN:SC.### ::RND', ERROR )
                           CALL ERRCH  ( '#',  ERROR                   )
                           CALL ERRINT ( '#',  RECIDX                  )
                           CALL TIMOUT ( EPOCH( J ), 
     .                          'YYYY-MM-DDTHR:MN:SC.### ::RND', ERROR )
                           CALL ERRCH  ( '#',  ERROR                   )
                           CALL SIGERR ( 'SPICE(TIMESOUTOFORDER)'      )
                        END IF

                     END IF

C
C                    Now, let's do time bracketing. Was START time
C                    provided in the setup file?
C
                     IF ( STATFL ) THEN

C
C                       Yes. Did we already find an input epoch greater 
C                       than the START time?
C
                        IF ( STAEPO ) THEN

C
C                          No. Is current epoch greater than or equal
C                          to the START time?
C                        
                           IF ( EPOCH (J) .GE. ETBEG ) THEN

C
C                             It is. We memorize the coverage start
C                             time and set the flag indicating that we
C                             are done processing start time bracket.
C
                              ETFST  = ETBEG
                              STAEPO = .FALSE.
                           
                           ELSE

C
C                             Current epoch is less than START time.
C                             Depending on whether we have enough
C                             padding states or not, we do nothing or
C                             "drop" the first buffered state.
C
                              IF ( J .GT. PADSTS ) THEN
                                 M = J * 6
                                 CALL REMLAD( 6, 1, STATE( 1, 1 ), M )
                                 CALL REMLAD( 1, 1, EPOCH( 1 ),    J )
                              END IF

                           END IF

                        END IF 
                     
                     ELSE

C
C                       START time was not provided in the setup file.
C                       We set it to be the first value of input data.
C
                        IF ( STAEPO ) THEN
                  
                           ETFST  = EPOCH (J)
                           STAEPO = .FALSE.
                        
                        END IF   
                  
                     END IF

C
C                    Was STOP time provided in the setup file?
C
                     IF ( STOTFL ) THEN

C
C                       Yes. Did we already find an input epoch greater 
C                       than STOP time? 
C
                        IF ( STOEPO ) THEN 

C
C                          No. Is current epoch greater than the STOP 
C                          time?
C
                           IF ( EPOCH (J) .GT. ETEND ) THEN

C
C                             It is. Memorize its index (as the
C                             temporary index of the last state we will
C                             write to the segment) and coverage end
C                             time and set the flag indicating that we
C                             are done processing end time bracket.
C
                              JLEPOC = J
                              ETLST  = ETEND
                              STOEPO = .FALSE.

C
C                             If we needed only one padding state or if
C                             we have filled up the buffer, we are
C                             done.
C
                              IF ( PADSTS .EQ. 1 .OR. 
     .                             J .EQ. MAXSTA      ) THEN
                                 EOSGMR = .TRUE.
                              END IF

                           ELSE
                           
C
C                             STOP time is defined in the setup but
C                             current epoch is less than it.
C
                              JLEPOC = J
                              ETLST = EPOCH (J)

                           END IF

                        ELSE

C
C                          Yes. We already found epoch greater than the 
C                          specified stop time. If we buffered enough 
C                          states for padding (or filled our buffer up)
C                          we are done.
C                          
                           IF ( (J - JLEPOC) .EQ. (PADSTS - 1) .OR. 
     .                           J .EQ. MAXSTA                 ) THEN
                              JLEPOC = J
                              EOSGMR = .TRUE.
                           END IF

                        END IF
             
                     ELSE

C
C                       STOP time is not defined in setup. We set it as
C                       current value of epoch array.
C
                        JLEPOC = J
                        ETLST = EPOCH (J)
                        
                     END IF

                  END IF
               
C
C                 Let's see if it's time to write a segment. We do it
C                 in two cases:
C           
C                    -- when we filled up a data buffer; or 
C
C                    -- when for some reason we have decided that we 
C                       have processed all input data we needed and 
C                       its time to write the last segment and bail 
C                       out of the program.
C
C                 The reason for the latter case would be that we have
C                 got one and only required record for types 15 and 17 
C                 or that the last record that we have got from the 
C                 input had time greater than the stop time provided in
C                 setup file. (in both cases EOSGMR was set to .TRUE.)
C
C                 In other words (Nicolas's words :) when we have 
C                 maximum set of states allowed per segment or epoch 
C                 greater than STOP time or process SPKW15 and SPKW17.
C                
                  IF ( J .EQ. MAXSTA .OR. EOSGMR  ) THEN

C
C                    Report that we write next SPK segment.
C                    
                     CALL TOSTDO ( ' '                            )
                     CALL TOSTDO ( 'Writing next SPK segment ...' )

C
C                    Compute time step (for fixed stepped types.) If we
C                    have got only one state, it's zero.
C
                     IF ( JLEPOC .GT. 1 ) THEN
                        TIMSTP = ( EPOCH( JLEPOC ) - EPOCH( 1 ) ) / 
     .                            DBLE( JLEPOC - 1 )
                     ELSE
                        TIMSTP = 0.D0
                     END IF

C
C                    Also, for table types if we have filled the buffer
C                    but didn't hit the STOP time boundary at the same
C                    time, we need to make sure that there is "soft and
C                    smooth" transition between this segment and the
C                    next one. As a preamble, we need to adjust segment
C                    coverage stop time to be PADSTS less than the last 
C                    buffered state.

                     IF ( .NOT. EOSGMR ) THEN
                        ETLST = EPOCH( JLEPOC - PADSTS )
                     END IF

C
C                    We will call corresponding SPKWxx depending on 
C                    our output SPK type.
C
                     IF ( OUTTVL .EQ. 5 ) THEN 
                     
                        CALL SPKW05 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                                ETFST, ETLST, SGIDVL, CNGMVL,
     .                                JLEPOC,
     .                                STATE(1,1), EPOCH(1)           )

                     ELSE IF ( OUTTVL .EQ. 8 ) THEN

C
C                       Adjust descriptor end time to make sure that
C                       round off doesn't trigger an error in SPKW08.
C
                        IF ( EPOCH(1)+(JLEPOC-1)*TIMSTP .LT. ETLST) THEN
                           ETLST = EPOCH(1)+(JLEPOC-1)*TIMSTP
                        END IF

                        CALL SPKW08 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                                ETFST, ETLST, SGIDVL, PLDGVL,
     .                                JLEPOC,
     .                                STATE(1,1), EPOCH(1), TIMSTP   )
     
                     ELSE IF ( OUTTVL .EQ. 9 ) THEN 
         
                        CALL SPKW09 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                                ETFST, ETLST, SGIDVL, PLDGVL,
     .                                JLEPOC,
     .                                STATE(1,1), EPOCH(1)           )

                     ELSE IF ( OUTTVL .EQ. 12 ) THEN

C
C                       Adjust descriptor end time to make sure that
C                       round off doesn't trigger an error in SPKW12.
C
                        IF ( EPOCH(1)+(JLEPOC-1)*TIMSTP .LT. ETLST) THEN
                           ETLST = EPOCH(1)+(JLEPOC-1)*TIMSTP
                        END IF

                        CALL SPKW12 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                                ETFST, ETLST, SGIDVL, PLDGVL,
     .                                JLEPOC,
     .                                STATE(1,1), EPOCH(1), TIMSTP   )
     
                     ELSE IF ( OUTTVL .EQ. 13 ) THEN 
         
                        CALL SPKW13 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                                ETFST, ETLST, SGIDVL, PLDGVL,
     .                                JLEPOC,
     .                                STATE(1,1), EPOCH(1)           )

                     ELSE IF ( OUTTVL .EQ. 15 ) THEN  
      
                        CALL SPKW15 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                                ETBEG, ETEND,SGIDVL, EPOCH (1),
     .                                TP, PA, P, E, J2FLG, PV,
     .                                CNGMVL, CNJ2VL, REQUAT         )
                           
                     ELSE IF ( OUTTVL .EQ. 17 ) THEN  

                        CALL SPKW17 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                                ETBEG, ETEND, SGIDVL, EPOCH (1),
     .                                EQEL, RAPOL, DEPOL             )
                  
                     END IF

C
C                    Postambule for table types when we have filled the
C                    buffer but didn't hit the STOP time boundary at
C                    the same time, would be moving last 2*PADSTS
C                    states to the top of the buffer before we will
C                    continue processing data for the next segment.
C
                     IF ( .NOT. EOSGMR ) THEN

C
C                       Reset segment coverage start time.
C
                        ETFST  = EPOCH( JLEPOC - PADSTS )

C
C                       Delete first (JLEPOC-2*PADSTS-1) states and
C                       epochs from the buffers.
C
                        N = ( JLEPOC - 2 * PADSTS - 1 ) * 6
                        M =   JLEPOC * 6
                        CALL REMLAD( N, 1, STATE( 1, 1 ), M )

                        N =   JLEPOC - 2 * PADSTS - 1
                        M =   JLEPOC
                        CALL REMLAD( N, 1, EPOCH( 1 ),    M )

C
C                       Reset index of the last buffered state and
C                       segment coverage stop time.
C
                        JLEPOC = PADSTS * 2 + 1
                        J      = JLEPOC
                        ETLST  = EPOCH( J )

                     END IF
C
C                    End of the segment writing block.
C
                  END IF
C                 
C                 End of single complete input data record processing 
C                 block.
C                  
               END IF 
            
C
C              Check if we should continue to process the data
C              for next segment.
C                                                          
               IF ( .NOT. EOSGMR ) THEN

C
C                 Continue to process input data. Reset FIRST position 
C                 to continue the parsing.
C
                  FIRST = NCPOS ( BUFFER, ' ', NPOS + 1 ) 
                     
C                         
C                 Increase counter to parse next value. 
C            
                  I = I + 1 
                            
               ELSE
            
C              
C                 We should finish data process. Set FIRST equal zero
C                 to leave the buffer string parsing loop.
C
                  FIRST = 0
      
               END IF 
                                   
C
C           End of buffer string parsing loop.
C                       
            END DO 
         
C                                               
C           Check whether we should continue processing of the input 
C           data for next segment.
C
            IF ( .NOT. EOSGMR ) THEN

C
C              Yes, we should. Then reset buffer content to continue
C              reading input data into the buffer.
C
               BUFFER = BUFAUX ( : K )
               
            ELSE

C              
C              We should finish input data processing. Set EOF to leave
C              the top level loop (input data buffering loop).
C               
               EOF = .TRUE.
               
            END IF      

C       
C           End of the top loop (input data buffering loop).
C
         END DO 

C
C        Check if we still have some data in the data buffer and should
C        write the last segment.
C
         IF ( .NOT. EOSGMR ) THEN

C
C           Yes, we should write one more segment. Let's check whether
C           our START boundary, if we had one, was processed. If not,
C           it means that that START time is greater than the last
C           point (and only) point that we accumulated, and the segment 
C           coverage start time (ETFST) 
C           did not get set. Let's set it.
C
            IF ( STATFL .AND. STAEPO ) THEN
               ETFST  = ETBEG
            END IF

C
C           Do the same for if STOP boundary was set but not processed:
C           set segment coverage end time. 
C
            IF ( STOTFL .AND. STOEPO ) THEN
               ETLST  = ETEND
            END IF
         
C
C           Next, let's check whether the data that we have in the data
C           buffer falls within start and stop time boundaries, if such
C           were defined in the setup file. This must be true for SPK
C           types 8, 9, 12 and 13.
C
            IF ( OUTTVL .EQ.  8 .OR. 
     .           OUTTVL .EQ.  9 .OR.
     .           OUTTVL .EQ. 12 .OR. 
     .           OUTTVL .EQ. 13      ) THEN
      
               IF ( STATFL .AND. EPOCH (J) .LT. ETBEG ) THEN

C
C                 Epoch of last point of input data is less
C                 than START time defined in setup. Complain.
C
                  CALL DAFCLS ( HANDLE )
                  CALL DELFIL ( OUTFN )
                  CALL SETMSG ( 'The epoch of the last input data '   //
     .                       'file record is smaller than the start ' //
     .                       'time specified in the setup file '      //
     .                       'keyword ''#''.'                          )
                  CALL ERRCH  ( '#',  KSTATM                           )
                  CALL SIGERR ( 'SPICE(INCONSISTSTARTTIME)'            )
   
               END IF

               IF ( STOTFL .AND. EPOCH (J) .LT. ETEND ) THEN

C
C                 Epoch of last point of input data is less
C                 than STOP time defined in setup. Complain.
C
                  CALL DAFCLS ( HANDLE )
                  CALL DELFIL ( OUTFN )
                  CALL SETMSG ( 'The epoch of the last input data '   //
     .                       'file record is smaller than the stop '  //
     .                       'time specified in the setup file '      //
     .                       'keyword ''#''.'                          )
                  CALL ERRCH  ( '#',  KSTOTM                           )
                  CALL SIGERR ( 'SPICE(INCONSISTSTOPTIME)'             )
   
               END IF

            END IF

C
C           We may need to write last segment process only for types 
C           5, 8, 9, 12 and 13.
C                    
            CALL TOSTDO ( ' '                            )
            CALL TOSTDO ( 'Writing last SPK segment ...' )

C
C           Compute time step (for fixed stepped types.) If we have got
C           only one state, it's zero.
C
            IF ( JLEPOC .GT. 1 ) THEN
               TIMSTP = ( EPOCH(JLEPOC) - EPOCH(1) ) /  
     .                   DBLE( JLEPOC-1 )
            ELSE
               TIMSTP = 0.D0
            END IF

C
C           We will call corresponding SPKWxx depending on our output
C           SPK type.
C
            IF ( OUTTVL .EQ. 5 ) THEN 

               CALL SPKW05 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                       ETFST, ETLST, SGIDVL, CNGMVL,
     .                       JLEPOC,
     .                       STATE(1,1), EPOCH(1)           )

            ELSE IF ( OUTTVL .EQ. 8 ) THEN
 
C
C              Adjust descriptor end time to make sure that round off
C              doesn't trigger an error in SPKW08.
C
               IF ( EPOCH(1)+(JLEPOC-1)*TIMSTP .LT. ETLST ) THEN
                  ETLST = EPOCH(1)+(JLEPOC-1)*TIMSTP
               END IF

               CALL SPKW08 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                       ETFST, ETLST, SGIDVL, PLDGVL,
     .                       JLEPOC,
     .                       STATE(1,1), EPOCH(1), TIMSTP   )
     
            ELSE IF ( OUTTVL .EQ. 9 ) THEN 
         
               CALL SPKW09 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                       ETFST, ETLST, SGIDVL, PLDGVL,
     .                       JLEPOC,
     .                       STATE(1,1), EPOCH(1)           )
                  
            ELSE IF ( OUTTVL .EQ. 12 ) THEN
 
C
C              Adjust descriptor end time to make sure that round off
C              doesn't trigger an error in SPKW12.
C
               IF ( EPOCH(1)+(JLEPOC-1)*TIMSTP .LT. ETLST ) THEN
                  ETLST = EPOCH(1)+(JLEPOC-1)*TIMSTP
               END IF

               CALL SPKW12 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                       ETFST, ETLST, SGIDVL, PLDGVL,
     .                       JLEPOC,
     .                       STATE(1,1), EPOCH(1), TIMSTP   )
     
            ELSE IF ( OUTTVL .EQ. 13 ) THEN 
         
               CALL SPKW13 ( HANDLE, OBIDVL, CNIDVL, FRNMVL,
     .                       ETFST, ETLST, SGIDVL, PLDGVL,
     .                       JLEPOC,
     .                       STATE(1,1), EPOCH (1)          )
                  
            END IF
         
         END IF

C 
C        Close the input data file.
C      
         CLOSE ( INPUNT ) 

      END IF

C
C     Close the output SPK file.
C
      CALL SPKCLS ( HANDLE )

C
C     OFF of SPICE error HANDLER.                      
C
      CALL TOSTDO ( ' '         )
      CALL TOSTDO ( 'All done.' )
      CALL TOSTDO ( ' '         )
      
      CALL CHKOUT ( 'MKSPK' )         
                  
      CALL BYEBYE ( 'SUCCESS' )

      END
