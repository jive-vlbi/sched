C$Program      CHRONOS ( SPICE Time Conversion Tool)
 
      PROGRAM  CHRONOS
 
C$ Abstract
C
C     CHRONOS is a program converting time between various time systems
C     and types. Currently it supports the following time systems/
C     types:
C
C        System         Type(s)
C       ---------      ------------------------
C        UTC            SCET, ERT, ETT, LT
C        ET             SCET, ERT, ETT, LT, SECONDS
C        SCLK           SCLK, HEX, TICKS
C        LST            LST, LSUN
C
C     To convert time from one supported system/type to another
C     CHRONOS program usage is:
C
C           % CHRONOS  -SETUP <setup file name OR kernel file name(s)>
C                      -FROM <"from" time system>
C                     [-FROMTYPE <"from" time type>]
C                      -TO <"to" time system>
C                     [-TOTYPE <"to" time type>]
C                     [-FORMAT <output time format picture>]
C                      -TIME <input time> | -BATCH
C                     [-SC <sc ID>]
C                     [-CENTER <central body ID>]
C                     [-LANDINGTIME <UTC time of the landing>]
C                     [-SOL1INDEX <index of the first SOL>]
C                     [-NOLABEL]
C                     [-TRACE]
C
C     To display help:
C
C           % CHRONOS [-HELP|-H]
C
C     To display usage:
C
C           % CHRONOS -USAGE|-U
C
C     To display setup file template:
C
C           % CHRONOS  -TEMPLATE
C
C     Command line parameters specified in [] are optional. Command
C     line keys '-XXXXXXX' are case insensitive. Any of the command
C     line options can be present in the command line multiple times.
C     In such cases the last appearance takes precedence. Order in
C     which options are specified is insignificant.
C
C     Although not required, the program allows certain parameters to
C     be provided in a setup file. Setup file name is usually provided
C     on the command line. If it's not present there the program looks
C     for such name in environment variable CHRONOS_SETUP_FILE.
C
C     The setup file format should correspond to the SPICE Kernel Text
C     file format specification, i.e. it must contain data formatted as
C     a set of KEYWORD=VALUE assignments enclosed between
C
C        \begindata
C        \begintext
C
C     markers. Each assignment and marker must be on a line by itself.
C
C     The following parameters may be provided in a setup file:
C
C        \begindata
C           LEAPSECONDS_FILE = 'name of a LSK file'
C           SCLK_FILE = 'name of a SCLK file for the mission'
C           PCK_FILE = 'name of a PCK file'
C           SPK_FILES = ( 'name of an SPK file', '...' )
C           CK_FILES = ( 'name of a CK file', '...' )
C           FRAMES_FILE = 'name of a frame definitions file'
C           SPACECRAFT_ID = NAIF ID for the spacecraft
C           CENTER_ID = NAIF ID for the center body
C           LANDING_TIME = 'UTC time of the landing'
C           LANDING_SOL_INDEX = SOL index of the landing
C        \begintext
C
C     Note that either or all of the SPACECRAFT_ID, CENTER_ID,
C     LANDING_TIME, and LANDING_SOL_INDEX parameters can also be
C     provided using the command line switches. If done so, the setup
C     file value corresponding to a command line value is not needed,
C     and, if present, is ignored by the program.
C
C     Similarly, the kernels files to be loaded can be provided using
C     the standard SPICE interface -- with the KERNELS_TO_LOAD
C     parameter:
C
C        \begindata
C           KERNELS_TO_LOAD = (
C                         'name of a LSK file',
C                         'name of a SCLK file ',
C                         'name of a PCK file',
C                         'name of an SPK file',
C                         '...',
C                         'name of a CK file',
C                         '...',
C                         'name of an FK file'
C                             )
C        \begintext
C
C     or even by simply listing them after the -SETUP command line
C     switch. In either of these two cases, specifying the
C     LEAPSECONDS_FILE, SCLK_FILE, PCK_FILE, SPK_FILES, CK_FILES, and
C     FRAMES_FILE setup file parameters is not necessary.
C
C     Note that if any other KEYWORD=VALUE definitions (such as LSK or
C     PCK values) are present in the setup file, they get loaded into
C     the program automatically. In such cases programs checks whether
C     required LSK values are already loaded and if so it's doesn't
C     load external LSK file(s).
C
C     Custom format for a particular time system/type pair can be
C     specified in a setup file using keywords [SYSTEM]_{TYPE}_FORMAT,
C     where [SYSTEM] and {TYPE} are corresponding character
C     designations (for example: UTC_SCET_FORMAT = 'YYYY-DOY//HR:MN')
C
C     See CHRONOS User's Guide for more information.
C
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     CHRONOS.UG
C     TIME.REQ
C     SCLK.REQ
C
C$ Author_and_Institution
C
C     B.V.Semenov      (JPL)
C
C$ Version
C
C-    CHRONOS Version 2.2.0, 28-OCT-2011 (BVS)
C
C        Moved PARCML to support. Updated its calling sequence.
C
C-    CHRONOS Version 2.1.0, 18-AUG-2006 (BVS)
C
C        The CROHOS subroutine was updated to fix the bug causing
C        incorrect computation of the local solar time second length.
C        This change has also resulted in conversions from LST/LTST to
C        any other time system/type to produce results that differ from
C        those produced by the previous version by up to one second.
C
C        The LSTMID subroutine was updated to fix the bug that
C        prevented termination of the midnight search loop for input
C        local times at the end of a local day (23:59:xx).
C
C        No change in overall program functionality.
C
C-    CHRONOS Version 2.0.2, 07-OCT-2005 (BVS)
C
C        CROHOS subroutine was updated to remove non-standard use of
C        duplicate arguments in subroutine calls (LSTMID and LTIME). No
C        change in overall program functionality.
C
C-    CHRONOS Version 2.0.1, 17-MAR-2004 (BVS)
C
C        Small infrastructure-related tweak in CRONOS. No change
C        in functionality.
C
C-    CHRONOS Version 2.0.0, 29-JUL-2003 (BVS)
C
C        The program was re-written to call CRONOS routine to do the
C        conversions. Command line was extended to allow specification
C        of the s/c id, center id, landing time, the first SOL
C        index, and list of the kernel files in place of a single
C        setup file.
C
C-    CHRONOS Version 1.4.0, October 16, 2002 (BVS)
C
C        Fixed LSTMID bug causing midnight search loop not terminate
C        in some obscure cases.
C
C-    CHRONOS Version 1.3.0, September 8, 2002 (NJB)
C
C        File name declarations now use system-dependent name
C        length declared in chronos.inc.
C
C-    CHRONOS Version 1.2.3, 25-NOV-2001 (BVS)
C
C        Replaced INT with IDNINT in the last LSTMID call in the input
C        LST processing branch to prevent "loosing" second due to round
C        off on some platforms.
C
C-    CHRONOS Version 1.2.2, 03-MAY-2001 (BVS)(EDW)
C
C        Fixed DSPLAY to show backslash in template display on all
C        platforms. Added a BYEBYE( 'SUCCESS' ) call at program's end.
C
C-    CHRONOS Version 1.2.1, 01-NOV-1999 (WLT)
C
C        Declared LTIME to be an external routine.
C
C-    CHRONOS Version 1.2.0, 14-OCT-1999 (WLT)
C
C        Made chronos.pgm into chronos.pgm.mst to get around VMS
C        Command line interpreter problems of converting everything to
C        upper case (or lower case if we use GETCML).  This is a
C        temporary fix for version N0050 of the SPICE Toolkit. No other
C        environments are affected.
C
C-    CHRONOS Version 1.1.0, 17-FEB-1999 (BVS)
C
C        Changed output SCLK/TICKS conversion to use SCE2C (continuous
C        ticks.) Enabled output formatting for this system/type.
C
C-    CHRONOS Version 1.0.0, 14-MAY-1998 (BVS)
C
C-&
 
      IMPLICIT             NONE
 
C
C     CHRONOS Include file.
C
      INCLUDE              'chronos.inc'
 
C
C     SPICELIB functions.
C
      INTEGER               ISRCHC
      INTEGER               RTRIM
      LOGICAL               EXISTS
 
C
C     Variables.
C
      CHARACTER*(FILEN)     CKFN
      CHARACTER*(LINSIZ)    ERROR
      CHARACTER*(LINSIZ)    FILE
      CHARACTER*(FILEN)     FRAFN
      CHARACTER*(LINSIZ)    FSRC
      CHARACTER*(LINSIZ)    HFNAME
      CHARACTER*(LINSIZ)    INTIME
      CHARACTER*(FILEN)     LSKFN
      CHARACTER*(LINSIZ)    OUTTIM
      CHARACTER*(FILEN)     PCKFN
      CHARACTER*(FILEN)     SCLKFN
      CHARACTER*(FILEN)     SPKFN
      CHARACTER*(LINSIZ)    TOFRMT
 
      CHARACTER*(LLNSIZ)    CLVALS ( MAXKEY )
      CHARACTER*(LLNSIZ)    CMDLIN
      CHARACTER*(LLNSIZ)    HLINE
      CHARACTER*(LLNSIZ)    UNPRSD
      CHARACTER*(LLNSIZ)    LINE
      CHARACTER*(FILEN)     SETPFN
 
      CHARACTER*(WRDSIZ)    CENSTR
      CHARACTER*(WRDSIZ)    CLKEYS ( MAXKEY )
      CHARACTER*(WRDSIZ)    CURKEY
      CHARACTER*(WRDSIZ)    DEFTYP ( MAXSYS )
      CHARACTER*(WRDSIZ)    FROMTS
      CHARACTER*(WRDSIZ)    FROMTT
      CHARACTER*(WRDSIZ)    FTYP
      CHARACTER*(WRDSIZ)    HWD
      CHARACTER*(WRDSIZ)    HWORD
      CHARACTER*(WRDSIZ)    LSTTIM
      CHARACTER*(WRDSIZ)    SCSTR
      CHARACTER*(WRDSIZ)    SOLIDS
      CHARACTER*(WRDSIZ)    SYSTMS ( MAXSYS )
      CHARACTER*(WRDSIZ)    TOTS
      CHARACTER*(WRDSIZ)    TOTT
      CHARACTER*(WRDSIZ)    TYPES  ( MAXTYP )
 
      CHARACTER*(WRDSIZ*2)  FMTPIC ( MAXSYS, MAXTYP )
 
      INTEGER               BODYID
      INTEGER               FRSIDX
      INTEGER               FRTIDX
      INTEGER               I
      INTEGER               J
      INTEGER               N
      INTEGER               SCID
      INTEGER               SOLZER
      INTEGER               STDIN
      INTEGER               TOSIDX
      INTEGER               TOTIDX
      INTEGER               COUNT
      INTEGER               HNDL
      INTEGER               PTR
 
      LOGICAL               BATMOD
      LOGICAL               CLFLAG ( MAXKEY )
      LOGICAL               FMTTED ( MAXSYS, MAXTYP )
      LOGICAL               DONE
      LOGICAL               FOUND
      LOGICAL               NOLABL
      LOGICAL               OK
      LOGICAL               SYSTYP ( MAXSYS, MAXTYP )
      LOGICAL               ENVSTP
 
 
C
C     Standard SPICE error handling.
C
      CALL CHKIN  ( 'CHRONOS' )
 
C
C     Display only short and long error messages.
C
      CALL ERRPRT ( 'SET', 'NONE, SHORT, LONG, TRACEBACK' )
 
C
C     Get STDIN unit.
C
      CALL STDIO ( 'STDIN',  STDIN )
 
C
C     Get the command line.
C
      CALL GETCML ( LINE )
      HLINE = LINE
 
C
C     Get parameter arrays -- time systems and types, format pictures
C     and flags, and command line keys.
C
      CALL CRCNST ( SYSTMS, TYPES,  DEFTYP, SYSTYP, FMTTED, FMTPIC,
     .                                                      CLKEYS )
 
C
C     Parse command line.
C
      CALL PARCML( HLINE, MAXKEY, CLKEYS, CLFLAG, CLVALS, FOUND,
     .             UNPRSD )
 
C
C     Are there any keys on the command line? Is one of the usage keys
C     present? Display USAGE and STOP if yes.
C
      IF ( .NOT. FOUND .OR.
     .     CLFLAG( ISRCHC( USGKEY, MAXKEY, CLKEYS ) ) .OR.
     .     CLFLAG( ISRCHC( UKEY,   MAXKEY, CLKEYS ) )       ) THEN
 
         CALL DSPLAY( 'USAGE', 'STOP' )
 
      END IF
 
C
C     Are there any help keys? Display HELP and STOP if yes.
C
      IF ( CLFLAG( ISRCHC( HLPKEY, MAXKEY, CLKEYS ) ) .OR.
     .     CLFLAG( ISRCHC( HKEY,   MAXKEY, CLKEYS ) )     ) THEN
 
         CALL DSPLAY( 'HELP', 'STOP' )
 
      END IF
 
C
C     What about template key? Display TEMPLATE and STOP if it's
C     present.
C
      IF ( CLFLAG( ISRCHC( TMLKEY, MAXKEY, CLKEYS ) ) ) THEN
 
         CALL DSPLAY( 'TEMPLATE', 'STOP' )
 
      END IF
 
C
C     If batch mode was requested, set the flag.
C
      BATMOD = CLFLAG( ISRCHC( BATKEY, MAXKEY, CLKEYS ) )
 
C
C     If no label printing was requested, set the flag.
C
      NOLABL = CLFLAG( ISRCHC( LBLKEY, MAXKEY, CLKEYS ) )
 
C
C     If printing trace was requested, set "speaker" ON. Also, change
C     label setting -- when trace ON label should be printed.
C
      IF ( CLFLAG( ISRCHC( TRCKEY, MAXKEY, CLKEYS ) ) ) THEN
 
         CALL SPEKON
         CALL DSPLAY( 'VERSION', 'PROCEED' )
         CALL SPEAK ( ' Actual command line: '//LINE(:RTRIM(LINE)) )
         CALL SPEAK ( ' '                                          )
         NOLABL = .FALSE.
 
      END IF
 
C
C     Well, nobody wants information about the program, they just want
C     to run it. So, check what other stuff we got on the command line.
C     But first, let set all values to blanks.
C
      SETPFN = ' '
      FROMTS = ' '
      FROMTT = ' '
      TOTS   = ' '
      TOTT   = ' '
      TOFRMT = ' '
      INTIME = ' '
      SCSTR  = ' '
      CENSTR = ' '
      LSTTIM = ' '
      SOLIDS = ' '
 
      DO I = 1, MAXKEY
 
         IF ( CLFLAG( I ) ) THEN
 
            CURKEY = CLKEYS(I)
 
            IF      ( CURKEY .EQ. STPKEY ) THEN
C
C              It's a setup file name.
C
               SETPFN = CLVALS( I )(:RTRIM(CLVALS( I )))
 
            ELSE IF ( CURKEY .EQ. FRMKEY ) THEN
C
C              It's "from" time system.
C
               FROMTS = CLVALS( I )(:RTRIM(CLVALS( I )))
               CALL UCASE( FROMTS, FROMTS )
 
            ELSE IF ( CURKEY .EQ. FRTKEY ) THEN
C
C              It's "from" time type.
C
               FROMTT = CLVALS( I )(:RTRIM(CLVALS( I )))
               CALL UCASE( FROMTT, FROMTT )
 
            ELSE IF ( CURKEY .EQ. TOKEY  ) THEN
C
C              It's "to" time system.
C
               TOTS = CLVALS( I )(:RTRIM(CLVALS( I )))
               CALL UCASE( TOTS, TOTS )
 
            ELSE IF ( CURKEY .EQ. TOTKEY ) THEN
C
C              It's "to" time type.
C
               TOTT = CLVALS( I )(:RTRIM(CLVALS( I )))
               CALL UCASE( TOTT, TOTT )
 
            ELSE IF ( CURKEY .EQ. FMTKEY ) THEN
C
C              It's "to" time format.
C
               TOFRMT = CLVALS( I )(:RTRIM(CLVALS( I )))
 
            ELSE IF ( CURKEY .EQ. TIMKEY ) THEN
C
C              It's input time string.
C
               INTIME = CLVALS( I )(:RTRIM(CLVALS( I )))
 
            ELSE IF ( CURKEY .EQ. SIDKEY ) THEN
C
C              It's spacecraft ID; save it in string.
C
               SCSTR = CLVALS( I )(:RTRIM(CLVALS( I )))
 
            ELSE IF ( CURKEY .EQ. BODKEY ) THEN
C
C              It's body ID; save it in string.
C
               CENSTR = CLVALS( I )(:RTRIM(CLVALS( I )))
 
            ELSE IF ( CURKEY .EQ. LSTKEY ) THEN
C
C              It's landing time.
C
               LSTTIM = CLVALS( I )(:RTRIM(CLVALS( I )))
 
            ELSE IF ( CURKEY .EQ. SOLKEY ) THEN
C
C              It's SOL 1 index; save it in string and integer.
C
               SOLIDS = CLVALS( I )(:RTRIM(CLVALS( I )))
 
               CALL NPARSI ( SOLIDS, SOLZER, ERROR, PTR )
               IF ( PTR .NE. 0 ) THEN
                  CALL SETMSG ( 'The first SOL index provided '   //
     .                          'on the command line, #, is '     //
     .                          'not an integer number.'           )
                  CALL ERRCH  ( '#', SOLIDS                        )
                  CALL SIGERR ( 'SPICE(BADSOLINDEX)'               )
               END IF
 
            END IF
 
         END IF
 
      END DO
 
C
C     Although CRONOS routine will throughly check consistency of the
C     inputs, from/to-system/types should be verified in this module
C     too. They are used to process other setups that can be provided
C     through the setup file. Start with "FROM" time system.
C
      FRSIDX = ISRCHC ( FROMTS, MAXSYS, SYSTMS )
      IF ( FROMTS .NE. ' ' ) THEN
         IF ( FRSIDX .EQ. 0 ) THEN
            CALL SETMSG ( 'Time system ''#'' from which the time' //
     .                    ' must be converted is not one of the ' //
     .                    'supported systems.'                     )
            CALL ERRCH  ( '#', FROMTS                              )
            CALL SIGERR ( 'SPICE(BADFROMTIMESYSTEM)'               )
         END IF
      ELSE
         CALL SETMSG ( 'Time system from which the time must '    //
     .                 'be converted wasn''t specified on the '   //
     .                 'command line using # switch.'              )
         CALL ERRCH  ( '#', FRMKEY                                 )
         CALL SIGERR ( 'SPICE(NOFROMTIMESYSTEM)'                   )
      END IF
 
C
C     "TO" time system goes second.
C
      TOSIDX = ISRCHC ( TOTS, MAXSYS, SYSTMS )
      IF ( TOTS .NE. ' ' ) THEN
         IF ( TOSIDX .EQ. 0 ) THEN
            CALL SETMSG ( 'Time system ''#'' to which the time '  //
     .                    'must be converted is not one of the '  //
     .                    'supported systems.'                     )
            CALL ERRCH  ( '#', TOTS                                )
            CALL SIGERR ( 'SPICE(BADTOTIMESYSTEM)'                 )
         END IF
      ELSE
         CALL SETMSG ( 'Time system to which the time must '      //
     .                 'be converted wasn''t specified on the '   //
     .                 'command line using # switch.'              )
         CALL ERRCH  ( '#', TOKEY                                  )
         CALL SIGERR ( 'SPICE(NOTOTIMESYSTEM)'                     )
      END IF
 
C
C     "FROM" time type goes third.
C
      FRTIDX = ISRCHC ( FROMTT, MAXTYP, TYPES )
      IF ( FRTIDX .NE. 0 ) THEN
         IF ( .NOT. SYSTYP( FRSIDX, FRTIDX  ) ) THEN
            CALL SETMSG ( 'Time type ''#'' is not applicable '    //
     .                    'for time system ''#'' from which '     //
     .                    'the time must be converted.'            )
            CALL ERRCH  ( '#', FROMTT                              )
            CALL ERRCH  ( '#', FROMTS                              )
            CALL SIGERR ( 'SPICE(MISMATCHFROMTIMETYPE)'            )
         END IF
      ELSE
         IF ( FROMTT .NE. ' ' ) THEN
            CALL SETMSG ( 'Time type ''#'' from which the time '  //
     .                    'must be converted is not one of the '  //
     .                    'supported types.'                       )
            CALL ERRCH  ( '#', FROMTT                              )
            CALL SIGERR ( 'SPICE(BADFROMTIMETYPE)'                 )
         ELSE
C
C           Set "from" type to default type for that system if the
C           value that we have got is blank.
C
            FROMTT = DEFTYP( FRSIDX )
            FRTIDX = ISRCHC ( FROMTT, MAXTYP, TYPES )
         END IF
      END IF
 
C
C     "TO" time type goes fourth.
C
      TOTIDX = ISRCHC ( TOTT, MAXTYP, TYPES )
      IF ( TOTIDX .NE. 0 ) THEN
         IF ( .NOT. SYSTYP( TOSIDX, TOTIDX  ) ) THEN
            CALL SETMSG ( 'Time type ''#'' is not applicable '    //
     .                    'for time system ''#'' to which '       //
     .                    'the time must be converted.'            )
            CALL ERRCH  ( '#', TOTT                                )
            CALL ERRCH  ( '#', TOTS                                )
            CALL SIGERR ( 'SPICE(MISMATCHTOTIMETYPE)'              )
         END IF
      ELSE
         IF ( TOTT .NE. ' ' ) THEN
            CALL SETMSG ( 'Time type ''#'' to which the time '    //
     .                    'must be converted is not one of the '  //
     .                    'supported types.'                       )
            CALL ERRCH  ( '#', TOTT                                )
            CALL SIGERR ( 'SPICE(BADTOTIMETYPE)'                   )
         ELSE
C
C           Set "to" type to default type for that system if the value
C           that we have got is blank.
C
            TOTT = DEFTYP( TOSIDX )
            TOTIDX = ISRCHC ( TOTT, MAXTYP, TYPES )
         END IF
      END IF
 
C
C     If setup file name was not provided on the command line or if it
C     was blank, look for environment variable.
C
      IF ( SETPFN .EQ. ' ' ) THEN
 
         CALL ZZGETENV ( STPENV, SETPFN )
 
         IF ( SETPFN .EQ. ' ' ) THEN
            CALL SETMSG ( 'Setup file name or kernel file names ' //
     .                    'weren''t provided '                    //
     .                    'neither on the command line using # '  //
     .                    'switch nor via environment variable '  //
     .                    '''#''.'                                 )
            CALL ERRCH  ( '#', STPKEY                              )
            CALL ERRCH  ( '#', STPENV                              )
            CALL SIGERR ( 'SPICE(NOFILENAMES)'                     )
         END IF
 
         ENVSTP = .TRUE.
 
      ELSE
 
         ENVSTP = .FALSE.
 
      END IF
 
C
C     The value provided with the setup file command line key or
C     environment variable can contain not just one but a list of file
C     names. This way the user can provide all kernel names on the
C     command line without even bothering to make a setup file.
C     Therefore, the files from SETPFN value must be loaded in a loop.
C
      DO WHILE ( SETPFN .NE.  ' ' )
 
C
C        Pick the next file name in the list.
C
         CALL NEXTWD( SETPFN, HFNAME, SETPFN )
 
         IF ( .NOT. EXISTS( HFNAME ) ) THEN
            IF ( ENVSTP ) THEN
               CALL SETMSG ( 'The file ''#'' listed in the '      //
     .                       'environment variable ''#'' '        //
     .                       'doesn''t exist.'                     )
               CALL ERRCH  ( '#', HFNAME                           )
               CALL ERRCH  ( '#', STPENV                           )
               CALL SIGERR ( 'SPICE(FILEDOESNTEXIST1)'             )
            ELSE
               CALL SETMSG ( 'The file ''#'' listed on the '      //
     .                       'command line doesn''t exist.'        )
               CALL ERRCH  ( '#', HFNAME                           )
               CALL SIGERR ( 'SPICE(FILEDOESNTEXIST2)'             )
            END IF
         END IF
 
C
C        Load the file using FURNSH
C
         CALL FURNSH( HFNAME )
 
      END DO
 
C
C     First, process all inputs that could have been provided on the
C     command line or in the old-style setup file, namely: output time
C     format, s/c and body IDs, landing time, and first SOL index. The
C     rule is that command line value, if present, overwrites setup
C     file value.
C
 
C
C     If output format string has not been provided on the command
C     line, try to get it from the pool.
C
      IF ( TOFRMT .EQ. ' ' ) THEN
 
C
C        Make up a KEYWORD corresponding to this system/type format and
C        see if it was loaded.
C
         HWORD = SYSTMS(TOSIDX)(:RTRIM(SYSTMS(TOSIDX))) // '_' //
     .           TYPES(TOTIDX)(:RTRIM(TYPES(TOTIDX)))   // '_' //
     .           FMTKWD
 
         CALL GCPOOL ( HWORD, 1, 1, N, TOFRMT, FOUND )
 
         IF ( .NOT. FOUND ) THEN
 
C
C           If it wasn't provided in the setup file or on the command
C           line, leave it blank.
C
            TOFRMT = ' '
 
         END IF
 
      END IF
 
C
C     If s/c ID has not been provided on the command line, try to get
C     it for the pool.
C
      IF ( SCSTR .EQ. ' ' ) THEN
 
C
C        S/C ID is only needed if input/output system is SCLK (used in
C        SCLK routine calls) or if input/output type is LST, ERT, ETT,
C        or and LT (used in SPK/LTIME calls.)
C
         IF ( FROMTS .EQ. SCLSYS .OR. TOTS .EQ. SCLSYS .OR.
     .        FROMTS .EQ. LSTTYP .OR. TOTS .EQ. LSTTYP .OR.
     .        FROMTT .EQ. ERTTYP .OR. TOTT .EQ. ERTTYP .OR.
     .        FROMTT .EQ. ETTTYP .OR. TOTT .EQ. ETTTYP .OR.
     .        FROMTT .EQ. LTTYP  .OR. TOTT .EQ. LTTYP      ) THEN
 
            CALL GIPOOL ( SIDKWD, 1, 1, N, SCID, FOUND )
            IF ( FOUND ) THEN
               CALL INTSTR( SCID, SCSTR )
            ELSE
               CALL SETMSG ( 'S/C ID needed for time conversion ' //
     .                       'that has been requested was not '   //
     .                       'provided on the command line of in '//
     .                       'the setup file.'                     )
               CALL SIGERR ( 'SPICE(NOSCID)'                       )
            END IF
 
         END IF
 
      END IF
 
C
C     If center ID has not been provided on the command line, try to
C     get it from the pool.
C
      IF ( CENSTR .EQ. ' ' ) THEN
 
C
C        Body ID is only needed if input or output time system is LST.
C
         IF ( FROMTS .EQ. LSTTYP .OR. TOTS .EQ. LSTTYP ) THEN
 
            CALL GIPOOL ( BODKWD, 1, 1, N, BODYID, FOUND )
            IF ( FOUND ) THEN
               CALL INTSTR( BODYID, CENSTR )
            ELSE
               CALL SETMSG ( 'Body ID needed for time conversion '//
     .                       'that has been requested was not '   //
     .                       'provided on the command line of in '//
     .                       'the setup file.'                     )
               CALL SIGERR ( 'SPICE(NOBODYID)'                     )
            END IF
 
         END IF
 
      END IF
 
C
C     If landing time has not been provided on the command line, try to
C     get it from the pool.
C
      IF ( LSTTIM .EQ. ' ' ) THEN
 
C
C        Landing time is only needed if input or output time system is
C        LST.
C
         IF ( FROMTS .EQ. LSTTYP .OR. TOTS .EQ. LSTTYP ) THEN
 
            CALL GCPOOL ( LSTKWD, 1, 1, N, LSTTIM, FOUND )
 
C
C           If LST hasn't been provided in either way, it's OK. It only
C           means that CRONOS will not count local days.
C
            IF ( .NOT. FOUND ) THEN
               LSTTIM = ' '
            END IF
 
         END IF
 
      END IF
 
C
C     If first Sol index has not been provided on the command line, try
C     to get it from the pool.
C
      IF ( SOLIDS .EQ. ' ' ) THEN
 
C
C        First SOL index is only needed if input or output time system
C        is LST.
C
         IF ( FROMTS .EQ. LSTTYP .OR. TOTS .EQ. LSTTYP ) THEN
 
            CALL GIPOOL ( SOLKWD, 1, 1, N, SOLZER, FOUND )
 
C
C           If it has not been found, it's OK. It will be set to the
C           default value in CRONOS.
C
            IF ( FOUND ) THEN
               CALL INTSTR( SOLZER, SOLIDS )
            ELSE
               SOLIDS = ' '
            END IF
 
         END IF
 
      END IF
 
C
C     Time to process kernels files. Some of them may have been already
C     loaded by an earlier call to FURNSH (both directly or through
C     KERNELS_TO_LOAD keyword.)
C
 
C
C     We always need LSK data and LSK values are probably the only we
C     can safely check on.
C
      OK = .TRUE.
      CALL DTPOOL ( 'DELTET/DELTA_T_A', FOUND, N, HWD )
      OK = OK .AND. FOUND .AND. N.GE.1 .AND. HWD(:RTRIM(HWD)).EQ.'N'
      CALL DTPOOL ( 'DELTET/K', FOUND, N, HWD )
      OK = OK .AND. FOUND .AND. N.GE.1 .AND. HWD(:RTRIM(HWD)).EQ.'N'
      CALL DTPOOL ( 'DELTET/EB', FOUND, N, HWD )
      OK = OK .AND. FOUND .AND. N.GE.1 .AND. HWD(:RTRIM(HWD)).EQ.'N'
      CALL DTPOOL ( 'DELTET/M', FOUND, N, HWD )
      OK = OK .AND. FOUND .AND. N.GE.1 .AND. HWD(:RTRIM(HWD)).EQ.'N'
      CALL DTPOOL ( 'DELTET/DELTA_AT', FOUND, N, HWD )
      OK = OK .AND. FOUND .AND. N.GE.2 .AND. HWD(:RTRIM(HWD)).EQ.'N'
 
      IF ( .NOT. OK ) THEN
 
C
C        Well, one or more of the LSK parameters wasn't found. Look for
C        LSK keyword; it would be in the POOL if the setup file was an
C        old fashion setup.
C
         CALL GCPOOL ( LSKKWD, 1, 1, N, LSKFN, FOUND )
 
         IF ( FOUND ) THEN
 
            IF ( EXISTS( LSKFN ) ) THEN
 
               CALL FURNSH( LSKFN )
 
            ELSE
               CALL SETMSG ( 'LSK file ''#'' provided in '        //
     .                       'the setup file using ''#'' keyword' //
     .                       'doesn''t exist.'                     )
               CALL ERRCH  ( '#', LSKFN                            )
               CALL ERRCH  ( '#', LSKKWD                           )
               CALL SIGERR ( 'SPICE(LSKDOESNTEXIST)'               )
            END IF
 
         ELSE
            CALL SETMSG ( 'LSK file name wasn''t provided in '    //
     .                    'the setup file using ''#'' keyword or '//
     .                    'KERNELS_TO_LOAD keyword. LSK data has '//
     .                    'also not been provided as part of the '//
     .                    'setup file.'                            )
            CALL ERRCH  ( '#', LSKKWD                              )
            CALL SIGERR ( 'SPICE(NOLSKFILENAME)'                   )
         END IF
 
      END IF
 
C
C     SCLK file may have been loaded already, but for backward
C     compatibility we will also look for SCLK keyword and will try to
C     load SCLK provided in it. Note that SCLK file is needed only if
C     input/output system is SCLK or if input/output type is LST, ERT,
C     ETT, or and LT (these require position computation, which may
C     include CK calls somewhere in the chain.)
C
      IF ( FROMTS .EQ. SCLSYS .OR. TOTS .EQ. SCLSYS .OR.
     .     FROMTS .EQ. LSTTYP .OR. TOTS .EQ. LSTTYP .OR.
     .     FROMTT .EQ. ERTTYP .OR. TOTT .EQ. ERTTYP .OR.
     .     FROMTT .EQ. ETTTYP .OR. TOTT .EQ. ETTTYP .OR.
     .     FROMTT .EQ. LTTYP  .OR. TOTT .EQ. LTTYP      ) THEN
 
C
C        No attempt to check for already loaded SCLK constants -- too
C        much hassle. Simply get SCLK name from the POOL and try to
C        load the file provided in it (if exists.)
C
         CALL GCPOOL ( SCLKWD, 1, 1, N, SCLKFN, FOUND )
 
         IF ( FOUND ) THEN
 
            IF ( EXISTS( SCLKFN ) ) THEN
 
               CALL FURNSH( SCLKFN )
 
            ELSE
               CALL SETMSG ( 'SCLK file ''#'' provided in '       //
     .                       'the setup file using ''#'' keyword' //
     .                       'doesn''t exist.'                     )
               CALL ERRCH  ( '#', SCLKFN                           )
               CALL ERRCH  ( '#', SCLKWD                           )
               CALL SIGERR ( 'SPICE(SCLKDOESNTEXIST)'              )
            END IF
 
         END IF
 
      END IF
 
C
C     Same deal with SPK, CK, PCK and Frame files -- they may have been
C     loaded already, but we need to be backward compatible. therefore,
C     if on of the time types is LST, LSN, ERT, ETT or LT we will try
C     to look for appropriate, old-style-setup keywords.
C
      IF ( FROMTS .EQ. LSTTYP .OR. TOTS .EQ. LSTTYP .OR.
     .     FROMTT .EQ. ERTTYP .OR. TOTT .EQ. ERTTYP .OR.
     .     FROMTT .EQ. ETTTYP .OR. TOTT .EQ. ETTTYP .OR.
     .     FROMTT .EQ. LTTYP  .OR. TOTT .EQ. LTTYP      ) THEN
 
C
C        Look for and load SPKs, if any are provided through the SPK
C        keyword.
C
         CALL DTPOOL( SPKKWD, FOUND, N, HWD )
 
         IF ( FOUND .AND. N .GE. 1 .AND. HWD(1:1) .EQ. 'C' ) THEN
 
            DO I = 1, N
 
               CALL GCPOOL ( SPKKWD, I, 1, J, SPKFN, FOUND )
               IF ( EXISTS( SPKFN ) ) THEN
 
                  CALL FURNSH( SPKFN )
 
               ELSE
                  CALL SETMSG ( 'SPK file ''#'' provided in '     //
     .                          'the setup file using ''#'' '     //
     .                          'keyword doesn''t exist.'          )
                  CALL ERRCH  ( '#', SPKFN                         )
                  CALL ERRCH  ( '#', SPKKWD                        )
                  CALL SIGERR ( 'SPICE(SPKDOESNTEXIST)'            )
               END IF
 
            END DO
 
         END IF
 
C
C        Look for and load CKs, if any are provided through the CK
C        keyword.
C
         CALL DTPOOL( CKKWD, FOUND, N, HWD )
 
         IF ( FOUND .AND. N .GE. 1 .AND. HWD(1:1) .EQ. 'C' ) THEN
 
            DO I = 1, N
 
               CALL GCPOOL ( CKKWD, I, 1, J, CKFN, FOUND )
 
               IF ( EXISTS( CKFN ) ) THEN
 
                  CALL FURNSH( CKFN )
 
               ELSE
                  CALL SETMSG ( 'CK file ''#'' provided in '      //
     .                          'the setup file using ''#'' '     //
     .                          'keyword doesn''t exist.'          )
                  CALL ERRCH  ( '#', CKFN                          )
                  CALL ERRCH  ( '#', CKKWD                         )
                  CALL SIGERR ( 'SPICE(CKDOESNTEXIST)'             )
               END IF
 
            END DO
 
         END IF
 
C
C        Look for and load FKs, if any are provided through the FK
C        keyword.
C
         CALL DTPOOL( FRAKWD, FOUND, N, HWD )
 
         IF ( FOUND .AND. N .GE. 1 .AND. HWD(1:1) .EQ. 'C' ) THEN
 
            DO I = 1, N
 
               CALL GCPOOL ( FRAKWD, I, 1, J, FRAFN, FOUND )
 
               IF ( EXISTS( FRAFN ) ) THEN
 
                  CALL FURNSH( FRAFN )
 
               ELSE
                  CALL SETMSG ( 'FK file ''#'' provided in '      //
     .                          'the setup file using ''#'' '     //
     .                          'keyword doesn''t exist.'          )
                  CALL ERRCH  ( '#', FRAFN                         )
                  CALL ERRCH  ( '#', FRAKWD                        )
                  CALL SIGERR ( 'SPICE(FKDOESNTEXIST)'             )
               END IF
 
            END DO
 
         END IF
 
C
C        PCK at last. We could have tried to check for whether PCK
C        stuff is already in the POOL, but it's too much hassle. Simply
C        get PCK name from the POOL and try to load the file provided
C        in it (if exists.)
C
C
C        Look for and load FKs, if any are provided through the FK
C        keyword.
C
         CALL DTPOOL( PCKKWD, FOUND, N, HWD )
 
         IF ( FOUND .AND. N .GE. 1 .AND. HWD(1:1) .EQ. 'C' ) THEN
 
            DO I = 1, N
 
               CALL GCPOOL ( PCKKWD, I, 1, J, PCKFN, FOUND )
 
               IF ( EXISTS( PCKFN ) ) THEN
 
                  CALL FURNSH( PCKFN )
 
               ELSE
                  CALL SETMSG ( 'PCK file ''#'' provided in '     //
     .                          'the setup file using ''#'' '     //
     .                          'keyword doesn''t exist.'         )
                  CALL ERRCH  ( '#', PCKFN                        )
                  CALL ERRCH  ( '#', PCKKWD                       )
                  CALL SIGERR ( 'SPICE(PCKDOESNTEXIST)'           )
               END IF
 
            END DO
 
         END IF
 
      END IF
 
C
C     If trace is ON, report on loaded kernels.
C
      CALL SPEKST( HWORD )
 
      IF ( HWORD(1:2) .EQ. 'ON' ) THEN
 
C
C        Display list of names provided with command line option or
C        through the environment variable.
C
         IF ( ENVSTP ) THEN
            HWORD =   STPENV //        ' list: '
         ELSE
            HWORD =  '            -SETUP list: '
         END IF
         CALL SPEAK( HWORD // SETPFN(:RTRIM(SETPFN))                  )
 
         CALL SPEAK( ' '                                              )
         CALL SPEAK( '   Loaded SPICE kernels: '                      )
 
C
C        Display the list of loaded text kernels.
C
         CALL KTOTAL ( 'TEXT', COUNT )
         IF ( COUNT .EQ. 0 ) THEN
            CALL SPEAK( '                   TEXT: (no files loaded) ' )
         ELSE
            DO I = 1, COUNT
               CALL KDATA( I, 'TEXT', FILE, FTYP, FSRC, HNDL, FOUND )
               IF ( I .EQ. 1 ) THEN
                  CALL SPEAK( '                   TEXT: ' // FILE )
               ELSE
                  CALL SPEAK( '                         ' // FILE )
               END IF
            END DO
         END IF
 
C
C        Display the list of loaded SPKs.
C
         CALL KTOTAL ( 'SPK', COUNT )
         IF ( COUNT .EQ. 0 ) THEN
            CALL SPEAK( '                    SPK: (no files loaded) ' )
         ELSE
            DO I = 1, COUNT
               CALL KDATA( I, 'SPK', FILE, FTYP, FSRC, HNDL, FOUND )
               IF ( I .EQ. 1 ) THEN
                  CALL SPEAK( '                    SPK: ' // FILE )
               ELSE
                  CALL SPEAK( '                         ' // FILE )
               END IF
            END DO
         END IF
 
C
C        Display the list of loaded CKs.
C
         CALL KTOTAL ( 'CK', COUNT )
         IF ( COUNT .EQ. 0 ) THEN
            CALL SPEAK( '                     CK: (no files loaded) ' )
         ELSE
            DO I = 1, COUNT
               CALL KDATA( I, 'CK', FILE, FTYP, FSRC, HNDL, FOUND )
               IF ( I .EQ. 1 ) THEN
                  CALL SPEAK( '                     CK: ' // FILE )
               ELSE
                  CALL SPEAK( '                         ' // FILE )
               END IF
            END DO
         END IF
 
C
C        Display the list of loaded binary PCKs.
C
         CALL KTOTAL ( 'PCK', COUNT )
         IF ( COUNT .EQ. 0 ) THEN
            CALL SPEAK( '             Binary PCK: (no files loaded) ' )
         ELSE
            DO I = 1, COUNT
               CALL KDATA( I, 'PCK', FILE, FTYP, FSRC, HNDL, FOUND )
               IF ( I .EQ. 1 ) THEN
                  CALL SPEAK( '             Binary PCK: ' // FILE )
               ELSE
                  CALL SPEAK( '                         ' // FILE )
               END IF
            END DO
         END IF
 
      END IF
 
C
C     Re-assemble command line for CRONOS input.
C
      CALL INTSTR( SOLZER, SOLIDS )
      CMDLIN = FRMKEY // ' ' // FROMTS(:RTRIM(FROMTS)) // ' ' //
     .         FRTKEY // ' ' // FROMTT(:RTRIM(FROMTT)) // ' ' //
     .         TOKEY  // ' ' // TOTS(:RTRIM(TOTS))     // ' ' //
     .         TOTKEY // ' ' // TOTT(:RTRIM(TOTT))     // ' ' //
     .         FMTKEY // ' ' // TOFRMT(:RTRIM(TOFRMT)) // ' ' //
     .         SIDKEY // ' ' // SCSTR(:RTRIM(SCSTR))   // ' ' //
     .         BODKEY // ' ' // CENSTR(:RTRIM(CENSTR)) // ' ' //
     .         LSTKEY // ' ' // LSTTIM(:RTRIM(LSTTIM)) // ' ' //
     .         SOLKEY // ' ' // SOLIDS(:RTRIM(SOLIDS))
 
C
C     Get input times from STDIN if we are in the batch mode.
C
      IF ( BATMOD ) THEN
         CALL READLN ( STDIN, INTIME, DONE )
      ELSE
         DONE = .FALSE.
      END IF
 
C
C     Loop until no more input times (just once for command line mode
C     :).
C
      DO WHILE( .NOT. DONE )
 
C
C        Call CRONOS routine.
C
         CALL CRONOS( CMDLIN, 1, INTIME, OUTTIM )
 
C
C        Display the result based on requested tracing and labeling.
C
         CALL SPEAK( INTIME(:64) // '(' //FROMTS(:RTRIM(FROMTS)) //
     .               '/' // FROMTT(:RTRIM(FROMTT)) // ')' )
 
         IF ( NOLABL ) THEN
            CALL TOSTDO( OUTTIM(:64) )
         ELSE
            CALL TOSTDO( OUTTIM(:64) // '(' // TOTS(:RTRIM(TOTS)) //
     .               '/' // TOTT(:RTRIM(TOTT)) // ')' )
         END IF
 
         CALL SPEAK( ' ' )
 
C
C        Get next input time from STDIN if we are in the batch mode.
C
         IF ( BATMOD ) THEN
            CALL READLN ( STDIN, INTIME, DONE )
         ELSE
            DONE = .TRUE.
         END IF
 
C
C        End of processing input times.
C
      END DO
 
C
C     All done.
C
      CALL CHKOUT ( 'CHRONOS' )
 
      CALL BYEBYE( 'SUCCESS' )
 
      END
