
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>scanit</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>scanit</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
      SCANIT ( Scan a character string )
 
      SUBROUTINE SCANIT ( STRING, START,  ROOM,
     .                    NMARKS, MARKS,  MRKLEN, PNTERS,
     .                    NTOKNS, <a href="ident.html">IDENT</a>,  BEG,    END     )
 
      IMPLICIT NONE
 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     This routine serves as an umbrella routine for routines
     that are used to scan a string for recognized and unrecognized
     substrings.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     SEARCH
     PARSE
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
 
      CHARACTER*(*)         STRING
      INTEGER               ROOM
      INTEGER               NMARKS
      CHARACTER*(*)         MARKS   ( * )
      INTEGER               MRKLEN  ( * )
      INTEGER               PNTERS  ( * )
      INTEGER               START
      INTEGER               NTOKNS
      INTEGER               BEG     ( * )
      INTEGER               END     ( * )
      INTEGER               <a href="ident.html">IDENT</a>   ( * )
 
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Description
     --------  ---  --------------------------------------------------
     STRING     I   a string to be scanned.
     ROOM       I   space available for located substrings.
     NMARKS    I/O  number of recognizable substrings.
     MARKS     I/O  recognizable substrings.
     MRKLEN    I/O  an auxiliary array describing MARKS.
     PNTERS    I/O  an auxiliary array describing MARKS.
     START     I/O  position from which to commence/resume scanning.
     NTOKNS     O   number of scanned substrings.
     BEG        O   beginnings of scanned substrings.
     END        O   endings of scanned substrings.
     <a href="ident.html">IDENT</a>      O   position of scanned substring within array MARKS.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     STRING     is any character string that is to be scanned
                to locate recognized and unrecognized substrings.

     ROOM       is the amount of space available for storing the
                results of scanning the string.

     NMARKS     is the number of marks that will be
                recognized substrings of STRING.

     MARKS      is an array of marks that will be recognized
                by the scanning routine.  The array must be
                processed by a call to <a href="scanpr.html">SCANPR</a> before it can
                be used by <a href="scan.html">SCAN</a>.  Further details are given
                in documentation for the individual entry points.

     MRKLEN     is an auxiliary array populated by <a href="scanpr.html">SCANPR</a>
                for use by <a href="scan.html">SCAN</a>.  It should be declared with
                length equal to the length of MARKS.

     PNTERS     is an auxiliary array populated by <a href="scanpr.html">SCANPR</a> for
                use by <a href="scan.html">SCAN</a>.  It should be declared in the
                calling program as

                   INTEGER  PNTERS ( RCHARS )

                RCHARS is given by the expression

                  MAX - MIN + 5

                where

                MAX is the maximum value of ICHAR(MARKS(I)(1:1))
                    over the range I = 1, NMARKS

                MIN is the minimum value of ICHAR(MARKS(I)(1:1))
                    over the range I = 1, NMARKS

               Further details are provided in the entry point
               <a href="scanpr.html">SCANPR</a>.

     START     is the position in the STRING from which scanning
               should commence.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     NMARKS    is the number of marks in the array MARKS after it
               has been prepared for <a href="scanpr.html">SCANPR</a>.

     MARKS     is an array of recognizable substrings that has
               been prepared for <a href="scan.html">SCAN</a> by <a href="scanpr.html">SCANPR</a>.  Note that MARKS
               will be sorted in increasing order.

     MRKLEN    is an auxiliary array, populated by <a href="scanpr.html">SCANPR</a> for
               use by <a href="scan.html">SCAN</a>.

     PNTERS    is an auxiliary array, populated by a call to
               <a href="scanpr.html">SCANPR</a> and is intended for use by <a href="scan.html">SCAN</a>.

     START     is the position from which scanning should continue
               in order to fully scan STRING (if sufficient memory was
               not provided in BEG, END, and <a href="ident.html">IDENT</a> on the current
               call to <a href="scan.html">SCAN</a>).

     NTOKNS    is the number of substrings identified in the current
               scan of STRING.

     BEG       Beginnings of scanned substrings.
               This should be declared so that it is at least
               as large as ROOM.

     END       Endings of scanned substrings.
               This should be declared so that it is at least
               as large as ROOM.

     <a href="ident.html">IDENT</a>     Positions of scanned substring within array MARKS.
               If the substring STRING(BEG(I):END(I)) is not in the
               list of MARKS then <a href="ident.html">IDENT</a>(I) will have the value 0.
               This should be declared so that it is at least
               as large as ROOM.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1) If this routine is called directly the error
        'SPICE(BOGUSENTRY)' will be signalled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     This routine serves as an umbrella routine for the two entry
     points <a href="scanpr.html">SCANPR</a> and <a href="scan.html">SCAN</a>.  It can be used to locate keywords
     or delimited substrings within a string.

     The process of breaking a string into those substrings that
     have recognizable meaning, is called &quot;scanning.&quot;  The substrings
     identified by the scanning process are called &quot;tokens.&quot;

     Scanning has many applications including:

     -- the parsing of algebraic expressions

     -- parsing calendar dates

     -- processing text with embedded directions for displaying
        the text.

     -- interpretation of command languages

     -- compilation of programming languages

     This routine simplifies the process of scanning a string for
     its tokens.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     Example 1.
     ----------

     Suppose you need to identify all of the words within a string
     and wish to ignore punctuation marks such as ',', ':', ';', ' ',
     '---'.

     The first step is to load the array of marks as shown here:

        The minimum ASCII code for the first character of a marker is
        32 ( for ' ').

        INTEGER               FCHAR
        PARAMETER           ( FCHAR = 32 )

        The maximum ASCII code for the first character of a marker is
        59 (for ';' )

        INTEGER               LCHAR
        PARAMETER           ( LCHAR = 59 )

        INTEGER               RCHAR
        PARAMETER           ( RCHAR = LCHAR - FCHAR + 5 )

        LOGICAL               FIRST
        CHARACTER*(3)         MARKS
        INTEGER               NMARKS ( 5     )
        INTEGER               MRKLEN ( 5     )
        INTEGER               PNTERS ( RCHAR )

        INTEGER               ROOM
        PARAMETER           ( ROOM = 50 )

        INTEGER               BEG    ( ROOM  )
        INTEGER               END    ( ROOM  )
        INTEGER               <a href="ident.html">IDENT</a>  ( ROOM  )

        SAVE                  FIRST
        SAVE                  MARKS
        SAVE                  MRKLEN
        SAVE                  PNTERS

        IF ( FIRST ) THEN

           FIRST    = .FALSE.

           MARKS(1) = ' '
           MARKS(2) = '---'
           MARKS(3) = ':'
           MARKS(4) = ','
           MARKS(5) = ';'

           NMARKS   = 5

           CALL <a href="scanpr.html">SCANPR</a> ( NMARKS, MARKS, MRKLEN, PNTERS )

        END IF

     Notice that the call to <a href="scanpr.html">SCANPR</a> is nested inside an
     IF ( FIRST ) THEN ... END IF block.  In this and many applications
     the marks that will be used in the scan are fixed.  Since the
     marks are not changing, you need to process MARKS and set up
     the auxiliary arrays MRKLEN and PNTERS only once (assuming that
     you SAVE the appropriate variables as has been done above).
     In this way if the code is executed many times, there is only
     a small overhead required for preparing the data so that it
     can be used efficiently in scanning.

     To identify the substrings that represent words we scan the
     string using the prepared MARKS, MRKLEN and PNTERS.

        CALL <a href="scan.html">SCAN</a> ( STRING, MARKS,  MRKLEN, PNTERS, ROOM,
       .            START,  NTOKNS, <a href="ident.html">IDENT</a>,  BEG,    END   )

     To isolate only the words of the string, we examine the
     array <a href="ident.html">IDENT</a> and keep only those Begin and Ends for which
     the corresponding identity is non-positive.

        KEPT = 0

        DO I = 1, NTOKNS

           IF ( <a href="ident.html">IDENT</a>(I) .LE. 0 ) THEN

              KEPT      = KEPT + 1
              BEG(KEPT) = BEG(I)
              END(KEPT) = END(I)

           END IF

        END DO


     Example 2.
     ----------

     To parse an algebraic expression such as

        ( X + Y ) * ( 2*Z + SIN(W) ) ** 2

     You would select '**', '*', '+', '-', '(', ')' and ' '
     to be the markers.  Note that all of these begin with one
     of the characters in the string ' !&quot;#$%&amp;''()*+,-./'
     so that we can declare PNTERS to have length 20.

     Prepare the MARKS, MRKLEN, and PNTERS.

        LOGICAL               FIRST
        CHARACTER*(4)         MARKS
        INTEGER               NMARKS ( 8  )
        INTEGER               MRKLEN ( 8  )
        INTEGER               PNTERS ( 20 )

        SAVE                  FIRST
        SAVE                  MARKS
        SAVE                  MRKLEN
        SAVE                  PNTERS

        IF ( FIRST ) THEN

           MARKS(1) = '('
           MARKS(2) = ')'
           MARKS(3) = '+'
           MARKS(4) = '-'
           MARKS(5) = '*'
           MARKS(6) = '/'
           MARKS(7) = '**'
           MARKS(8) = ' '

           NMARKS   = 8

           CALL <a href="scanpr.html">SCANPR</a> ( NMARKS, MARKS, MRKLEN, PNTERS )

           Locate the blank character in MARKS once it has
           been prepared.

           BLANK = <a href="bsrchc.html">BSRCHC</a> ( ' ', NMARKS, MARKS )

        END IF


     Once all of the initializations are out of the way,
     we can scan an input string.

        CALL <a href="scan.html">SCAN</a> ( STRING, MARKS,  MRKLEN, PNTERS, ROOM,
       .            START,  NTOKNS, <a href="ident.html">IDENT</a>,  BEG,    END   )


     Next eliminate any white space that was returned in the
     list of tokens.

     KEPT = 0

     DO I = 1, NTOKNS

        IF ( <a href="ident.html">IDENT</a>(I) .NE. BLANK ) THEN
           KEPT        = KEPT + 1
           BEG  (KEPT) = BEG   (I)
           END  (KEPT) = END   (I)
           <a href="ident.html">IDENT</a>(KEPT) = <a href="ident.html">IDENT</a> (I)
        END IF

     END DO

     Now all of the substrings remaining point to grouping symbols,
     operators, functions, or variables.  Given that the individual
     &quot;words&quot; of the expression are now in hand, the meaning of the
     expression is much easier to determine.

     The rest of the routine is left as a non-trivial exercise
     for the reader.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     The array of MARKS, MRKLEN, and PNTERS must be properly formatted
     prior to calling <a href="scan.html">SCAN</a>.  This is accomplished by calling <a href="scanpr.html">SCANPR</a>.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     W.L. Taber     (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    Spicelib Version  1.0.0, 26-JUL-1996 (WLT)</PRE>
<h4>Link to routine SCANIT source file <a href='../../../src/spicelib/scanit.f'>scanit.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:53 2014</pre>

</body>
</html>

