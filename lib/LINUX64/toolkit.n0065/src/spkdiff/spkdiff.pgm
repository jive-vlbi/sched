C$Procedure   SPKDIFF ( Compare two SPK files. )
 
      PROGRAM SPKDIFF

C$ Abstract
C
C     SPKDIFF is a program that samples data from an SPK file or finds
C     differences between geometric states computed from two SPK files
C     and either displays these differences or shows statistics about
C     them.
C
C     For complete information about the program see SPKDIFF User's
C     Guide.
C  
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     SPKDIFF.UG
C
C$ Keywords
C
C     SPK
C
C$ Declarations

      IMPLICIT NONE

      INCLUDE              'errhnd.inc'
      INCLUDE              'spkdiff.inc'

C$ Brief_I/O
C
C     See User's Guide.
C
C$ Detailed_Input
C
C     See User's Guide.
C
C$ Detailed_Output
C
C     See User's Guide.
C
C$ Parameters
C
C     See include files in Declarations section.
C
C$ Exceptions
C
C     TBD.
C
C$ Files
C
C     See User's Guide.
C
C$ Particulars
C
C     See User's Guide.
C
C$ Examples
C
C     See User's Guide.
C
C$ Restrictions
C
C     See User's Guide.
C
C$ Literature_References
C
C     None.
C
C$ Author_and_Institution
C
C     B.V. Semenov   (JPL)
C
C$ Version
C
C-    Version 2.0.0, 25-MAR-2014 (BVS).
C
C        Updated for majors functionality additions (sampling, window
C        with gaps, etc).
C
C-    Version 1.0.0, 18-JUL-2006 (BVS).
C
C-&

C
C     SPICELIB functions.
C
      DOUBLE PRECISION      SPD

      INTEGER               CARDD
      INTEGER               RTRIM
      INTEGER               WNCARD

      LOGICAL               EQSTR

C
C     Local variables
C
      CHARACTER*(5*LINSIZ)  HLLINE
      CHARACTER*(LMSGLN)    ERROR
      CHARACTER*(LINSIZ)    GAPSTR
      CHARACTER*(LINSIZ)    INFMSG ( INFMAX )
      CHARACTER*(LINSIZ)    KERNLS ( 3 )
      CHARACTER*(LINSIZ)    LINE
      CHARACTER*(LINSIZ)    SPK    ( 2 )
      CHARACTER*(LINSIZ)    STPSTR
      CHARACTER*(LINSIZ)    TIME   ( 2 )
      CHARACTER*(LINSIZ)    TIMFMT
      CHARACTER*(WRDSIZ)    BODNAM ( 2 )
      CHARACTER*(WRDSIZ)    CENNAM ( 2 )
      CHARACTER*(WRDSIZ)    DIFTYP
      CHARACTER*(WRDSIZ)    FRAME  ( 2 )
      CHARACTER*(WRDSIZ)    HWORD

      DOUBLE PRECISION      CMPWIN ( LBCELL : WINSIZ )
      DOUBLE PRECISION      EPOCH  ( MAXITR )
      DOUBLE PRECISION      ET     ( 2 )
      DOUBLE PRECISION      HDP1
      DOUBLE PRECISION      HDP2
      DOUBLE PRECISION      HDP3
      DOUBLE PRECISION      HDP4
      DOUBLE PRECISION      STATE1 ( 6, MAXITR )
      DOUBLE PRECISION      STATE2 ( 6, MAXITR )
      DOUBLE PRECISION      STEP
      DOUBLE PRECISION      STEPSV
      DOUBLE PRECISION      WINMES

      INTEGER               BODID  ( 2 )
      INTEGER               CENID  ( 2 )
      INTEGER               COUNT
      INTEGER               ERRIDX
      INTEGER               I
      INTEGER               INFCNT
      INTEGER               J
      INTEGER               NITR
      INTEGER               NSGCNT
      INTEGER               SIGDIG
      INTEGER               SGTCNT
      INTEGER               DAY
      INTEGER               HOUR
      INTEGER               MINUTS
      INTEGER               SEC
      INTEGER               MSEC
      INTEGER               TRYCNT

      LOGICAL               DONE
      LOGICAL               EPONLY
      LOGICAL               INFPRT ( INFMAX )
      LOGICAL               OK
      LOGICAL               OVRFLW
      LOGICAL               SAMPLE

C
C     Save everything to prevent potential memory problems in f2c'ed
C     version.
C
      SAVE

C
C     Check in.
C
      CALL CHKIN ( PGMNAM )

C
C     Reset default error messages.
C
      CALL ERRPRT (  'SET', 'NONE, SHORT, LONG, TRACEBACK'  )

C
C     Initialize comparison window.
C
      CALL SSIZED ( WINSIZ, CMPWIN )

C
C     Get command line and call the "big kahuna" deal-with-command-line
C     routine to get back all needed setups.
C
      CALL GETCML ( LINE )
      CALL CHWCML ( LINE, SPK, BODNAM, BODID, CENNAM, CENID,  
     .              FRAME, CMPWIN, NITR, STEP, DIFTYP, TIMFMT, 
     .              KERNLS, SAMPLE, SIGDIG )

C
C     The fork for single/multiple intervals below is for backwards
C     compatibility with the version 1.0.0 of SPKDIFF that could work
C     only on continuous intervals.
C
      IF ( WNCARD(CMPWIN) .EQ. 1 .AND. .NOT. SAMPLE ) THEN
      
C
C        If our windows contains a single interval, calculate times 
C        for which we will compute states using the simple loop used
C        in the version 1.0.0.
C
         CALL WNFETD ( CMPWIN, 1, ET(1), ET(2) )

         DO J = 0, NITR-2
            EPOCH(J+1) = ET(1) + DBLE(J)*STEP
         END DO
      
         EPOCH(NITR) = ET(2)

         EPONLY = NITR .EQ. 2

      ELSE

C
C        For multi-interval windows we used the algorithm developed for
C        FRMDIFF. Note that parts of this algorithm must be consistent
C        with what's done to compute STEP or and/or NIRT in CHWCML.
C
C        Count how many singleton and non-singleton intervals the
C        comparison window contains and get the measure of the window.
C
         WINMES = 0.D0
         SGTCNT = 0
         NSGCNT = 0

         DO I = 1, CARDD( CMPWIN ), 2

            WINMES = WINMES + ( CMPWIN(I+1) - CMPWIN(I) )

            IF ( CMPWIN(I+1) .EQ. CMPWIN(I) ) THEN
               SGTCNT = SGTCNT + 1
            ELSE
               NSGCNT = NSGCNT + 1
            END IF

         END DO

C
C        We will make two attempts to come up with a step and
C        distribute points within the comparison window. In the first
C        attempt we will set step on a smaller side, allocating just
C        one extra point for each interval whether it is a singleton or
C        not. If that attempt will produce more points than can fit the
C        buffer, we will back off a bit and make step bigger by
C        allocating two extra points for each non-singleton interval.
C
         DONE   = .FALSE.
         TRYCNT = 1
         STEPSV = STEP

         DO WHILE ( .NOT. DONE )

C
C           Set buffer overflow flag to false.
C
            OVRFLW = .FALSE.

C
C           Determine time step if it was not given on the command
C           line.
C
            IF ( STEP .EQ. 0.D0 ) THEN

C
C              Check how the number of points for comparison returned
C              by CHWCML relates to these singleton/non-singleton
C              interval counts. Recall that for each singleton interval
C              the time array will contain one point while for each
C              non-singleton it will contain at least two points -- one
C              for each interval end. Note that because our coverage
C              window is declared to have the same size as the times
C              buffer the case with just end points cannot cause an
C              overflow.
C
               IF ( NITR .LE. ( SGTCNT + NSGCNT * 2 ) ) THEN

C
C                 The requested number of points for comparison is less
C                 or equal to the minimum number that we should have
C                 for the intervals in our comparison window. In this
C                 case, we set step to a value that won't produce any
C                 points within intervals. NITR will be reset to the
C                 minimum number later, in the loop that computes
C                 epochs.
C
                  STEP = MAX( 1.D0, WINMES + 1.D0 )

               ELSE

C
C                 The requested number of points for comparison is
C                 greater than the minimum number that we should have
C                 for the intervals in our comparison window. In this
C                 case, we have some points to distribute within
C                 non-singleton intervals and to do that we need to
C                 compute the step using which they should be
C                 distributed. In the first attempt we will set step on
C                 a smaller side, allocating just one extra point for
C                 each interval whether it is a singleton or not. On
C                 the second try we will back off a bit and make step
C                 bigger by allocating two extra points for each
C                 non-singleton interval. One of the two approaches
C                 should work.
C
                  IF      ( TRYCNT .EQ. 1 ) THEN

                     STEP = WINMES / ( NITR - ( SGTCNT + NSGCNT ) )

                  ELSE IF ( TRYCNT .EQ. 2 ) THEN

                     STEP = WINMES / ( NITR - ( SGTCNT + NSGCNT * 2 ) )

                  ELSE 

                     CALL SETMSG ( 'There is a bug in the program. ' //
     .                             'Please, contact NAIF.'           )
                     CALL SIGERR ( 'SPICE(SPKDIFFBUG3)'              )

                  END IF

               END IF

            END IF

C
C           Using step generate array of times at which attitudes will
C           be computed using the same algorithm as was used in CHWCML.
C           Note that if the step was given on the input, it should not
C           cause overflow of the epoch buffer (the input was verified
C           not to). But if the step was computed it could cause
C           overflow on the first try, so we will check for overflow as
C           we go.
C
            NITR = 0
            DO I = 1, WNCARD(CMPWIN)

C
C              Fetch endpoints of the next interval.
C
               CALL WNFETD ( CMPWIN, I, ET(1), ET(2) )

C
C              Add one step for start of the interval.
C
               IF ( NITR .LT. MAXITR ) THEN
                  NITR = NITR + 1
                  EPOCH( NITR ) = ET(1)
               ELSE
                  OVRFLW = .TRUE.
               END IF

C
C              Add one step for each point between endpoints up to the
C              end of the interval minus padding. Note that in the case
C              of overflow this loop will not execute as NITR will be 
C              equal to MAXITR.
C
               HDP2  = ET(2) - STEP * STPPAD

               COUNT = 1
               HDP1  = ET(1) + STEP * COUNT

               DO WHILE ( NITR .LT. MAXITR .AND. HDP1 .LT. HDP2 )

                  NITR  = NITR + 1
                  EPOCH( NITR ) = HDP1
               
                  COUNT = COUNT + 1 
                  HDP1  = ET(1) + STEP * COUNT

               END DO

C
C              If interval begin time is not equal to interval end time
C              add one step for the end of the interval.
C
               IF ( ET(1) .NE. ET(2) ) THEN

                  IF ( NITR .LT. MAXITR ) THEN
                     NITR = NITR + 1
                     EPOCH ( NITR ) = ET(2)
                  ELSE
                     OVRFLW = .TRUE.
                  END IF

               END IF

            END DO

C
C           If we did not overflow the buffer, we are done. Otherwise
C           restore step and do another try.
C
            IF ( .NOT. OVRFLW ) THEN
               DONE = .TRUE.
            ELSE
               TRYCNT = TRYCNT + 1
               STEP = STEPSV
            END IF   

         END DO

C
C        Set flag indicating that the number of steps is equal to the
C        number of end points.
C
         EPONLY = NITR .EQ. ( SGTCNT + NSGCNT * 2 )

      END IF

C
C     Generate and display the report header. First, prepare strings 
C     that will appear in all variations of headers.
C
C     Make string representing step. Step is included in the report as
C     the number of seconds and as DDDAYS:HR:MN:SC.MSECND.
C
      STPSTR = '# second (#)'
      CALL REPMF ( STPSTR, '#', STEP, 15, 'F', STPSTR )
      CALL DR2STR( STEP, HWORD )
      CALL REPMC ( STPSTR, '#', HWORD,         STPSTR )

C
C     Make strings representing start and stop times.
C
      CALL ETCAL ( CMPWIN(1),             TIME(1) )
      CALL ETCAL ( CMPWIN(CARDD(CMPWIN)), TIME(2) )

      CALL PREFIX( '''',                     0, TIME(1) )
      CALL PREFIX( '''',                     0, TIME(2) )

      CALL SUFFIX( ' TDB'' (# TDB seconds)', 0, TIME(1) )
      CALL SUFFIX( ' TDB'' (# TDB seconds)', 0, TIME(2) )

      CALL REPMF ( TIME(1), '#', CMPWIN(1),    15, 'F', TIME(1) )
      CALL REPMF ( TIME(2), '#', CMPWIN(CARDD(CMPWIN)),
     .                                         15, 'F', TIME(2) )

C
C     Make string indicating whether comparison window has gaps.
C
      IF ( WNCARD(CMPWIN) .EQ. 1 ) THEN
         GAPSTR = 'continuous'
      ELSE
         GAPSTR = 'non-continuous (with # gaps)'
         CALL REPMI ( GAPSTR, '#', WNCARD(CMPWIN)-1, GAPSTR )
      END IF

C
C     Tag all lines in the header buffers as printable. Those that
C     don't need to printed in certain circumstances will be reset to
C     FALSE later.
C
      DO I = 1, INFMAX
         INFPRT(I) = .TRUE.
      END DO

C
C     Fill in report header. We will have three different report header
C     formats: first for sampling case, second for comparison case when
C     we have a single interval, both SPKs, and no SPK-specific kernels
C     (for compatibility with version 1.0.0), and third for all other
C     comparison cases.
C
C
      IF ( SAMPLE ) THEN

C
C        Fill in the sampling report header for all sampling cases. Set
C        header template.
C
         INFMSG(  1 ) = '#'
         INFMSG(  2 ) = '# Sampling of $ ''$''-referenced geometric '
     .   //             'states'
         INFMSG(  3 ) = '#'
         INFMSG(  4 ) = '#    of ''$'' ($) relative to ''$'' ($)'
         INFMSG(  5 ) = '#    computed using'
         INFMSG(  6 ) = '#'
         INFMSG(  7 ) = '#       $'
         INFMSG(  8 ) = '#       $'
         INFMSG(  9 ) = '#       $'
         INFMSG( 10 ) = '#'
         INFMSG( 11 ) = '# with a $ step size'
         INFMSG( 12 ) = '# within the $ time period'
         INFMSG( 13 ) = '#'
         INFMSG( 14 ) = '#    from $'
         INFMSG( 15 ) = '#    to   $'
         INFMSG( 16 ) = '#'
         INFMSG( 17 ) = '# Times $.'
         INFMSG( 18 ) = '#'

         INFCNT = 18

C
C        Substitute values.
C
         CALL REPMI ( INFMSG(  2 ), '$', NITR,      INFMSG(  2 ) )
         CALL REPMC ( INFMSG(  2 ), '$', FRAME(1),  INFMSG(  2 ) )

         CALL REPMC ( INFMSG(  4 ), '$', BODNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', BODID(1),  INFMSG(  4 ) )
         CALL REPMC ( INFMSG(  4 ), '$', CENNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', CENID(1),  INFMSG(  4 ) )

         IF ( KERNLS(3) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  7 ), '$', KERNLS(3), INFMSG(  7 ) )
         ELSE
            INFPRT( 7 ) = .FALSE.
         END IF

         IF ( KERNLS(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  8 ), '$', KERNLS(1), INFMSG(  8 ) )
         ELSE
            INFPRT( 8 ) = .FALSE.
         END IF

         IF      ( SPK(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', SPK(1), INFMSG(  9 ) )
         ELSE IF ( SPK(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', SPK(2), INFMSG(  9 ) )
         ELSE
            INFPRT( 9 ) = .FALSE.
         END IF

         CALL REPMC ( INFMSG( 11 ), '$', STPSTR,  INFMSG( 11 ) )

         CALL REPMC ( INFMSG( 12 ), '$', GAPSTR,  INFMSG( 12 ) )

         CALL REPMC ( INFMSG( 14 ), '$', TIME(1), INFMSG( 14 ) )

         CALL REPMC ( INFMSG( 15 ), '$', TIME(2), INFMSG( 15 ) )

C
C        For coverage reports, change some wording.
C
         IF ( EQSTR( DIFTYP, DCVAL ) .OR.
     .        EQSTR( DIFTYP, DGVAL )      ) THEN

            INFMSG(  2 ) = '# Coverage for ''$''-referenced geometric '
     .   //                'states'
            CALL REPMC ( INFMSG(  2 ), '$', FRAME(1),  INFMSG(  2 ) )

         END IF

C
C        For runs checking only endpoints, replace step line.
C
         IF ( EPONLY ) THEN
            INFMSG( 11 ) = '# at continuous coverage intervals'' ' //
     .                     'endpoints'
         END IF

C
C        Finally, fill in time type for dump and coverage reports.
C
         IF ( EQSTR( DIFTYP, BSCVAL ) .OR.
     .        EQSTR( DIFTYP, STSVAL )      ) THEN

            INFCNT = 16

         ELSE

            IF ( TIMFMT .EQ. ' ' ) THEN

               CALL REPMC ( INFMSG( 17 ), '$', 
     .              'are TDB seconds past J2000',  
     .              INFMSG( 17 ) )
   
            ELSE
               
               CALL REPMC ( INFMSG( 17 ), '$', 
     .              'were generated by TIMOUT using ''$'' format',
     .              INFMSG( 17 ) )
               CALL REPMC ( INFMSG( 17 ), '$', TIMFMT, INFMSG( 17 ) )
            
            END IF

         END IF

C
C        Done filling out sampling report header.
C


      ELSE IF ( WNCARD(CMPWIN) .EQ. 1            .AND.  
     .          SPK(1)         .NE. ' '          .AND. 
     .          SPK(2)         .NE. ' '          .AND. 
     .          KERNLS(1)      .EQ. ' '          .AND.     
     .          KERNLS(2)      .EQ. ' '          .AND.      
     .          ( .NOT. EQSTR( DIFTYP, DCVAL ) ) .AND.
     .          ( .NOT. EQSTR( DIFTYP, DGVAL ) )        ) THEN

C
C        Fill in the comparison report header for comparison case when
C        we have a single interval, both SPKs, and no SPK-specific
C        kernels (for compatibility with version 1.0.0). Set header
C        template.
C
         INFMSG(  1 ) = '# '
         INFMSG(  2 ) = '# Comparison of $ ''$''-referenced geometric '
     .   //             'states'
         INFMSG(  3 ) = '# '
         INFMSG(  4 ) = '#    of ''$'' ($) relative to ''$'' ($)'
         INFMSG(  5 ) = '#    from SPK ''$'''
         INFMSG(  6 ) = '# '
         INFMSG(  7 ) = '# with $ ''$''-referenced geometric state'
     .   //             's'
         INFMSG(  8 ) = '# '
         INFMSG(  9 ) = '#    of ''$'' ($) relative to ''$'' ($)'
         INFMSG( 10 ) = '#    from SPK ''$'''
         INFMSG( 11 ) = '# '
         INFMSG( 12 ) = '# evenly-spaced with $ second ($) step size'
         INFMSG( 13 ) = '# within the time interval'
         INFMSG( 14 ) = '# '
         INFMSG( 15 ) = '#    from $'
         INFMSG( 16 ) = '#    to   $'
         INFMSG( 17 ) = '# '
         INFMSG( 18 ) = '# using additional data from these kernels'
         INFMSG( 19 ) = '# '
         INFMSG( 20 ) = '#    ''$'''
         INFMSG( 21 ) = '# '

C
C        Substitute values.
C
         CALL REPMI ( INFMSG(  2 ), '$', NITR,      INFMSG(  2 ) )
         CALL REPMC ( INFMSG(  2 ), '$', FRAME(1),  INFMSG(  2 ) )

         CALL REPMC ( INFMSG(  4 ), '$', BODNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', BODID(1),  INFMSG(  4 ) )
         CALL REPMC ( INFMSG(  4 ), '$', CENNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', CENID(1),  INFMSG(  4 ) )

         CALL REPMC ( INFMSG(  5 ), '$', SPK(1),    INFMSG(  5 ) )

         CALL REPMI ( INFMSG(  7 ), '$', NITR,      INFMSG(  7 ) )
         CALL REPMC ( INFMSG(  7 ), '$', FRAME(2),  INFMSG(  7 ) )

         CALL REPMC ( INFMSG(  9 ), '$', BODNAM(2), INFMSG(  9 ) )
         CALL REPMI ( INFMSG(  9 ), '$', BODID(2),  INFMSG(  9 ) )
         CALL REPMC ( INFMSG(  9 ), '$', CENNAM(2), INFMSG(  9 ) )
         CALL REPMI ( INFMSG(  9 ), '$', CENID(2),  INFMSG(  9 ) )

         CALL REPMC ( INFMSG( 10 ), '$', SPK(2),    INFMSG( 10 ) )

C
C        For backward compatibility with version 1.0.0 this in-line
C        step formatting is used instead of the STPSTR prepared earlier.
C
C        Step in included into the report as the number of seconds and
C        as #d #h #m #.######s (for more clarity.)
C     
         CALL REPMF ( INFMSG( 12 ), '$', STEP, 15, 'F',  INFMSG( 12 ) )

         CALL RMAIND( STEP,   SPD(), HDP1, HDP2 )
         DAY    = HDP1
         CALL RMAIND( HDP2, 3600.D0, HDP1, HDP3 )
         HOUR   = HDP1
         CALL RMAIND( HDP3,   60.D0, HDP1, HDP4 )
         MINUTS = HDP1
         CALL RMAIND( HDP4,    1.D0, HDP1, HDP2 )
         SEC    = HDP1

         MSEC = NINT( HDP2 * 1000000.D0 )
         IF ( MSEC .EQ. 1000000 ) THEN
            MSEC = 999999
         END IF
         CALL INTSTR( MSEC, HWORD )
         DO WHILE ( RTRIM(HWORD) .LT. 6 )
            CALL PREFIX( '0', 0, HWORD )
         END DO

         LINE   = '#d #h #m #.#s'
         CALL REPMI ( LINE, '#', DAY,    LINE )
         CALL REPMI ( LINE, '#', HOUR,   LINE )
         CALL REPMI ( LINE, '#', MINUTS, LINE )
         CALL REPMI ( LINE, '#', SEC,    LINE )
         CALL REPMC ( LINE, '#', HWORD,  LINE )

         CALL REPMC ( INFMSG( 12 ), '$', LINE,  INFMSG( 12 ) )

         CALL REPMC ( INFMSG( 12 ), '$', STPSTR,    INFMSG( 12 ) )

         CALL REPMC ( INFMSG( 15 ), '$', TIME(1),   INFMSG( 15 ) )

         CALL REPMC ( INFMSG( 16 ), '$', TIME(2),   INFMSG( 16 ) )

C
C        If no additional kernels were provided, don't report them.
C
         IF ( KERNLS(3) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG( 20 ), '$', KERNLS(3), INFMSG( 20 ) )
            INFCNT = 21
         ELSE
            INFCNT = 17
         END IF

C
C        Done filling out version 1.0.0 compatibility comparison report
C        header.
C


      ELSE

C
C        Fill in the comparison report header for all other comparison
C        cases. Set header template.
C
         INFMSG(  1 ) = '#'
         INFMSG(  2 ) = '# Comparison of $ ''$''-referenced geometric '
     .   //             'states'
         INFMSG(  3 ) = '#'
         INFMSG(  4 ) = '#    of ''$'' ($) relative to ''$'' ($)'
         INFMSG(  5 ) = '#    computed using'
         INFMSG(  6 ) = '#'
         INFMSG(  7 ) = '#       $'
         INFMSG(  8 ) = '#       $'
         INFMSG(  9 ) = '#       $'
         INFMSG( 10 ) = '#'
         INFMSG( 11 ) = '# with $ ''$''-referenced geometric state'
     .   //             's'
         INFMSG( 12 ) = '#'
         INFMSG( 13 ) = '#    of ''$'' ($) relative to ''$'' ($)'
         INFMSG( 14 ) = '#    computed using'
         INFMSG( 15 ) = '#'
         INFMSG( 16 ) = '#       $'
         INFMSG( 17 ) = '#       $'
         INFMSG( 18 ) = '#       $'
         INFMSG( 19 ) = '#'
         INFMSG( 20 ) = '# with a $ step size'
         INFMSG( 21 ) = '# within the $ time period'
         INFMSG( 22 ) = '#'
         INFMSG( 23 ) = '#    from $'
         INFMSG( 24 ) = '#    to   $'
         INFMSG( 25 ) = '#'
         INFMSG( 26 ) = '# Times $.'
         INFMSG( 27 ) = '#'

         INFCNT = 27

C
C        Substitute values.
C
         CALL REPMI ( INFMSG(  2 ), '$', NITR,      INFMSG(  2 ) )
         CALL REPMC ( INFMSG(  2 ), '$', FRAME(1),  INFMSG(  2 ) )

         CALL REPMC ( INFMSG(  4 ), '$', BODNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', BODID(1),  INFMSG(  4 ) )
         CALL REPMC ( INFMSG(  4 ), '$', CENNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', CENID(1),  INFMSG(  4 ) )

         IF ( KERNLS(3) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  7 ), '$', KERNLS(3), INFMSG(  7 ) )
         ELSE
            INFPRT( 7 ) = .FALSE.
         END IF

         IF ( KERNLS(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  8 ), '$', KERNLS(1), INFMSG(  8 ) )
         ELSE
            INFPRT( 8 ) = .FALSE.
         END IF

         IF      ( SPK(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', SPK(1), INFMSG(  9 ) )
         ELSE IF ( SPK(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', SPK(2), INFMSG(  9 ) )
         ELSE
            INFPRT( 9 ) = .FALSE.
         END IF

         CALL REPMI ( INFMSG( 11 ), '$', NITR,      INFMSG( 11 ) )
         CALL REPMC ( INFMSG( 11 ), '$', FRAME(2),  INFMSG( 11 ) )

         CALL REPMC ( INFMSG( 13 ), '$', BODNAM(2), INFMSG( 13 ) )
         CALL REPMI ( INFMSG( 13 ), '$', BODID(2),  INFMSG( 13 ) )
         CALL REPMC ( INFMSG( 13 ), '$', CENNAM(2), INFMSG( 13 ) )
         CALL REPMI ( INFMSG( 13 ), '$', CENID(2),  INFMSG( 13 ) )

         IF ( KERNLS(3) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG( 16 ), '$', KERNLS(3), INFMSG( 16 ) )
         ELSE
            INFPRT( 16 ) = .FALSE.
         END IF

         IF ( KERNLS(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG( 17 ), '$', KERNLS(2), INFMSG( 17 ) )
         ELSE
            INFPRT( 17 ) = .FALSE.
         END IF

         IF      ( SPK(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG( 18 ), '$', SPK(2), INFMSG( 18 ) )
         ELSE
            INFPRT( 18 ) = .FALSE.
         END IF

         CALL REPMC ( INFMSG( 20 ), '$', STPSTR,  INFMSG( 20 ) )

         CALL REPMC ( INFMSG( 21 ), '$', GAPSTR,  INFMSG( 21 ) )

         CALL REPMC ( INFMSG( 23 ), '$', TIME(1), INFMSG( 23 ) )

         CALL REPMC ( INFMSG( 24 ), '$', TIME(2), INFMSG( 24 ) )

C
C        For coverage reports, change some wording.
C
         IF ( EQSTR( DIFTYP, DCVAL ) .OR.
     .        EQSTR( DIFTYP, DGVAL )      ) THEN

            INFMSG(  2 ) = '# Coverage overlap for ''$''-referenced '
     .   //                'geometric states'
            CALL REPMC ( INFMSG(  2 ), '$', FRAME(1),  INFMSG(  2 ) )

            INFMSG( 11 ) = '# and ''$''-referenced '
     .   //                'geometric states'
            CALL REPMC ( INFMSG( 11 ), '$', FRAME(2),  INFMSG( 11 ) )

         END IF

C
C        For runs checking only endpoints, replace step line.
C
         IF ( EPONLY ) THEN
            INFMSG( 20 ) = '# at continuous coverage intervals'' ' //
     .                     'endpoints'
         END IF

C
C        Finally, fill in time type for dump and coverage reports
C
         IF ( EQSTR( DIFTYP, BSCVAL ) .OR.
     .        EQSTR( DIFTYP, STSVAL )      ) THEN

            INFCNT = 25

         ELSE

            IF ( TIMFMT .EQ. ' ' ) THEN

               CALL REPMC ( INFMSG( 26 ), '$', 
     .              'are TDB seconds past J2000',  
     .              INFMSG( 26 ) )
   
            ELSE
               
               CALL REPMC ( INFMSG( 26 ), '$', 
     .              'were generated by TIMOUT using ''$'' format',
     .              INFMSG( 26 ) )
               CALL REPMC ( INFMSG( 26 ), '$', TIMFMT, INFMSG( 26 ) )
            
            END IF

         END IF

C
C        Done filling out other compatibility comparison report header.
C

      END IF

C
C     Display report header.
C
      DO I = 1, INFCNT
         IF ( INFPRT(I) ) THEN
            CALL TOSTDO ( INFMSG(I) )
         END IF
      END DO

C
C     With the first and second trajectory set attributes and epochs in
C     hand we can now compute the trajectory sets. How we do this
C     depends on how many SPKs were provided on the command line. We
C     also set states in the second set to zero which they have to be
C     for sampling runs; for comparison runs they fill in as needed.
C
      CALL CLEARD ( NITR*6, STATE2 )

      IF      ( SPK(1) .NE. ' ' .AND.
     .          SPK(2) .NE. ' '       ) THEN

C
C        Two SPKs were provided on the command line.
C
C        Compute the first trajectory set.
C
C        Unload everything; load additional kernels for first
C        trajectory; check that first trajectory cannot be computed
C        without the first SPK at all epochs; load the first SPK;
C        compute and buffer trajectory for all epochs.
C
         CALL KCLEAR

         HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
         CALL LDKLST( HLLINE )

         CALL GETSTA ( .TRUE., BODID(1), CENID(1), FRAME(1), 
     .                 EPOCH, NITR, STATE1, OK, ERROR, ERRIDX )

         IF ( .NOT. OK ) THEN
            CALL ETCAL  ( EPOCH(ERRIDX), LINE )
            CALL SETMSG ( 'Oops ... It looks like we can compute '//
     .                    'geometric state of # with respect to ' //
     .                    '# in ''#'' frame at ''# TDB'' (ET #), '//
     .                    'even without loading the first SPK '   //
     .                    'file ''#''. It means that '            //
     .                    'supporting kernel(s) ''#'' already '   //
     .                    'contain data for this '                //
     .                    'center/body pair.'                     )
            CALL ERRINT ( '#', BODID(1)                           )
            CALL ERRINT ( '#', CENID(1)                           ) 
            CALL ERRCH  ( '#', FRAME(1)                           )
            CALL ERRCH  ( '#', LINE                               )
            CALL ERRDP  ( '#', EPOCH(ERRIDX)                      )
            CALL ERRCH  ( '#', SPK(1)                             )
            CALL ERRCH  ( '#', HLLINE                             )
            CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN1)'                )
         END IF

         CALL LDKLST( SPK(1) )

         CALL GETSTA ( .FALSE., BODID(1), CENID(1), FRAME(1), 
     .                 EPOCH, NITR, STATE1, OK, ERROR, ERRIDX )

         IF ( .NOT. OK ) THEN

            IF ( SAMPLE ) THEN
               CALL SETMSG ( 'The trajectory that is being '      // 
     .                       'sampled must be computable '        //
     .                       'using the SPK ''#'' and '           //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
            ELSE
               CALL SETMSG ( 'The first trajectory to be compared '//
     .                       'must be computable using the SPK '   //
     .                       '''#'' and supporting kernels ''#'' ' //
     .                       'provided after the keys ''#'' and '  //
     .                       '''#''. #'                           )
            END IF
            CALL ERRCH  ( '#', SPK(1)                          )
            CALL ERRCH  ( '#', HLLINE                          )
            CALL ERRCH  ( '#', KERKEY                          )
            CALL ERRCH  ( '#', KE1KEY                          )
            CALL ERRCH  ( '#', ERROR                           )
            CALL SIGERR ( 'SPICE(NOTENOUGHDATA1)'              )       
           
         END IF

C
C        Compute the second trajectory set needed for comparison runs.
C
         IF ( .NOT. SAMPLE ) THEN

C
C           Compute second trajectory set in the same fashion as the
C           first one.
C
C           Unload everything; load additional kernels for second
C           trajectory; check that second trajectory cannot be computed
C           without the second SPK at all epochs; load the second SPK
C           file; compute and buffer trajectory for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(2)
            CALL LDKLST( HLLINE )

            CALL GETSTA ( .TRUE., BODID(2), CENID(2), FRAME(2), 
     .                    EPOCH, NITR, STATE2, OK, ERROR, ERRIDX )

            IF ( .NOT. OK ) THEN
               CALL ETCAL  ( EPOCH(ERRIDX), LINE )
               CALL SETMSG ( 'Oops ... It looks like we can compute '//
     .                       'geometric state of # with respect to ' //
     .                       '# in ''#'' frame at ''# TDB'' (ET #), '//
     .                       'even without loading the second SPK '  //
     .                       'file ''#''. It means that '            //
     .                       'supporting kernel(s) ''#'' already '   //
     .                       'contain data for this '                //
     .                       'center/body pair.'                     )
               CALL ERRINT ( '#', BODID(2)                           )
               CALL ERRINT ( '#', CENID(2)                           ) 
               CALL ERRCH  ( '#', FRAME(2)                           )
               CALL ERRCH  ( '#', LINE                               )
               CALL ERRDP  ( '#', EPOCH(ERRIDX)                      )
               CALL ERRCH  ( '#', SPK(2)                             )
               CALL ERRCH  ( '#', HLLINE                             )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN2)'                )
            END IF

            CALL LDKLST( SPK(2) )

            CALL GETSTA ( .FALSE., BODID(2), CENID(2), FRAME(2), 
     .                    EPOCH, NITR, STATE2, OK, ERROR, ERRIDX )

            IF ( .NOT. OK ) THEN

               CALL SETMSG ( 'The second trajectory to be '       //
     .                       'compared must be computable '       //
     .                       'using the SPK ''#'' and '           //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
               CALL ERRCH  ( '#', SPK(2)                          )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA2)'              )
           
            END IF

         END IF

      ELSE IF ( SPK(2) .NE. ' '       ) THEN

C
C        Only one SPK was provided on the command line. 
C
C        Compute the first trajectory set.
C
C        Unload everything; load additional kernels for first
C        trajectory; check that first trajectory cannot be computed
C        without the SPK at all epochs; load the SPK; compute and
C        buffer trajectory for all epochs.
C
         CALL KCLEAR

         HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
         CALL LDKLST( HLLINE )

         CALL GETSTA ( .TRUE., BODID(1), CENID(1), FRAME(1), 
     .                 EPOCH, NITR, STATE1, OK, ERROR, ERRIDX )

         IF ( .NOT. OK ) THEN
            CALL ETCAL  ( EPOCH(ERRIDX), LINE )
            CALL SETMSG ( 'Oops ... It looks like we can compute '//
     .                    'geometric state of # with respect to ' //
     .                    '# in ''#'' frame at ''# TDB'' (ET #), '//
     .                    'even without loading the SPK '         //
     .                    'file ''#''. It means that '            //
     .                    'supporting kernel(s) ''#'' already '   //
     .                    'contain data for this '                //
     .                    'center/body pair.'                     )
            CALL ERRINT ( '#', BODID(1)                           )
            CALL ERRINT ( '#', CENID(1)                           ) 
            CALL ERRCH  ( '#', FRAME(1)                           )
            CALL ERRCH  ( '#', LINE                               )
            CALL ERRDP  ( '#', EPOCH(ERRIDX)                      )
            CALL ERRCH  ( '#', SPK(2)                             )
            CALL ERRCH  ( '#', HLLINE                             )
            CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN3)'                )
         END IF

         CALL LDKLST( SPK(2) )

         CALL GETSTA ( .FALSE., BODID(1), CENID(1), FRAME(1), 
     .                 EPOCH, NITR, STATE1, OK, ERROR, ERRIDX )

         IF ( .NOT. OK ) THEN

            IF ( SAMPLE ) THEN
               CALL SETMSG ( 'The trajectory that is being '      // 
     .                       'sampled must be computable '        //
     .                       'using the SPK ''#'' and '           //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
            ELSE
               CALL SETMSG ( 'The first trajectory to be compared '//
     .                       'must be computable using the SPK '   //
     .                       '''#'' and supporting kernels ''#'' ' //
     .                       'provided after the keys ''#'' and '  //
     .                       '''#''. #'                           )
            END IF
            CALL ERRCH  ( '#', SPK(2)                          )
            CALL ERRCH  ( '#', HLLINE                          )
            CALL ERRCH  ( '#', KERKEY                          )
            CALL ERRCH  ( '#', KE1KEY                          )
            CALL ERRCH  ( '#', ERROR                           )
            CALL SIGERR ( 'SPICE(NOTENOUGHDATA3)'              )
                      
         END IF

C
C        Compute the second trajectory set needed for comparison runs.
C
         IF ( .NOT. SAMPLE ) THEN

C
C           Compute second trajectory set in the same fashion as the
C           first one.
C
C           Unload everything; load additional kernels for second
C           trajectory; check that second trajectory cannot be computed
C           without the SPK at all epochs; load the SPK; compute and
C           buffer trajectory for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(2)
            CALL LDKLST( HLLINE )

            CALL GETSTA ( .TRUE., BODID(2), CENID(2), FRAME(2), 
     .                    EPOCH, NITR, STATE2, OK, ERROR, ERRIDX )

            IF ( .NOT. OK ) THEN
               CALL ETCAL  ( EPOCH(ERRIDX), LINE )
               CALL SETMSG ( 'Oops ... It looks like we can compute '//
     .                       'geometric state of # with respect to ' //
     .                       '# in ''#'' frame at ''# TDB'' (ET #), '//
     .                       'even without loading the SPK '         //
     .                       'file ''#''. It means that '            //
     .                       'supporting kernel(s) ''#'' already '   //
     .                       'contain data for this '                //
     .                       'center/body pair.'                     )
               CALL ERRINT ( '#', BODID(2)                           )
               CALL ERRINT ( '#', CENID(2)                           ) 
               CALL ERRCH  ( '#', FRAME(2)                           )
               CALL ERRCH  ( '#', LINE                               )
               CALL ERRDP  ( '#', EPOCH(ERRIDX)                      )
               CALL ERRCH  ( '#', SPK(2)                             )
               CALL ERRCH  ( '#', HLLINE                             )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN4)'                )
            END IF

            CALL LDKLST( SPK(2) )

            CALL GETSTA ( .FALSE., BODID(2), CENID(2), FRAME(2), 
     .                    EPOCH, NITR, STATE2, OK, ERROR, ERRIDX )

            IF ( .NOT. OK ) THEN

               CALL SETMSG ( 'The second trajectory to be '       //
     .                       'compared must be computable '       //
     .                       'using the SPK ''#'' and '           //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
               CALL ERRCH  ( '#', SPK(2)                          )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA4)'              )
           
            END IF

         END IF

      ELSE

C
C        No kernels were provided on the command line. Compute the
C        first trajectory set.
C
C        Unload everything; load additional kernels for first
C        trajectory; compute and buffer trajectory for all epochs.
C
         CALL KCLEAR

         HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
         CALL LDKLST( HLLINE )

         CALL GETSTA ( .FALSE., BODID(1), CENID(1), FRAME(1), 
     .                 EPOCH, NITR, STATE1, OK, ERROR, ERRIDX )

         IF ( .NOT. OK ) THEN

            IF ( SAMPLE ) THEN
               CALL SETMSG ( 'The trajectory that is being '       // 
     .                       'sampled must be computable '         //
     .                       'using the supporting kernels ''#'' ' //
     .                       'provided after the keys ''#'' and '  //
     .                       '''#''. #'                            )
            ELSE
               CALL SETMSG ( 'The first trajectory to be compared '//
     .                       'must be computable using the '       //
     .                       'supporting kernels ''#'' '           //
     .                       'provided after the keys ''#'' and  ' //
     .                       '''#''. #'                            )
            END IF
            CALL ERRCH  ( '#', HLLINE                          )
            CALL ERRCH  ( '#', KERKEY                          )
            CALL ERRCH  ( '#', KE1KEY                          )
            CALL ERRCH  ( '#', ERROR                           )
            CALL SIGERR ( 'SPICE(NOTENOUGHDATA5)'              )
           
         END IF

C
C        Compute the second trajectory set needed for comparison runs.
C
         IF ( .NOT. SAMPLE ) THEN

C
C           Compute second trajectory set in the same fashion as the
C           first one.
C
C           Unload everything; load additional kernels for second
C           trajectory; compute and buffer trajectory for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(2)
            CALL LDKLST( HLLINE )

            CALL GETSTA ( .FALSE., BODID(2), CENID(2), FRAME(2), 
     .                    EPOCH, NITR, STATE2, OK, ERROR, ERRIDX )

            IF ( .NOT. OK ) THEN

               CALL SETMSG ( 'The second trajectory to be '       //
     .                       'compared must be computable '       //
     .                       'using the supporting kernels '      //
     .                       '''#'' '                             //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA6)'              )
           
            END IF

         END IF

      END IF

C
C     Load kernels that may be needed for time conversions in the
C     routine that does the rest of display.
C
      HLLINE = KERNLS(3)(:RTRIM(KERNLS(3))) // ' ' // 
     .         KERNLS(2)(:RTRIM(KERNLS(2))) // ' ' // 
     .         KERNLS(1)

      CALL KCLEAR
      CALL LDKLST( HLLINE )

C
C     Pass state tables to the routine that will do analysis of the
C     differences and will print them to the screen.
C
      CALL STDIFF ( STATE1, STATE2, CMPWIN, NITR, EPOCH, DIFTYP, TIMFMT,
     .              SAMPLE, SIGDIG )

C
C     Check out.
C
      CALL CHKOUT( PGMNAM )

C
C     We are done. :-)
C
      END
