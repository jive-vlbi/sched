C$Procedure   FRMDIFF ( Compare two rotations. )

      PROGRAM FRMDIFF

C$ Abstract
C
C     FRMDIFF is a program that samples orientation of a reference
C     frame known to SPICE or computes differences between orientations
C     of two reference frames known to SPICE, and either displays this
C     orientation or these differences, or shows statistics about it or
C     them.
C
C     For complete information about the program see FRMDIFF User's
C     Guide.
C
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     FRMDIFF.UG
C
C$ Keywords
C
C     FRAMES
C     CK
C     ROTATIONS
C
C$ Declarations

      IMPLICIT NONE

      INCLUDE              'frmdiff.inc'
      INCLUDE              'ninert.inc'
      INCLUDE              'errhnd.inc'

C$ Brief_I/O
C
C     See User's Guide.
C
C$ Detailed_Input
C
C     See User's Guide.
C
C$ Detailed_Output
C
C     See User's Guide.
C
C$ Parameters
C
C     See include files in Declarations section.
C
C$ Exceptions
C
C     TBD.
C
C$ Files
C
C     See User's Guide.
C
C$ Particulars
C
C     See User's Guide.
C
C$ Examples
C
C     See User's Guide.
C
C$ Restrictions
C
C     See User's Guide.
C
C$ Literature_References
C
C     None.
C
C$ Author_and_Institution
C
C     B.V. Semenov   (JPL)
C
C$ Version
C
C-    Version 2.1.0, 25-MAR-2014 (BVS).
C
C        BUG FIX: added exception for non-rotation cases in GETQAV.
C
C        Included 'errhnd.inc' and used LMSGLN to declare ERROR.
C
C-    Version 2.0.0, 27-FEB-2012 (BVS).
C
C        Updated to support a new command line option for specifying
C        the number of significant digits in dump outputs.
C
C        Updated to fetch coverage from non-primary kernels when 
C        no primary kernels were specified.
C
C        BUG FIX: updated to load SCLK kernel before calling RTDIFF for
C        runs when it is the only primary kernel given on the command
C        line.
C
C-    Version 1.1.0, 28-OCT-2011 (BVS).
C
C        Moved PARCML to support.
C
C-    Version 1.0.0, 10-FEB-2009 (BVS).
C
C-&

C
C     Local variables
C
      CHARACTER*(5*LINSIZ)  HLLINE
      CHARACTER*(LINSIZ)    INFMSG ( INFMAX )
      CHARACTER*(LINSIZ)    KERNLS ( 3 )
      CHARACTER*(LINSIZ)    LINE
      CHARACTER*(LINSIZ)    STPSTR
      CHARACTER*(LINSIZ)    GAPSTR
      CHARACTER*(LINSIZ)    AVSTR
      CHARACTER*(LINSIZ)    KERNAM ( 2 )
      CHARACTER*(LINSIZ)    TIME   ( 2 )
      CHARACTER*(LINSIZ)    TIMFMT
      CHARACTER*(LMSGLN)    ERROR
      CHARACTER*(WRDSIZ)    FFRNAM ( 2 )
      CHARACTER*(WRDSIZ)    TFRNAM ( 2 )
      CHARACTER*(WRDSIZ)    DIFTYP
      CHARACTER*(WRDSIZ)    HWORD
      CHARACTER*(WRDSIZ)    AUNITS

      DOUBLE PRECISION      CMPWIN ( LBCELL : WINSIZ )
      DOUBLE PRECISION      EPOCH  (    MAXITR )
      DOUBLE PRECISION      ET     ( 2 )
      DOUBLE PRECISION      Q1     ( 4, MAXITR )
      DOUBLE PRECISION      Q2     ( 4, MAXITR )
      DOUBLE PRECISION      AV1    ( 3, MAXITR )
      DOUBLE PRECISION      AV2    ( 3, MAXITR )
      DOUBLE PRECISION      STEP
      DOUBLE PRECISION      HDP1
      DOUBLE PRECISION      HDP2
      DOUBLE PRECISION      WINMES

      INTEGER               FFRID  ( 2 )
      INTEGER               TFRID  ( 2 )
      INTEGER               I
      INTEGER               NITR
      INTEGER               SCLKID ( 2 )
      INTEGER               AXES   ( 3 )
      INTEGER               FRMID1
      INTEGER               FRMID2
      INTEGER               INFCNT
      INTEGER               MYSCID
      INTEGER               COUNT
      INTEGER               TLIDX

      INTEGER               SGTCNT
      INTEGER               NSGCNT

      INTEGER               SIGDIG

      LOGICAL               INFPRT ( INFMAX )
      LOGICAL               AVFLG
      LOGICAL               AVFFLG
      LOGICAL               OK
      LOGICAL               SAMPLE
      LOGICAL               ISINRT
      LOGICAL               EPONLY

C
C     SPICELIB functions.
C
      INTEGER               CARDD
      INTEGER               RTRIM
      INTEGER               WNCARD
      LOGICAL               EQSTR

C
C     Save everything to prevent potential memory problems in f2c'ed
C     version.
C
      SAVE

C
C     In-line function definitions.
C
      ISINRT ( FRMID2, FRMID1 ) =       FRMID1 .GT. 0
     .                            .AND. FRMID1 .LE. NINERT
     .                            .AND. FRMID2 .GT. 0
     .                            .AND. FRMID2 .LE. NINERT

C
C     Check in.
C
      CALL CHKIN ( PGMNAM )

C
C     Reset default error messages.
C
      CALL ERRPRT (  'SET', 'NONE, SHORT, LONG, TRACEBACK'  )

C
C     Initialize comparison window.
C
      CALL SSIZED ( WINSIZ, CMPWIN )

C
C     Get command line and call the "big kahuna" deal-with-command-line
C     routine to get back all needed setups.
C
      CALL GETCML ( LINE )
      CALL CHWCML ( LINE, KERNAM, FFRNAM, FFRID, TFRNAM, TFRID,
     .              AVFLG, AVFFLG, CMPWIN, NITR, STEP, DIFTYP, TIMFMT,
     .              KERNLS, SCLKID, AXES, AUNITS, SIGDIG )

C
C     Set flag indicating whether we are running in comparison mode or
C     in sampling mode. When two files were provided, we will do
C     sampling if ``from'' frames are the same, ``to'' frames are the
C     same, file-specific kernels are the same, and files are the same.
C     When one of no files were provided, we will do sampling if
C     ``from'' frames are the same, ``to'' frames are the same, and
C     file-specific kernels are the same.
C
      IF ( KERNAM(1) .NE. ' ' .AND. KERNAM(2) .NE. ' ' ) THEN

         SAMPLE = EQSTR( FFRNAM(1), FFRNAM(2) ) .AND.
     .            EQSTR( TFRNAM(1), TFRNAM(2) ) .AND.
     .            KERNLS(1) .EQ. KERNLS(2)      .AND.
     .            KERNAM(1) .EQ. KERNAM(2)

      ELSE

         SAMPLE = EQSTR( FFRNAM(1), FFRNAM(2) ) .AND.
     .            EQSTR( TFRNAM(1), TFRNAM(2) ) .AND.
     .            KERNLS(1) .EQ. KERNLS(2)

      END IF

C
C     Count how many singleton and non-singleton intervals comparison
C     window contains and get the measure of the window.
C
      WINMES = 0.D0
      SGTCNT = 0
      NSGCNT = 0

      DO I = 1, CARDD( CMPWIN ), 2
            
         WINMES = WINMES + ( CMPWIN(I+1) - CMPWIN(I) )

         IF ( CMPWIN(I+1) .EQ. CMPWIN(I) ) THEN
            SGTCNT = SGTCNT + 1
         ELSE
            NSGCNT = NSGCNT + 1
         END IF

      END DO

C
C     Determine time step if it was not given on the command line.
C
      IF ( STEP .EQ. 0.D0 ) THEN

C
C        Check how the number of points for comparison returned by
C        CHWCML relates to these singleton/non-singleton interval
C        counts. Recall that for each singleton interval the time
C        array will contain one point while for each non-singleton
C        it will contain at least two points -- one for each
C        interval end.
C
         IF ( NITR .LE. ( SGTCNT + NSGCNT * 2 ) ) THEN

C
C           The requested number of points for comparison is less or
C           equal to the minimum number that we should have for the
C           intervals in our comparison window. In this case, we set
C           step to a value that won't produce any points within
C           intervals. NITR will be reset to the minimum number
C           later, in the loop that computes epochs.
C
            STEP = MAX( 1.D0, WINMES + 1.D0 )

         ELSE

C
C           The requested number of points for comparison is greater
C           than the minimum number that we should have for the
C           intervals in our comparison window. In this case, we
C           have some points to distribute within non-singleton
C           intervals and to do that we need to compute the step
C           using which they should be distributed. We do this by
C           dividing the window measure by the difference between
C           requested number of points and the minimum number of
C           intervals. Note that the step computed this way is
C           larger than the step that we could have gotten if we
C           have divided by the difference between requested number
C           and the total number of intervals. But, unfortunately,
C           the smaller step computed using the latter approach may
C           cause epoch buffer overflow due to round off.
C
            STEP = WINMES / ( NITR - ( SGTCNT + NSGCNT * 2 ) )

         END IF

      END IF

C
C     Using step generate array of times at which attitudes will be
C     computed using the same algorithm as was used in CHWCML. Note
C     that although the step should not cause overflow of the epoch
C     buffer (the input was verified to and the computed step was
C     set to not to do so), we will still check for overflow and
C     generate bug-type errors if we see it.
C
      NITR = 0
      DO I = 1, WNCARD(CMPWIN)

C
C        Fetch endpoints of the next interval.
C
         CALL WNFETD ( CMPWIN, I, ET(1), ET(2) )

C
C        Add one step for start of the interval.
C
         IF ( NITR + 1 .LE. MAXITR ) THEN
            NITR = NITR + 1
            EPOCH( NITR ) = ET(1)
         ELSE
            CALL SETMSG ( 'There is a bug in the program. '       //
     .                    'Please, contact NAIF.'                 )
            CALL SIGERR ( 'SPICE(FRMDIFFBUG3)'                    )
         END IF

C
C        Add one step for each point between endpoints up to the end
C        of the interval minus padding.
C
         HDP2  = ET(2) - STEP * STPPAD

         COUNT = 1
         HDP1  = ET(1) + STEP * COUNT

         DO WHILE ( HDP1 .LT. HDP2 .AND. NITR .LT. MAXITR )

            NITR  = NITR + 1
            EPOCH( NITR ) = HDP1

            COUNT = COUNT + 1 
            HDP1  = ET(1) + STEP * COUNT

         END DO

C
C        If interval begin time is not equal to interval end time
C        add one step for the end of the interval.
C
         IF ( ET(1) .NE. ET(2) ) THEN

            IF ( NITR + 1 .LE. MAXITR ) THEN
               NITR = NITR + 1
               EPOCH ( NITR ) = ET(2)
            ELSE
               CALL SETMSG ( 'There is a bug in the program. '    //
     .                       'Please, contact NAIF.'              )
               CALL SIGERR ( 'SPICE(FRMDIFFBUG4)'                 )
            END IF

         END IF

      END DO

C
C     Set flag indicating that the number of steps is equal to the
C     number of end points.
C
      EPONLY = NITR .EQ. ( SGTCNT + NSGCNT * 2 )

C
C     With the first and second attitude set attributes and epochs
C     in hand we can now compute the attitude. How we do this
C     depends on how many files were provided on the command line.
C
      IF      ( KERNAM(1) .NE. ' ' .AND.
     .          KERNAM(2) .NE. ' '       ) THEN

C
C        Compute one or two attitude sets depending on sampling
C        flag.
C
         IF ( SAMPLE ) THEN

C
C           Compute one attitude set.
C
C           Unload everything; load additional kernels for first
C           attitude; check that first attitude cannot be computed
C           without the first file at all epochs (except for
C           inertial frames); load the first file; compute and
C           buffer attitude (and AV if requested) for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .TRUE.,  FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK                           .AND.
     .           .NOT. ISINRT( FFRID(1), TFRID(1) )       ) THEN
               CALL SETMSG ( 'The attitude must not be '          //
     .                       'computable using only supporting '  //
     .                       'kernels ''#'' '                     //
     .                       'provided after the keys '           //
     .                       '''#'' and ''#'' without loading '   //
     .                       'the first kernel ''#''. #.'         )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', KERNAM(1)                       )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN0)'             )
            END IF

            CALL LDKLST( KERNAM(1) )

            CALL GETQAV( .FALSE., FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The attitude must be computable '   //
     .                       'using the first kernel ''#'' and '  //
     .                       'supporting kernels ''#'' '          //
     .                       'provided '                          //
     .                       'after the keys ''#'' and ''#''. #'  )
               CALL ERRCH  ( '#', KERNAM(1)                       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA0)'              )
            END IF

C
C           Set second attitude to identity and AV to zero.
C
            DO I = 1, NITR
               Q2 (1,I) = 1.D0
               Q2 (2,I) = 0.D0
               Q2 (3,I) = 0.D0
               Q2 (4,I) = 0.D0
               AV2(1,I) = 0.D0
               AV2(2,I) = 0.D0
               AV2(3,I) = 0.D0
            END DO

         ELSE

C
C           Compute two attitude sets.
C
C           Unload everything; load additional kernels for first
C           attitude; check that first attitude cannot be computed
C           without first file at all epochs (except for inertial
C           frames); load first file; compute and buffer attitude
C           (and AV if requested) for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .TRUE.,  FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK                           .AND.
     .           .NOT. ISINRT( FFRID(1), TFRID(1) )       ) THEN
               CALL SETMSG ( 'The first attitude to be compared ' //
     .                       'must not be computable using only ' //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after '                    //
     .                       'the keys ''#'' and ''#'' without '  //
     .                       'loading the first kernel ''#''. #.' )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', KERNAM(1)                       )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN1)'             )
            END IF

            CALL LDKLST( KERNAM(1) )

            CALL GETQAV( .FALSE., FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The first attitude to be compared ' //
     .                       'must be computable using the first '//
     .                       'kernel ''#'' and supporting '       //
     .                       ' kernels ''#'' '                    //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
               CALL ERRCH  ( '#', KERNAM(1)                       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA1)'              )
            END IF

C
C           Unload everything; load additional kernels for second
C           attitude; check that second attitude cannot be computed
C           without second file at all epochs (except for inertial
C           frames); load second file; compute and buffer attitude
C           (and AV if requested) for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(2)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .TRUE.,  FFRNAM(2), TFRNAM(2), EPOCH, NITR,
     .                   AVFLG, Q2, AV2, OK, ERROR )

            IF ( .NOT. OK                           .AND.
     .           .NOT. ISINRT( FFRID(2), TFRID(2) )       ) THEN
               CALL SETMSG ( 'The second attitude to be compared '//
     .                       'must not be computable using only ' //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after '                    //
     .                       'the keys ''#'' and ''#'' without '  //
     .                       'loading the second kernel ''#''. #.')
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN2)'             )
            END IF

            CALL LDKLST( KERNAM(2) )

            CALL GETQAV( .FALSE., FFRNAM(2), TFRNAM(2), EPOCH, NITR,
     .                   AVFLG, Q2, AV2, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The second attitude to be compared '//
     .                       'must be computable using the '      //
     .                       'second kernel ''#'' and supporting '//
     .                       'kernels ''#'' '                     //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA2)'              )
            END IF

         END IF

      ELSE IF ( KERNAM(2) .NE. ' '       ) THEN

C
C        Only one kernel was provided on the command line. Compute
C        one or two attitude sets depending on sampling flag.
C
         IF ( SAMPLE ) THEN

C
C           Compute one attitude set.
C
C           Unload everything; load additional kernels for first
C           attitude; check that first attitude cannot be computed
C           without the input file at all epochs (except for
C           inertial frames); load the file; compute and buffer
C           attitude (and AV if requested) for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .TRUE.,  FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK                           .AND.
     .           .NOT. ISINRT( FFRID(1), TFRID(1) )       ) THEN
               CALL SETMSG ( 'The attitude must not be '          //
     .                       'computable using only supporting '  //
     .                       'kernels ''#'' '                     //
     .                       'provided after the keys '           //
     .                       '''#'' and ''#'' without loading '   //
     .                       'the kernel ''#''. #.'               )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN3)'             )
            END IF

            CALL LDKLST( KERNAM(2) )

            CALL GETQAV( .FALSE., FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The attitude must be computable '   //
     .                       'using the kernel ''#'' and '        //
     .                       'supporting kernels ''#'' '          //
     .                       'provided '                          //
     .                       'after the keys ''#'' and ''#''. #'  )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA3)'              )
            END IF

C
C           Set second attitude to identity and AV to zero.
C
            DO I = 1, NITR
               Q2 (1,I) = 1.D0
               Q2 (2,I) = 0.D0
               Q2 (3,I) = 0.D0
               Q2 (4,I) = 0.D0
               AV2(1,I) = 0.D0
               AV2(2,I) = 0.D0
               AV2(3,I) = 0.D0
            END DO

         ELSE

C
C           Compute two attitude sets.
C
C           Unload everything; load additional kernels for first
C           attitude; check that first attitude cannot be computed
C           without the input file at all epochs (except for
C           inertial frames); load the file; compute and buffer
C           attitude (and AV if requested) for all epochs
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .TRUE.,  FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK                           .AND.
     .           .NOT. ISINRT( FFRID(1), TFRID(1) )       ) THEN
               CALL SETMSG ( 'The first attitude to be compared ' //
     .                       'must not be computable using only ' //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after '                    //
     .                       'the keys ''#'' and ''#'' without '  //
     .                       'loading the kernel ''#''. #.'       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN4)'             )
            END IF

            CALL LDKLST( KERNAM(2) )

            CALL GETQAV( .FALSE., FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The first attitude to be compared ' //
     .                       'must be computable using the '      //
     .                       'kernel ''#'' and supporting '       //
     .                       'kernels ''#'' '                     //
     .                       'provided after the keys '           //
     .                       '''#'' and ''#''. #'                 )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA4)'              )
            END IF

C
C           Unload everything; load additional kernels for second
C           attitude; check that second attitude cannot be computed
C           without the input file at all epochs (except for
C           inertial frames); load the file; compute and buffer
C           attitude (and AV if requested) for all epochs
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(2)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .TRUE.,  FFRNAM(2), TFRNAM(2), EPOCH, NITR,
     .                   AVFLG, Q2, AV2, OK, ERROR )

            IF ( .NOT. OK                           .AND.
     .           .NOT. ISINRT( FFRID(2), TFRID(2) )       ) THEN
               CALL SETMSG ( 'The second attitude to be compared '//
     .                       'must not be computable using only ' //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after '                    //
     .                       'the keys ''#'' and ''#'' without '  //
     .                       'loading the kernel ''#''. #.'       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN5)'             )
            END IF

            CALL LDKLST( KERNAM(2) )

            CALL GETQAV( .FALSE., FFRNAM(2), TFRNAM(2), EPOCH, NITR,
     .                   AVFLG, Q2, AV2, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The second attitude to be compared '//
     .                       'must be computable using the '      //
     .                       'kernel ''#'' and supporting '       //
     .                       'kernels ''#'' '                     //
     .                       'provided after the keys '           //
     .                       '''#'' and ''#''. #'                 )
               CALL ERRCH  ( '#', KERNAM(2)                       )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA5)'              )
            END IF

         END IF

      ELSE

C
C        No kernels were provided on the command line.   Compute
C        one or two attitude sets depending on sampling flag.
C
         IF ( SAMPLE ) THEN

C
C           Compute one attitude set.
C
C           Unload everything; load additional kernels for first
C           attitude; compute and buffer attitude (and AV if
C           requested) for all epochs
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .FALSE., FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The attitude must be computable '   //
     .                       'using the supporting kernels '      //
     .                       '''#'' '                             //
     .                       'provided after the keys ''#'' and ' //
     .                       '''#''. #'                           )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA6)'              )
            END IF

C
C           Set second attitude to identity.
C
            DO I = 1, NITR
               Q2 (1,I) = 1.D0
               Q2 (2,I) = 0.D0
               Q2 (3,I) = 0.D0
               Q2 (4,I) = 0.D0
               AV2(1,I) = 0.D0
               AV2(2,I) = 0.D0
               AV2(3,I) = 0.D0
            END DO

         ELSE

C
C           Compute two attitude sets.
C
C           Unload everything; load additional kernels for first
C           attitude; compute and buffer attitude (and AV if
C           requested) for all epochs.
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(1)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .FALSE., FFRNAM(1), TFRNAM(1), EPOCH, NITR,
     .                   AVFLG, Q1, AV1, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The first attitude to be compared ' //
     .                       'must be computable using the '      //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after '                    //
     .                       'the keys ''#'' and ''#''. #'        )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE1KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA7)'              )
            END IF

C
C           Unload everything; load additional kernels for second
C           attitude; compute and buffer attitude (and AV if
C           requested) for all epochs
C
            CALL KCLEAR

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3)))//' '//KERNLS(2)
            CALL LDKLST( HLLINE )

            CALL GETQAV( .FALSE., FFRNAM(2), TFRNAM(2), EPOCH, NITR,
     .                   AVFLG, Q2, AV2, OK, ERROR )

            IF ( .NOT. OK ) THEN
               CALL SETMSG ( 'The second attitude to be compared '//
     .                       'must be computable using the '      //
     .                       'supporting kernels ''#'' '          //
     .                       'provided after '                    //
     .                       'the keys ''#'' and ''#''. #'        )
               CALL ERRCH  ( '#', HLLINE                          )
               CALL ERRCH  ( '#', KERKEY                          )
               CALL ERRCH  ( '#', KE2KEY                          )
               CALL ERRCH  ( '#', ERROR                           )
               CALL SIGERR ( 'SPICE(NOTENOUGHDATA8)'              )
            END IF

         END IF

      END IF

C
C     Load kernels that may be needed for time conversions in the
C     routine that does the rest of display. The set of kernels that we
C     will load depends on the time format. For SCLK output we will
C     load kernels applicable for the SCLK ID that is set (either
C     SCLKID(1) or SCLKID(2)). For all other formats we will first load
C     all kernels applicable to both attitude sets, then all kernels
C     applicable to second attitude set, and finally all kernels
C     applicable to first attitude set, just like we did in CHWCML
C     before processing begin and end time command line arguments.
C
      IF ( EQSTR( TIMFMT, SCSVAL ) .OR.
     .     EQSTR( TIMFMT, SCDVAL ) .OR.
     .     EQSTR( TIMFMT, SCTVAL )      ) THEN

         IF      ( SCLKID(1) .NE. 0 ) THEN

            IF (  KERNAM(1) .NE. ' ' ) THEN
               HLLINE = KERNLS(3)(:RTRIM(KERNLS(3))) // ' ' // 
     .                  KERNLS(1)(:RTRIM(KERNLS(1))) // ' ' // 
     .                  KERNAM(1)
            ELSE
               HLLINE = KERNLS(3)(:RTRIM(KERNLS(3))) // ' ' //
     .                  KERNLS(1)(:RTRIM(KERNLS(1))) // ' ' //
     .                  KERNAM(2)
            END IF
            MYSCID = SCLKID(1)

         ELSE IF ( SCLKID(2) .NE. 0 ) THEN

            HLLINE = KERNLS(3)(:RTRIM(KERNLS(3))) // ' ' //
     .               KERNLS(2)(:RTRIM(KERNLS(2))) // ' ' // 
     .               KERNAM(2)
            MYSCID = SCLKID(2)

         ELSE

            CALL SETMSG ( 'There is a bug in the program. Please '   //
     .                    'contact NAIF.'                            )
            CALL SIGERR ( 'SPICE(FRMDIFFBUG5)'                       )

         END IF

      ELSE

         HLLINE = KERNLS(3)(:RTRIM(KERNLS(3))) // ' ' //
     .            KERNLS(2)(:RTRIM(KERNLS(2))) // ' ' //
     .            KERNAM(2)(:RTRIM(KERNAM(2))) // ' ' //
     .            KERNLS(1)(:RTRIM(KERNLS(1))) // ' ' //
     .            KERNAM(1)

         MYSCID = 0

      END IF

      CALL KCLEAR
      CALL LDKLST( HLLINE )

C
C     Generate and display report header. The header for comparison
C     run is different from the header for sampling run. First, prepare
C     strings that will appear in both headers.
C
C     Make string representing step. Step is included in the report as
C     the number of seconds and as DDDAYS:HR:MN:SC.MSECND.
C
      STPSTR = '# second (#)'
      CALL REPMF ( STPSTR, '#', STEP, 15, 'F', STPSTR )
      CALL DR2STR( STEP, HWORD )
      CALL REPMC ( STPSTR, '#', HWORD,         STPSTR )

C
C     Make strings representing start and stop times.
C
      CALL ETCAL ( CMPWIN(1),             TIME(1) )
      CALL ETCAL ( CMPWIN(CARDD(CMPWIN)), TIME(2) )

      CALL PREFIX( '''',                     0, TIME(1) )
      CALL PREFIX( '''',                     0, TIME(2) )

      CALL SUFFIX( ''' TDB (# TDB seconds)', 0, TIME(1) )
      CALL SUFFIX( ''' TDB (# TDB seconds)', 0, TIME(2) )

      CALL REPMF ( TIME(1), '#', CMPWIN(1),    15, 'F', TIME(1) )
      CALL REPMF ( TIME(2), '#', CMPWIN(CARDD(CMPWIN)),
     .                                         15, 'F', TIME(2) )

C
C     Make string indicating whether comparison window has gaps.
C
      IF ( WNCARD(CMPWIN) .EQ. 1 ) THEN
         GAPSTR = 'continuous'
      ELSE
         GAPSTR = 'non-continuous (with # gaps)'
         CALL REPMI ( GAPSTR, '#', WNCARD(CMPWIN)-1, GAPSTR )
      END IF

C
C     Make string indicating if angular velocities were computed
C     and, if yes, in which frame(s).
C
      IF ( AVFLG ) THEN
         IF ( AVFFLG ) THEN
            AVSTR = '''to'''
         ELSE
            AVSTR = '''from'''
         END IF
      ELSE
         AVSTR = ' '
      END IF

C
C     Fill in report header.
C
      IF ( SAMPLE ) THEN

C
C        Set header template for sampling case.
C
         INFMSG(  1 ) = '#'
         INFMSG(  2 ) = '# Sampling of $ rotations'
         INFMSG(  3 ) = '#'
         INFMSG(  4 ) = '#    from ''$'' ($) to ''$'' ($)'
         INFMSG(  5 ) = '#    computed using'
         INFMSG(  6 ) = '#'
         INFMSG(  7 ) = '#       $'
         INFMSG(  8 ) = '#       $'
         INFMSG(  9 ) = '#       $'
         INFMSG( 10 ) = '#'
         INFMSG( 11 ) = '# with a $ step size'
         INFMSG( 12 ) = '# within the $ time period'
         INFMSG( 13 ) = '#'
         INFMSG( 14 ) = '#    from $'
         INFMSG( 15 ) = '#    to   $'
         INFMSG( 16 ) = '#'
         INFMSG( 17 ) = '# including angular velocities relative ' //
     .                  'to $ frame.'
         INFMSG( 18 ) = '#'
         INFMSG( 19 ) = '# Times $.'
         INFMSG( 20 ) = '#'

         INFCNT = 20

C
C        Tag all lines as printable.
C
         DO I = 1, INFCNT
            INFPRT(I) = .TRUE.
         END DO

C
C        Substitute values.
C
         CALL REPMI ( INFMSG(  2 ), '$', NITR,      INFMSG(  2 ) )

         CALL REPMC ( INFMSG(  4 ), '$', FFRNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', FFRID(1),  INFMSG(  4 ) )
         CALL REPMC ( INFMSG(  4 ), '$', TFRNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', TFRID(1),  INFMSG(  4 ) )

         IF ( KERNLS(3) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  7 ), '$', KERNLS(3), INFMSG(  7 ) )
         ELSE
            INFPRT( 7 ) = .FALSE.
         END IF

         IF ( KERNLS(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  8 ), '$', KERNLS(1), INFMSG(  8 ) )
         ELSE
            INFPRT( 8 ) = .FALSE.
         END IF

         IF      ( KERNAM(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', KERNAM(1), INFMSG(  9 ) )
         ELSE IF ( KERNAM(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', KERNAM(2), INFMSG(  9 ) )
         ELSE
            INFPRT( 9 ) = .FALSE.
         END IF

         IF ( .NOT. INFPRT( 7 ) .AND.
     .        .NOT. INFPRT( 8 ) .AND.
     .        .NOT. INFPRT( 9 )       ) THEN
            INFPRT( 5 ) = .FALSE.
            INFPRT( 6 ) = .FALSE.
         END IF

         CALL REPMC ( INFMSG( 11 ), '$', STPSTR,  INFMSG( 11 ) )

         CALL REPMC ( INFMSG( 12 ), '$', GAPSTR,  INFMSG( 12 ) )

         CALL REPMC ( INFMSG( 14 ), '$', TIME(1), INFMSG( 14 ) )

         CALL REPMC ( INFMSG( 15 ), '$', TIME(2), INFMSG( 15 ) )

         IF ( AVFLG ) THEN
            CALL REPMC ( INFMSG( 17 ), '$', AVSTR,   INFMSG( 17 ) )
         ELSE
            INFPRT(17) = .FALSE.
            INFPRT(18) = .FALSE.
         END IF

C
C        Set index of the line providing time spec.
C
         TLIDX = 19

C
C        For coverage reports we need to change some wording and drop
C        some lines.
C
         IF ( EQSTR( DIFTYP, DCVAL  ) .OR.
     .        EQSTR( DIFTYP, DGVAL  )      ) THEN

            INFMSG(  2 ) = '# Coverage for rotation'

         END IF

C
C        For runs checking only endpoints, replace step line.
C
         IF ( EPONLY ) THEN
            INFMSG( 11 ) = '# at continuous coverage intervals'' ' //
     .                     'endpoints'
         END IF

      ELSE

C
C        Set header template for comparison case.
C
         INFMSG(  1 ) = '#'
         INFMSG(  2 ) = '# Comparison of $ rotations'
         INFMSG(  3 ) = '#'
         INFMSG(  4 ) = '#    from ''$'' ($) to ''$'' ($)'
         INFMSG(  5 ) = '#    computed using'
         INFMSG(  6 ) = '#'
         INFMSG(  7 ) = '#       $'
         INFMSG(  8 ) = '#       $'
         INFMSG(  9 ) = '#       $'
         INFMSG( 10 ) = '#'
         INFMSG( 11 ) = '# with $ rotations'
         INFMSG( 12 ) = '#'
         INFMSG( 13 ) = '#    from ''$'' ($) to ''$'' ($)'
         INFMSG( 14 ) = '#    computed using'
         INFMSG( 15 ) = '#'
         INFMSG( 16 ) = '#       $'
         INFMSG( 17 ) = '#       $'
         INFMSG( 18 ) = '#       $'
         INFMSG( 19 ) = '#'
         INFMSG( 20 ) = '# with a $ step size'
         INFMSG( 21 ) = '# within the $ time period'
         INFMSG( 22 ) = '#'
         INFMSG( 23 ) = '#    from $'
         INFMSG( 24 ) = '#    to   $'
         INFMSG( 25 ) = '#'
         INFMSG( 26 ) = '# including differences in angular ' //
     .                  'velocities relative to $ frames.'
         INFMSG( 27 ) = '#'
         INFMSG( 28 ) = '# Times $.'
         INFMSG( 29 ) = '#'

         INFCNT = 29

C
C        Tag all lines as printable.
C
         DO I = 1, INFCNT
            INFPRT(I) = .TRUE.
         END DO

C
C        Substitute values.
C
         CALL REPMI ( INFMSG(  2 ), '$', NITR,      INFMSG(  2 ) )

         CALL REPMC ( INFMSG(  4 ), '$', FFRNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', FFRID(1),  INFMSG(  4 ) )
         CALL REPMC ( INFMSG(  4 ), '$', TFRNAM(1), INFMSG(  4 ) )
         CALL REPMI ( INFMSG(  4 ), '$', TFRID(1),  INFMSG(  4 ) )

         IF ( KERNLS(3) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  7 ), '$', KERNLS(3), INFMSG(  7 ) )
         ELSE
            INFPRT( 7 ) = .FALSE.
         END IF

         IF ( KERNLS(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  8 ), '$', KERNLS(1), INFMSG(  8 ) )
         ELSE
            INFPRT( 8 ) = .FALSE.
         END IF

         IF      ( KERNAM(1) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', KERNAM(1), INFMSG(  9 ) )
         ELSE IF ( KERNAM(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG(  9 ), '$', KERNAM(2), INFMSG(  9 ) )
         ELSE
            INFPRT( 9 ) = .FALSE.
         END IF

         IF ( .NOT. INFPRT( 7 ) .AND.
     .        .NOT. INFPRT( 8 ) .AND.
     .        .NOT. INFPRT( 9 )       ) THEN
            INFPRT( 5 ) = .FALSE.
            INFPRT( 6 ) = .FALSE.
         END IF

         CALL REPMI ( INFMSG( 11 ), '$', NITR,      INFMSG( 11 ) )

         CALL REPMC ( INFMSG( 13 ), '$', FFRNAM(2), INFMSG( 13 ) )
         CALL REPMI ( INFMSG( 13 ), '$', FFRID(2),  INFMSG( 13 ) )
         CALL REPMC ( INFMSG( 13 ), '$', TFRNAM(2), INFMSG( 13 ) )
         CALL REPMI ( INFMSG( 13 ), '$', TFRID(2),  INFMSG( 13 ) )


         IF ( KERNLS(3) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG( 16 ), '$', KERNLS(3), INFMSG( 16 ) )
         ELSE
            INFPRT( 16 ) = .FALSE.
         END IF

         IF ( KERNLS(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG( 17 ), '$', KERNLS(2), INFMSG( 17 ) )
         ELSE
            INFPRT( 17 ) = .FALSE.
         END IF

         IF      ( KERNAM(2) .NE. ' ' ) THEN
            CALL REPMC ( INFMSG( 18 ), '$', KERNAM(2), INFMSG( 18 ) )
         ELSE
            INFPRT( 18 ) = .FALSE.
         END IF

         IF ( .NOT. INFPRT( 16 ) .AND.
     .        .NOT. INFPRT( 17 ) .AND.
     .        .NOT. INFPRT( 18 )       ) THEN
            INFPRT( 14 ) = .FALSE.
            INFPRT( 15 ) = .FALSE.
         END IF

         CALL REPMC ( INFMSG( 20 ), '$', STPSTR,  INFMSG( 20 ) )

         CALL REPMC ( INFMSG( 21 ), '$', GAPSTR,  INFMSG( 21 ) )

         CALL REPMC ( INFMSG( 23 ), '$', TIME(1), INFMSG( 23 ) )

         CALL REPMC ( INFMSG( 24 ), '$', TIME(2), INFMSG( 24 ) )

         IF ( AVFLG ) THEN
            CALL REPMC ( INFMSG( 26 ), '$', AVSTR,   INFMSG( 26 ) )
         ELSE
            INFPRT(26) = .FALSE.
            INFPRT(27) = .FALSE.
         END IF

C
C        Set index of the line providing time spec.
C
         TLIDX = 28

C
C        For coverage reports we need to change some wording and drop
C        some lines.
C
         IF ( EQSTR( DIFTYP, DCVAL  ) .OR.
     .        EQSTR( DIFTYP, DGVAL  )      ) THEN

            INFMSG(  2 ) = '# Coverage overlap for rotation'
            INFMSG( 11 ) = '# and rotation'

         END IF

C
C        For runs checking only endpoints, replace step line.
C
         IF ( EPONLY ) THEN
            INFMSG( 20 ) = '# at continuous coverage intervals'' ' //
     .                     'endpoints'
         END IF

      END IF

C
C     Fill in time type.
C
      IF ( EQSTR( DIFTYP, BASVAL  ) .OR.
     .     EQSTR( DIFTYP, STSVAL  )      ) THEN

         INFPRT(TLIDX)   = .FALSE.
         INFPRT(TLIDX+1) = .FALSE.

      ELSE

         IF      ( EQSTR( TIMFMT, ETVAL ) ) THEN

            CALL REPMC ( INFMSG( TLIDX ), '$', 
     .           'are TDB seconds past J2000',  
     .           INFMSG( TLIDX ) )
   
         ELSE IF ( EQSTR( TIMFMT, SCTVAL ) ) THEN

            CALL REPMC ( INFMSG( TLIDX ), '$', 
     .           'are SCLK ticks computed using SCLK ID $',
     .           INFMSG( TLIDX ) )
            CALL REPMI ( INFMSG( TLIDX ), '$', MYSCID, INFMSG( TLIDX ) )

         ELSE IF ( EQSTR( TIMFMT, SCSVAL ) ) THEN

            CALL REPMC ( INFMSG( TLIDX ), '$', 
     .           'are SCLKs computed using SCLK ID $',
     .           INFMSG( TLIDX ) )
            CALL REPMI ( INFMSG( TLIDX ), '$', MYSCID, INFMSG( TLIDX ) )

         ELSE IF ( EQSTR( TIMFMT, SCDVAL ) ) THEN

            CALL REPMC ( INFMSG( TLIDX ), '$', 
     .           'are decimal SCLKs computed using SCLK ID $',
     .           INFMSG( TLIDX ) )
            CALL REPMI ( INFMSG( TLIDX ), '$', MYSCID, INFMSG( TLIDX ) )

         ELSE

            CALL REPMC ( INFMSG( TLIDX ), '$', 
     .           'were generated by TIMOUT using ''$'' format',
     .           INFMSG( TLIDX ) )
            CALL REPMC ( INFMSG( TLIDX ), '$', TIMFMT, INFMSG( TLIDX ) )
            
         END IF

      END IF

C
C     Display report header.
C
      DO I = 1, INFCNT
         IF ( INFPRT(I) ) THEN
            CALL TOSTDO ( INFMSG(I) )
         END IF
      END DO

C
C     Pass quaternions and AV tables with all the flags to the routine
C     that will do analysis of the differences and will print them to
C     the screen.
C
      CALL RTDIFF( Q1, AV1, Q2, AV2, CMPWIN, NITR, EPOCH, DIFTYP,
     .             AVFLG, AVFFLG, TIMFMT, MYSCID, AXES, AUNITS, SAMPLE,
     .             SIGDIG )

C
C     Check out.
C
      CALL CHKOUT( PGMNAM )

C
C     We are done. :-)
C
      END
