C$Program    CKBRIEF ( BRIEF CK summary )
C
      PROGRAM CKBRIEF
 
      IMPLICIT NONE
C
C$ Abstract
C
C     CKBRIEF is a utility program that provides brief summaries of
C     the contents of one or more CK files.
C
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     CKBRIEF User's Guide.
C
C$ Keywords
C
C     FILES
C     UTILITY
C
C$ Parameters
C
C     None.
C
C$ Exceptions
C
C     None.
C
C$ Files
C
C     1) All summary tasks performed require name for at least one
C        CK file to be provided.
C
C     2) To display time tags in any format (except DP SCLK), LSK
C        and appropriate SCLK files must be provided.
C
C$ Particulars
C
C     For usage details see User's Guide.
C
C$ Examples
C
C     None.
C
C$ Restrictions
C
C     None.
C
C$ Literature_References
C
C     None.
C
C$ Author_and_Institution
C
C     Y.K. Zaiko     (BERC)
C     B.V. Semenov   (NAIF)
C     F.S. Turner    (JPL)
C
C$ Version
C
C-    Toolkit Version 6.1.0, 27-JUN-2014 (BVS)
C
C        BUG FIX: changed logic to make a combination of -a and an ID
C        specified on the command line work in all cases.
C
C-    Toolkit Version 6.0.0, 28-APR-2014 (BVS) (NJB)
C
C        Modified to treat all files as a single file (-a).
C
C        Changed SCLKD display format to include 6 decimal 
C        places.
C
C        Increased MAXBOD to 1,000,000 (from 100,000) and CMDSIZ to 
C        50,000 (from 25,000).
C
C        Added support for CK type 6.
C
C-    Toolkit Version 5.0.0, 11-FEB-2009 (BVS)
C
C        Modified to display names of the frames associated with CK 
C        IDs (new option -n).
C
C        Updated help display.
C
C        Bug fix: hanging up when no value was provided after -f.
C
C        Bug fix: replaced warning message and incomplete summary in
C        the case of insufficient buffer space (FULBUF) with an error
C        message.
C
C-    Toolkit Version 4.0.0, 13-JAN-2008 (BVS)
C
C        Bug fix: GDSP is now initialized to .FALSE. Uninitialized GDSP
C        caused spontaneous, unsolicited grouping displays on some C
C        environments.
C
C        Updated to summarize CKs provided in meta-kernels. Updated to
C        recognize and complain about kernels that should be
C        summarized other utility programs. Updated to display shorter
C        usage message when ran with a blank command line.
C
C        Changed format of the displayed version string.
C
C        Added CHKIN/CHKOUT and set ERRACT to ABORT (which removed
C        "Oh, by the way ..." from the errors).
C
C        Increased MAXBOD to 100,000 (from 10,000) and CMDSIZ to 
C        25,000 (from 4,000)
C
C        SAVEed all variables.
C
C-    Toolkit Version 3.2.0, 02-NOV-2006 (BVS)
C
C        Replaced LDPOOL with FURNSH.
C
C-    Toolkit Version 3.1.0, 08-NOV-2005 (BVS)
C
C        Updated usage display to describe what kind of summary
C        is generated by default.
C
C-    Toolkit Version 3.0.0, 28-AUG-2002 (FST)
C
C        Added support for the -dump option for type 4 and 5 CK
C        segments.
C
C        Modified ZZCKCVR3 calling sequence to agree with changes
C        as delivered to support.
C
C-    Toolkit Version 2.0.0, 15-MAY-2001 (BVS)
C
C        Added option to dump interpolation interval information
C        from type 2 & 3 CK segments.
C
C-    Toolkit Version 1.1.2, 09-APR-2001 (BVS)
C
C        Fixed usage display and User's Guide.
C
C-    Toolkit Version 1.1.1, 03-NOV-2000 (EDW)
C
C        Added a BYEBYE( 'SUCCESS' ) call at program's end.
C
C-    Toolkit Version 1.1.0, 14-OCT-1999 (WLT)
C
C        Commented out EXTERNALS in source code.  See note in the
C        code for details.
C
C-    Toolkit Version 1.0.0, 26-Mar-1999 (WLT)
C
C        Added code to skip attempting to load binary kernels into
C        the kernel pool.
C
C-    Beta Version 1.0.0,  24-MAR-1999  ( YKZ ) ( BVS )
C
C        See CKBRIEF.INC for version information.
C
C-&
 
C
C     User adjustable parameters.
C
      INCLUDE              'ckbrief.inc'
 
C
C     Passed Functions
C
C     The lines below have been commented out as they do not appear
C     to be needed for anything.  BIGGER and INC are not referenced
C     anywhere else in this file.  (WLT) 14-OCT-1999
C
C      EXTERNAL              BIGGER
C      EXTERNAL              INC
 
 
C
C     SPICELIB Functions
C
      INTEGER               ISRCHI
      INTEGER               CARDD
      LOGICAL               BEINT
      INTEGER               RTRIM
 
C
C     Local parameters
C
 
C
C     Command line options as parameters.
C
      CHARACTER*(*)         FREL
      PARAMETER           ( FREL    = '-rel'    )
 
      CHARACTER*(*)         FTDSP
      PARAMETER           ( FTDSP   = '-t'      )
 
      CHARACTER*(*)         FGROUP
      PARAMETER           ( FGROUP  = '-g'      )
 
      CHARACTER*(*)         FHELP
      PARAMETER           ( FHELP   = '-h'      )
 
      CHARACTER*(*)         FVRSN
      PARAMETER           ( FVRSN   = '-v'      )
 
      CHARACTER*(*)         FSCLK
      PARAMETER           ( FSCLK   = '-sclk'   )
 
      CHARACTER*(*)         FDPCLK
      PARAMETER           ( FDPCLK  = '-dpsclk' )
 
      CHARACTER*(*)         FUTC
      PARAMETER           ( FUTC    = '-utc'    )
 
      CHARACTER*(*)         FDOY
      PARAMETER           ( FDOY    = '-utcdoy' )
 
      CHARACTER*(*)         FSFILE
      PARAMETER           ( FSFILE  = '-f'      )
 
      CHARACTER*(*)         FNOMRG
      PARAMETER           ( FNOMRG  = '-nm'     )
 
      CHARACTER*(*)         FDUMP
      PARAMETER           ( FDUMP   = '-dump'   )
 
      CHARACTER*(*)         FALL
      PARAMETER           ( FALL   = '-a'       )
 
      CHARACTER*(*)         FFNAME
      PARAMETER           ( FFNAME  = '-n'      )
 
C
C     Lower cell size.
C
      INTEGER               LBCELL
      PARAMETER           ( LBCELL  = -5 )
 
C
C     CK DAF summary component counts.
C
      INTEGER               ND
      PARAMETER           ( ND      = 2 )
 
      INTEGER               NI
      PARAMETER           ( NI      = 6 )
 
C
C     SPICE Kernel types as recognized by GETFAT.
C
      CHARACTER*(*)         CK
      PARAMETER           ( CK      = 'CK' )
 
      CHARACTER*(*)         DAF
      PARAMETER           ( DAF     = 'DAF' )
 
      CHARACTER*(*)         DAS
      PARAMETER           ( DAS     = 'DAS' )
 
C
C     Usage and help message sizes.
C
      INTEGER               USGSIZ
      PARAMETER           ( USGSIZ  = 21 )

      INTEGER               HLPSIZ
      PARAMETER           ( HLPSIZ  = 47 )
 
C
C     Local variables.
C
 
C
C     Help message holder.
C
      CHARACTER*(LINESZ)    TEXT  ( HLPSIZ )
 
C
C     Usage message holder.
C
      CHARACTER*(LINESZ)    UTEXT ( USGSIZ )
 
C
C     Ancillary line and file names holder line.
C
      CHARACTER*(LINESZ)    LINE
      CHARACTER*(LINESZ)    SRCFIL
 
C
C     Command line and parsing variables.
C
      CHARACTER*(CMDSIZ)    PASS1
      CHARACTER*(CMDSIZ)    PASS2
      CHARACTER*(CMDSIZ)    PASS3
 
      INTEGER               BEG
      INTEGER               END
      INTEGER               START
 
C
C     Parsed Control Values.
C
      LOGICAL               HAVFIL
      LOGICAL               FDSP
      LOGICAL               NDSP
      LOGICAL               HELP
      LOGICAL               OBNAM
      LOGICAL               TDSP
      LOGICAL               GDSP
      LOGICAL               VRSN
      LOGICAL               SFILE
      LOGICAL               NOMERG
      LOGICAL               IDUMP
      LOGICAL               DOALL
 
C
C     Internal flags explanation: FNDSUM is .TRUE. if we have
C     something found to display in CK-file we are considering.
C
      LOGICAL               FNDSUM
 
C
C     DAF Variables
C
      INTEGER               HANDLE
      INTEGER               IC     ( NI )
      DOUBLE PRECISION      DC     ( ND )
      DOUBLE PRECISION      SEGSUM ( NI / 2 + ND )
 
C
C     Arrays to store segment descriptors data for an objects with
C     a single intervals of coverage in a given CK-file
C
      INTEGER               IDS    ( MAXBOD )
      INTEGER               AVFS   ( MAXBOD )
      INTEGER               FRAMES ( MAXBOD )
      DOUBLE PRECISION      TSTRTS ( MAXBOD )
      DOUBLE PRECISION      TENDS  ( MAXBOD )
 
C
C     Arrays to store all segment descriptors data for a given CK-file
C
      INTEGER               IDA    ( MAXBOD )
      INTEGER               AVFA   ( MAXBOD )
      INTEGER               FRAMEA ( MAXBOD )
      INTEGER               BADDRA ( MAXBOD )
      INTEGER               EADDRA ( MAXBOD )
      INTEGER               TYPEA  ( MAXBOD )
      DOUBLE PRECISION      TSTRTA ( MAXBOD )
      DOUBLE PRECISION      TENDA  ( MAXBOD )
 
C
C     Arrays to store all segment descriptors data for one object in
C     a given CK-file
C
      INTEGER               IDO    ( MAXBOD )
      INTEGER               AVFO   ( MAXBOD )
      INTEGER               FRAMEO ( MAXBOD )
      DOUBLE PRECISION      TSTRTO ( MAXBOD )
      DOUBLE PRECISION      TENDO  ( MAXBOD )
 
      DOUBLE PRECISION      WIND   ( LBCELL:LRGWIN )
 
      DOUBLE PRECISION      TEMPS  ( MAXBOD )
      DOUBLE PRECISION      TEMPE  ( MAXBOD )
 
      INTEGER               IORDER ( MAXBOD )
 
C
C     Utility Variables
C
      CHARACTER*(LINESZ)    HWORD
      CHARACTER*(LINESZ)    ERROR
      CHARACTER*(3)         TYPE
      CHARACTER*(3)         ARCH
      CHARACTER*(LINESZ)    TOUT
 
      CHARACTER*(LINESZ)    STRN
 
      INTEGER               I
      INTEGER               K
      INTEGER               L
      INTEGER               NOBGS
      INTEGER               NOBGO
      INTEGER               CNT
      INTEGER               NOBJ
      INTEGER               PTR
      INTEGER               VALUE
      INTEGER               NUMOBJ
      INTEGER               OBJLIS ( MAXUSE )
 
      INTEGER               LOC
 
      LOGICAL               FND
      LOGICAL               EOF
      LOGICAL               MIXDAV
      LOGICAL               MIXDFR
      LOGICAL               FULBUF

C
C     Variable for dealing with FURNSH'ed CKs.
C
      INTEGER               FCOUNT
      INTEGER               FINDEX
      CHARACTER*(LINESZ)    FILTYP
      CHARACTER*(LINESZ)    SOURCE
      LOGICAL               FOUND

C
C     Save all variables.
C
      SAVE
 
C
C     SPICELIB error handling.
C
      CALL CHKIN  ( 'CKBRIEF' )
      CALL ERRACT ( 'SET', 'ABORT')

C
C     The first thing we do is to display version.
C
      LINE = 'CKBRIEF -- Version # -- Toolkit Version #'
      CALL TOSTDO( ' ' )
      CALL REPMC ( LINE, '#', VERSN, LINE )
      CALL TKVRSN( 'TOOLKIT', HWORD )
      CALL REPMC ( LINE, '#', HWORD, LINE )
      CALL TOSTDO( LINE )
 
C
C     Set up the usage text.
C
      UTEXT(  1 ) = '   CKBRIEF is a command-line utility pro'
     .//            'gram that displays a summary for'
      UTEXT(  2 ) = '   one or more binary CK files. The prog'
     .//            'ram usage is:'
      UTEXT(  3 ) = ' '
      UTEXT(  4 ) = '      % ckbrief [-options] file [file ..'
     .//            '.]'
      UTEXT(  5 ) = ' '
      UTEXT(  6 ) = '   The most useful options are shown bel'
     .//            'ow. For the complete set of'
      UTEXT(  7 ) = '   options, run CKBRIEF with the -h opti'
     .//            'on. The order of options is not'
      UTEXT(  8 ) = '   significant. The option keys must be '
     .//            'lowercase as shown below.'
      UTEXT(  9 ) = ' '
      UTEXT( 10 ) = '      -dump        display interpolation'
     .//            ' intervals'
      UTEXT( 11 ) = '      -rel         display relative-to f'
     .//            'rames (may need FK)'
      UTEXT( 12 ) = '      -n           display frames associ'
     .//            'ated with CK IDs (may need FK)'
      UTEXT( 13 ) = '      -t           display summary in a '
     .//            'tabular format'
      UTEXT( 14 ) = '      -a           treat all files as a '
     .//            'single file'
      UTEXT( 15 ) = '      -utc         display times in UTC '
     .//            'calendar date format (needs LSK&SCLK)'
      UTEXT( 16 ) = '      -utcdoy      display times in UTC '
     .//            'day-of-year format (needs LSK&SCLK)'
      UTEXT( 17 ) = '      -sclk        display times as SCLK'
     .//            ' strings (needs SCLK)'
      UTEXT( 18 ) = ' '
      UTEXT( 19 ) = '   LSK and SCLK files must be provided o'
     .//            'n the command line to display times'
      UTEXT( 20 ) = '   in UTC, ET, or SCLK formats. FK file('
     .//            's) must be provided on the command'
      UTEXT( 21 ) = '   line to display names of any frames t'
     .//            'hat are not built into the Toolkit.'



C
C     Set up the help text.
C
      TEXT(  1 ) = '   CKBRIEF is a command line program that'
     .//           ' displays a summary of the'
      TEXT(  2 ) = '   contents and time coverage for one or '
     .//           'more binary CK files. The program'
      TEXT(  3 ) = '   displays a summary for each CK file li'
     .//           'sted on the command line, in a'
      TEXT(  4 ) = '   list file, and/or a meta-kernel. It ca'
     .//           'n display coverage boundaries as'
      TEXT(  5 ) = '   ephemeris time (ET) in calendar format'
     .//           ', as UTC time in'
      TEXT(  6 ) = '   ``year-month-day'''' or ``day-of-year'''
     .//           ''' format, or as on-board clock'
      TEXT(  7 ) = '   (SCLK) time in string or encoded forma'
     .//           't. It can display the summary in a'
      TEXT(  8 ) = '   variety of formats, with or without sh'
     .//           'owing the names of the frames'
      TEXT(  9 ) = '   associated with spacecraft or structur'
     .//           'e IDs or the names/IDs of the'
      TEXT( 10 ) = '   frames with respect to which orientati'
     .//           'on is provided.'
      TEXT( 11 ) = ' '
      TEXT( 12 ) = '   The program usage is:'
      TEXT( 13 ) = ' '
      TEXT( 14 ) = '      ckbrief [-options] file [file ...]'
      TEXT( 15 ) = ' '
      TEXT( 16 ) = '   where [file]s are binary CK files and '
     .//           'text kernels needed to support'
      TEXT( 17 ) = '   time conversion (LSK and SCLKs), or co'
     .//           'ntaining frame definitions (FKs),'
      TEXT( 18 ) = '   provided in any order. The options are'
     .//           ':'
      TEXT( 19 ) = ' '
      TEXT( 20 ) = '      -dump        display interpolation '
     .//           'intervals boundaries'
      TEXT( 21 ) = '      -nm          display segment bounda'
     .//           'ries'
      TEXT( 22 ) = ' '
      TEXT( 23 ) = '      -rel         display relative-to fr'
     .//           'ames'
      TEXT( 24 ) = '      -n           display frames associa'
     .//           'ted with structure IDs'
      TEXT( 25 ) = ' '
      TEXT( 26 ) = '      -t           display summary in a t'
     .//           'abular format'
      TEXT( 27 ) = '      -a           treat all files as a '
     .//            'single file'
      TEXT( 28 ) = '      -g           display summary groupe'
     .//           'd by coverage'
      TEXT( 29 ) = ' '
      TEXT( 30 ) = '      -utc         display times in UTC c'
     .//           'alendar date format'
      TEXT( 31 ) = '      -utcdoy      display times in UTC d'
     .//           'ay-of-year format'
      TEXT( 32 ) = '      -sclk        display times as SCLK '
     .//           'strings'
      TEXT( 33 ) = '      -dpsclk      display times as SCLK '
     .//           'ticks'
      TEXT( 34 ) = ' '
      TEXT( 35 ) = '      [ID]         display summary for st'
     .//           'ructure with [ID]'
      TEXT( 36 ) = ' '
      TEXT( 37 ) = '      -f [list]    summarize kernels list'
     .//           'ed in the [list] file'
      TEXT( 38 ) = ' '
      TEXT( 39 ) = '      -h           display help'
      TEXT( 40 ) = '      -v           display version'
      TEXT( 41 ) = ' '
      TEXT( 42 ) = '   The options can be provided in any ord'
     .//           'er and can appear before, after,'
      TEXT( 43 ) = '   or intermixed with file names. The cas'
     .//           'e of option keys is significant:'
      TEXT( 44 ) = '   they must be lowercase as shown above.'
     .//           ' While any option can be provided'
      TEXT( 45 ) = '   together with any other option or a co'
     .//           'mbination of options, some options'
      TEXT( 46 ) = '   will override others.'
      TEXT( 47 ) = ' '

C
C     Next step is to parse the command line. This is done in two
C     passes. The first pass determines the options specified. The
C     second pass gets file names.
C
C     Pass one.  The defaults are:
C
      OBNAM  = .FALSE.
      TDSP   = .FALSE.
      GDSP   = .FALSE.
      HELP   = .FALSE.
      VRSN   = .FALSE.
      HAVFIL = .FALSE.
      FDSP   = .FALSE.
      NDSP   = .FALSE.
      SFILE  = .FALSE.
      NOMERG = .FALSE.
      IDUMP  = .FALSE.
      DOALL  = .FALSE.
      TOUT = ET
 
C
C     Reset ancillary strings that will be used in parsing of the
C     command line.
C
      PASS1 = ' '
      PASS2 = ' '
      PASS3 = ' '
 
C
C     Get command line.
C
      CALL GETCML (PASS1)

C
C     If command line is blank display brief usage.
C
      IF ( PASS1 .EQ. ' ' ) THEN
         CALL TOSTDO( ' ' )
         DO I = 1, USGSIZ
            CALL TOSTDO ( UTEXT(I) )
         END DO
         CALL TOSTDO ( ' ' )
         STOP
      END IF
 
C
C     Now locate the first word in the command line.
C
      NUMOBJ = 0
      START = 1
      CALL FNDNWD ( PASS1, START, BEG, END )
 
      DO WHILE ( BEG .GT. 0 )
 
C
C        All options begin with a '-'.
C
         IF ( PASS1(BEG:BEG) .NE. '-' ) THEN
C
C           This item doesn't have dash as the first character, so
C           it is presumed to be a file name which we will append
C           to the string containing only file names.
C
            CALL SUFFIX ( PASS1(BEG:END), 1, PASS2 )
            HAVFIL = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FTDSP ) THEN
C
C           Display summary in tabular format.
C
            TDSP  = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FGROUP ) THEN
C
C           Group summaries for objects with the same coverage
C
            GDSP  = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FREL ) THEN
C
C           Display names of base frames
C
            FDSP   = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FFNAME ) THEN
C
C           Display names of reference frames associated with CK IDs.
C
            NDSP = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FHELP ) THEN
C
C           Print the help.
C
            HELP   = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FVRSN ) THEN
C
C           Print the version.
C
            VRSN  = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FSFILE ) THEN
 
C
C           We have got a file containing names of the CK, LSK
C           or/and SCLK files.
C
            START  = END + 1
            CALL FNDNWD ( PASS1, START, BEG, END )
 
            IF ( BEG .GT. 0 ) THEN
               SFILE  = .TRUE.
               SRCFIL =  PASS1(BEG:END)
            ELSE
               END = START - 1
            END IF

         ELSE IF ( PASS1(BEG:END) .EQ. FUTC ) THEN
C
C           Display times as UTC times.
C
            TOUT = UTC
 
         ELSE IF ( PASS1(BEG:END) .EQ. FSCLK ) THEN
C
C           Display times as string SCLK times.
C
            TOUT = SCLK
 
         ELSE IF ( PASS1(BEG:END) .EQ. FDPCLK ) THEN
C
C           Display times as DP SCLK or SCLK ticks.
C
            TOUT = DPSCLK
 
         ELSE IF ( PASS1(BEG:END) .EQ. FDOY ) THEN
C
C           Display times as UTC/DOY times.
C
            TOUT = DOY
 
         ELSE IF ( PASS1(BEG:END) .EQ. FNOMRG ) THEN
C
C           Set "no-merge" flag.
C
            NOMERG = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FDUMP ) THEN
C
C           Set "dump-intervals" flag.
C
            IDUMP = .TRUE.
 
         ELSE IF ( PASS1(BEG:END) .EQ. FALL ) THEN
C
C           Set "treat-all-as-one" flag.
C
            DOALL = .TRUE.
 
         ELSE
C
C           Items that begin with '-' that are not one of the previous
C           cases are regarded as a request to summarize only for
C           particular items. This item must an integer, so we try to
C           parse it as integer. If we were successful, we add to the
C           integer array containing IDs "to restrict relative to" :)
C
            IF ( BEINT ( PASS1(BEG:END) ) ) THEN
 
               CALL NPARSI ( PASS1(BEG:END), VALUE, ERROR, PTR )
 
C
C              INSLAI is a great routine but it's our responsibility
C              to check whether our ID will fit into OBJLIS array.
C
               IF ( NUMOBJ .LT. MAXUSE ) THEN
 
C
C                 This ID will fit into our OBJLIS array, lets
C                 insert it there.
C
                  CALL INSLAI ( VALUE, 1, NUMOBJ+1, OBJLIS, NUMOBJ )
 
               ELSE
 
C
C                 There is no space for this ID in our array. Lets
C                 report about it.
C
                  CALL TOSTDO ( ' Object number ' )
                  CALL TOSTDO ( PASS1(BEG:END) )
                  CALL TOSTDO ( ' doesn''t fit into the buffer' )
                  CALL TOSTDO ( ' which can hold no more than' )
                  CALL TOSTDO ( ' MAXUSE elements.' )
 
               END IF
 
            ELSE
 
C
C              Unrecognized option specified.
C
               CALL TOSTDO( ' ' )
               HWORD = '''#'' is not a recognized option.'
               CALL REPMC ( HWORD, '#', PASS1(BEG:END), HWORD )
               CALL TOSTDO( HWORD )
               CALL TOSTDO( ' ' )
 
               HELP        = .TRUE.
 
            END IF
 
         END IF
 
C
C        Locate the next word.
C
         START = END + 1
         CALL FNDNWD ( PASS1, START, BEG, END )
 
      END DO
 
C
C     Handle any exceptions that might have been occurred. First,
C     display version if version key was the only one on the
C     command line.
C
      IF ( VRSN .AND. (.NOT. HAVFIL )
     .          .AND. (.NOT. SFILE )
     .          .AND. (.NOT. HELP ) ) THEN
 
         CALL TOSTDO( ' ' )
         STOP
 
      END IF
 
C
C     Display help only if it was requested or if we didn't get any
C     file names on the command line and we didn't get the name of a
C     file containing these names.
C
      HELP = HELP .OR. ( .NOT. ( HAVFIL .OR. SFILE ) )
 
      IF ( HELP ) THEN
 
         CALL TOSTDO( ' ' )
         DO I = 1, HLPSIZ
            CALL TOSTDO ( TEXT(I) )
         END DO
         CALL TOSTDO ( ' ' )
         STOP
 
      END IF
 
C
C     Reset contradicting flags. If interval dump was requested we
C     cannot do grouping (-g), filtering by object ID ([obj]), 
C     displaying of segment boundaries (-nm), or treating all as one
C     (-a).
C
      IF ( IDUMP ) THEN
         NOMERG = .FALSE.
         GDSP   = .FALSE.
         DOALL  = .FALSE.
         NUMOBJ = 0
      END IF
 
C
C     Now finish up determining what the user wants us to do. It is
C     necessary to process string PASS2 and file SRCFIL, if it was
C     provided, to check files the names of which provided and
C     load/process these files correspondingly.
C
C     User can provide 3 types of input files:
C
C      - LSK file(s);
C      - SCLK file(s);
C      - binary CK file(s).
C
C     First, let check if we have a file name provided using -f
C     command line flag
C
      IF ( SFILE ) THEN
 
         EOF = .FALSE.
 
         DO WHILE ( .NOT. EOF )
 
            CALL RDNBL ( SRCFIL, STRN, EOF )
 
            IF ( .NOT. EOF ) THEN
 
C
C              We need to check whether we have enough space in our
C              string to append another file name to it. If we do,
C              we append it. Other wise we report about it.
C
               IF ( RTRIM(STRN) + RTRIM(PASS2) .LT. CMDSIZ ) THEN
 
                  CALL SUFFIX ( STRN, 1, PASS2 )
                  HAVFIL = .TRUE.
 
               ELSE
 
                  HWORD = 'No space in the file name buffer for ' //
     .                    'the name ' //
     .                    '''#'' obtained from the input file ''#'''
                  CALL REPMC ( HWORD, '#', STRN, HWORD )
                  CALL REPMC ( HWORD, '#', SRCFIL, HWORD )
                  CALL TOSTDO( HWORD )
 
               END IF
 
            END IF
 
         END DO
 
      END IF
 
C
C     Start processing of the file names in string PASS2.
C
      IF ( HAVFIL ) THEN
 
         START  = 1
         CALL FNDNWD ( PASS2, START, BEG, END )
 
         DO WHILE ( BEG .GT. 0 )
 
            CALL GETFAT ( PASS2( BEG:END ), ARCH, TYPE )
 
            IF ( TYPE .EQ. CK .AND. ARCH .EQ. DAF ) THEN
 
C
C              We don't need to check whether we have enough space
C              in the PASS3 because PASS2 and PASS3 are of the same
C              size.
C
               CALL SUFFIX ( PASS2(BEG:END) , 1, PASS3 )
 
            ELSE IF ( ARCH .EQ. 'DAF' .AND. TYPE .EQ. 'SPK' ) THEN

C
C              Signal an error, reporting that this is a SPK file.
C
               CALL SETMSG ( 'Kernel ''#'' is a binary SPK and, '   //
     .                       'therefore, cannot be summarized '     //
     .                       'using CKBRIEF. Use BRIEF or '         //
     .                       'SPACIT to summarize this file.'       )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL SIGERR ( 'SPICE(SPKFILE)'                       )

            ELSE IF ( ARCH .EQ. 'DAF' .AND. TYPE .EQ. 'PCK' ) THEN

C
C              Signal an error, reporting that this is a PCK file.
C
               CALL SETMSG ( 'Kernel ''#'' is a binary PCK and, '   //
     .                       'therefore, cannot be summarized '     //
     .                       'using CKBRIEF. Use BRIEF or '         //
     .                       'SPACIT to summarize this file.'       )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL SIGERR ( 'SPICE(PCKFILE)'                       )

            ELSE IF ( ARCH .EQ. 'DAS' .AND. TYPE .EQ. 'EK' ) THEN

C
C              Signal an error, reporting that this is an EK file.
C
               CALL SETMSG ( 'Kernel ''#'' is a binary EK and, '    //
     .                       'therefore, cannot be summarized '     //
     .                       'using BRIEF. Use SPACIT or '          //
     .                       'INSPEKT to summarize this file.'      )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL SIGERR ( 'SPICE(EKFILE)'                        )

            ELSE IF ( ARCH .EQ. 'XFR' .OR. 
     .                ARCH .EQ. 'DEC'       ) THEN

C
C              Signal an error, reporting that this is a transfer file.
C
               CALL SETMSG ( 'Kernel ''#'' is in transfer format. ' //
     .                       'It must be converted to binary '      //
     .                       'format to be summarized using CKBRIEF.')
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL SIGERR ( 'SPICE(TRANSFERFORMAT)'                )

            ELSE IF ( ARCH .EQ. 'DAS' .OR. 
     .                ARCH .EQ. 'DAF' .OR.
     .                ARCH .EQ. 'TE1'      ) THEN

C
C              This is a ``catch all'' branch for all other kernels
C              that are not binary CKs. Signal an error, reporting that
C              this is a file with a wrong architecture and type.
C
               CALL SETMSG ( 'Kernel ''#'' is not a binary CK '     //
     .                       'and, therefore, cannot be '           //
     .                       'summarized using CKBRIEF. It is a '   //
     .                       '''#/#'' file.'                        )
               CALL ERRCH  ( '#',  PASS2(BEG:END)                   )
               CALL ERRCH  ( '#',  ARCH                             )
               CALL ERRCH  ( '#',  TYPE                             )
               CALL SIGERR ( 'SPICE(BADARCHITECTURE)'               )

            ELSE
 
C
C              This is probably a text kernel. To simplify our
C              lives we load this file into the kernel pool without
C              checking of what type this file is. If it's LSK or
C              SCLK, it's going to be processed just fine. If it's
C              something else, kernel pool subsystem won't find any
C              data in it ... it's just going to take a long time to
C              load if somebody provided the name of 20MB file :).
C
               CALL FURNSH ( PASS2(BEG:END) )
 
            END IF
 
            START = END + 1
            CALL FNDNWD ( PASS2, START, BEG, END )
 
         END DO
 
      END IF

C
C     See if any CKs were loaded via meta-kernels. If so, add them
C     to the list of CK files to be summarized.
C
      CALL KTOTAL( 'CK', FCOUNT )

      IF ( FCOUNT .NE. 0 ) THEN

         DO FINDEX = 1, FCOUNT

            CALL KDATA ( FINDEX, 'CK', 
     .                   STRN, FILTYP, SOURCE, HANDLE, FOUND )

            IF ( FOUND ) THEN

C
C              We need to check whether we have enough space in our
C              string to append another file name to it. If we do,
C              we append it. Otherwise we report about it.
C
               IF ( RTRIM(STRN) + RTRIM(PASS3) .LT. CMDSIZ ) THEN
 
                  CALL SUFFIX ( STRN, 1, PASS3 )
 
               ELSE
 
                  HWORD = 'No space in the file name buffer for ' //
     .                    'the name ''#'' obtained from the '     //
     .                    'meta-kernel(s).'
                  CALL REPMC ( HWORD, '#', STRN, HWORD )
                  CALL TOSTDO( HWORD )
 
               END IF

            END IF

         END DO

      END IF
 
C
C     Check whether at least one CK file was provided. If not,
C     complain about it.
C
      IF ( PASS3 .EQ. ' ' ) THEN
 
         CALL TOSTDO ( 'No CK files were provided -- no summary ' //
     .                 'will be displayed.'                       )
         CALL TOSTDO ( ' ' )
         CALL TOSTDO ( 'Run CKBRIEF without command line options ' //
     .                 'to see program usage.'                    )
         CALL TOSTDO ( ' ' )
         STOP
 
      END IF
 
C
C     Below is the main loop processing sequentially all CK-files those
C     names are stored in string PASS3. 
C
      START = 1
      CALL FNDNWD (PASS3, START, BEG, END )
 
      DO WHILE ( BEG .NE. 0  )

C
C        Were we asked to treat all CK files as one?
C
         IF ( .NOT. DOALL ) THEN

C
C           We were not asked to treat all files as one. So open the
C           next file and collect information from it.
C
            CALL DAFOPR ( PASS3(BEG:END), HANDLE )
            FNDSUM = .FALSE.
            CALL DAFBFS ( HANDLE )
            CALL DAFFNA ( FND    )
 
C
C           These arrays will hold summary data from segment
C           descriptors from the current CK file. At the end of
C           collection process these arrays will have the same size
C           equal to NOBJ:
C
C           IDA      contains IDs of object.
C           AVFA     contains AV flags.
C           FRAMEA   contains reference frame IDs
C           TYPEA    contains segment types
C           BADDRA   contains segment begin addresses
C           EADDRA   contains segment end addresses
C           TSTRTA   contains start time for the
C                    objects coverage.
C           TENDA    contains end time for the
C                    objects coverage.
C
            NOBJ = 1
 
            FULBUF = .FALSE.
 
            DO WHILE (FND)
 
               CALL DAFGS  (SEGSUM)
               CALL DAFUS  (SEGSUM, ND, NI, DC, IC)
 
C
C              If we are summarizing from a list of input object,
C              find out if this object is in the list to summarize.
C
               IF ( NUMOBJ .GT. 0 ) THEN
 
                  IF ( ISRCHI ( IC(1), NUMOBJ, OBJLIS ) .GT. 0 ) THEN
 
C
C                    We need to check whether we have space in the
C                    buffer. Note that we check against MAXBOD-1
C                    because we will use the element IDA(MAXBOD) as
C                    loop terminator flag further in the program.
C
                     IF ( NOBJ .LE. MAXBOD - 1 ) THEN
 
                        FNDSUM = .TRUE.
 
                        IDA   ( NOBJ ) = IC(1)
                        FRAMEA( NOBJ ) = IC(2)
                        TYPEA ( NOBJ ) = IC(3)
                        AVFA  ( NOBJ ) = IC(4)
                        BADDRA( NOBJ ) = IC(5)
                        EADDRA( NOBJ ) = IC(6)
                        TSTRTA( NOBJ ) = DC(1)
                        TENDA ( NOBJ ) = DC(2)
 
                        NOBJ = NOBJ + 1
 
                     ELSE
 
                        FULBUF = .TRUE.
 
                     END IF
 
                  END IF
 
               ELSE
 
C
C                 Same as above -- check whether we have space in the
C                 buffer. Note that we check against MAXBOD-1 because
C                 we will use the element IDA(MAXBOD) as loop
C                 terminator flag further in the program.
C
                  IF ( NOBJ .LE. MAXBOD - 1 ) THEN
 
                     FNDSUM = .TRUE.
 
                     IDA   ( NOBJ ) = IC(1)
                     FRAMEA( NOBJ ) = IC(2)
                     TYPEA ( NOBJ ) = IC(3)
                     AVFA  ( NOBJ ) = IC(4)
                     BADDRA( NOBJ ) = IC(5)
                     EADDRA( NOBJ ) = IC(6)
                     TSTRTA( NOBJ ) = DC(1)
                     TENDA ( NOBJ ) = DC(2)
 
                     NOBJ = NOBJ + 1
 
                  ELSE
 
                     FULBUF = .TRUE.
 
                  END IF
 
               END IF
C
C              Go to the next segment
C
               CALL DAFFNA ( FND )
 
            END DO
 
         ELSE

C
C           We were asked to treat all CK files as one. Collect
C           information from all of them in the same buffers.
C
            NOBJ = 1
            FULBUF = .FALSE.
            FNDSUM = .FALSE.

            DO WHILE ( BEG .NE. 0  )

C
C              Open the next CK file.
C
               CALL DAFOPR ( PASS3(BEG:END), HANDLE )
               CALL DAFBFS ( HANDLE )
               CALL DAFFNA ( FND    )
 
C
C              These arrays will hold summary data from segment
C              descriptors from all CK files. At the end of collection
C              process these arrays will have the same size equal to
C              NOBJ:
C
C              IDA      contains IDs of object.
C              AVFA     contains AV flags.
C              FRAMEA   contains reference frame IDs
C              TYPEA    contains segment types
C              BADDRA   contains segment begin addresses
C              EADDRA   contains segment end addresses
C              TSTRTA   contains start time for the
C                       objects coverage.
C              TENDA    contains end time for the
C                       objects coverage.
C
               DO WHILE (FND)
 
                  CALL DAFGS  (SEGSUM)
                  CALL DAFUS  (SEGSUM, ND, NI, DC, IC)
               
C
C                 If we are summarizing from a list of input object,
C                 find out if this object is in the list to summarize.
C
                  IF ( NUMOBJ .GT. 0 ) THEN
 
                     IF ( ISRCHI ( IC(1), NUMOBJ, OBJLIS ) .GT. 0 ) THEN
 
C
C                       We need to check whether we have space in the
C                       buffer. Note that we check against MAXBOD-1
C                       because we will use the element IDA(MAXBOD) as
C                       loop terminator flag further in the program.
C
                        IF ( NOBJ .LE. MAXBOD - 1 ) THEN
 
                           FNDSUM = .TRUE.
 
                           IDA   ( NOBJ ) = IC(1)
                           FRAMEA( NOBJ ) = IC(2)
                           TYPEA ( NOBJ ) = IC(3)
                           AVFA  ( NOBJ ) = IC(4)
                           BADDRA( NOBJ ) = IC(5)
                           EADDRA( NOBJ ) = IC(6)
                           TSTRTA( NOBJ ) = DC(1)
                           TENDA ( NOBJ ) = DC(2)
 
                           NOBJ = NOBJ + 1
 
                        ELSE
 
                           FULBUF = .TRUE.
 
                        END IF
 
                     END IF
 
                  ELSE
 
C
C                    Same as above -- check whether we have space in
C                    the buffer. Note that we check against MAXBOD-1
C                    because we will use the element IDA(MAXBOD) as
C                    loop terminator flag further in the program.
C
                     IF ( NOBJ .LE. MAXBOD - 1 ) THEN
 
                        FNDSUM = .TRUE.
                        
                        IDA   ( NOBJ ) = IC(1)
                        FRAMEA( NOBJ ) = IC(2)
                        TYPEA ( NOBJ ) = IC(3)
                        AVFA  ( NOBJ ) = IC(4)
                        BADDRA( NOBJ ) = IC(5)
                        EADDRA( NOBJ ) = IC(6)
                        TSTRTA( NOBJ ) = DC(1)
                        TENDA ( NOBJ ) = DC(2)
 
                        NOBJ = NOBJ + 1
 
                     ELSE
 
                        FULBUF = .TRUE.
 
                     END IF
 
                  END IF
C
C                 Go to the next segment
C
                  CALL DAFFNA ( FND )
 
               END DO

C
C              Current CK-file processing is over - close it and move
C              on to the next file.
C
               CALL DAFCLS (HANDLE)
 
               START = END + 1
 
               CALL FNDNWD (PASS3, START, BEG, END )
 
            END DO

C
C           We buffered information from all CKs. Re-open the first CK
C           to have a valid HANDLE (to make DAFCLS at the end of the
C           main loop happy). Reset the list of CKs to a generic phrase
C           "all CK files". Reset BEG and END to the beginning and end
C           character positions of this phrase. Setting END to the
C           last character will make the outer loop terminate.
C
            CALL FNDNWD ( PASS3, 1, BEG, END )
            CALL DAFOPR ( PASS3(BEG:END), HANDLE )

            PASS3 = 'all CK files'

            BEG = 1
            END = RTRIM(PASS3)
            
         END IF

C
C        The NOBJ is currently greater that the number of collected
C        objects by one. We need to fix this.
C
         NOBJ = NOBJ - 1
 
C
C        If any segment information was collected, display the name of
C        the file being summarized.
C
         IF ( NOBJ .NE. 0 ) THEN
 
C
C           First, check whether we had a buffer overflow. If yes,
C           signal an error. Do slightly different messages for 
C           all files and single file cases.
C
            IF ( .NOT. DOALL ) THEN

               IF ( FULBUF ) THEN
 
                  IF ( NUMOBJ .GT. 0 ) THEN
 
                     CALL SETMSG ( 'The number of segments containing'//
     .                             ' data for the specified IDs in '  //
     .                             'the CK file ''#'' was '           //
     .                             'greater than the program can '    //
     .                             'buffer (#). CKBRIEF cannot '      //
     .                             'summarize this file.'              )
                     CALL ERRCH  ( '#',  PASS3(BEG:END)                )
                     CALL ERRINT ( '#',  MAXBOD-1                      )
                     CALL SIGERR ( 'SPICE(BUFFEROVERRUN1)'             )
 
                  ELSE
 
                     CALL SETMSG ( 'The number of segments in '       //
     .                             'the CK file ''#'' was '           //
     .                             'greater than the program can '    //
     .                             'buffer (#). CKBRIEF cannot '      //
     .                             'summarize this file.'              )
                     CALL ERRCH  ( '#',  PASS3(BEG:END)                )
                     CALL ERRINT ( '#',  MAXBOD-1                      )
                     CALL SIGERR ( 'SPICE(BUFFEROVERRUN2)'             )
 
                  END IF
 
               END IF

            ELSE

               IF ( FULBUF ) THEN
 
                  IF ( NUMOBJ .GT. 0 ) THEN
 
                     CALL SETMSG ( 'The number of segments containing'//
     .                             ' data for the specified IDs in '  //
     .                             'all CK files was '                //
     .                             'greater than the program can '    //
     .                             'buffer (#).'                       )
                     CALL ERRINT ( '#',  MAXBOD-1                      )
                     CALL SIGERR ( 'SPICE(BUFFEROVERRUN3)'             )
 
                  ELSE
 
                     CALL SETMSG ( 'The number of segments in '       //
     .                             'all CK files was '                //
     .                             'greater than the program can '    //
     .                             'buffer (#).'                       )
                     CALL ERRINT ( '#',  MAXBOD-1                      )
                     CALL SIGERR ( 'SPICE(BUFFEROVERRUN4)'             )
 
                  END IF
 
               END IF

            END IF

C
C           No buffer overrun. Display the name of the file.
C
            CALL TOSTDO ( '  ' )
            CALL TOSTDO ( '  ' )
            CALL TOSTDO
     .        ( 'Summary for: '//PASS3(BEG:END) )

         ELSE

C
C           No segment data was collected. Report this fact.
C
            CALL TOSTDO ( '  ' )
            CALL TOSTDO ( '  ' )

            IF ( NUMOBJ .GT. 0 ) THEN
               CALL TOSTDO
     .              ( 'No data for specified objects in ' 
     .                // PASS3(BEG:END) )
            ELSE
               CALL TOSTDO
     .              ( 'No data segments in ' // PASS3(BEG:END) )
            END IF
 
         END IF
 
C
C        If we were asked to dump intervals, we have got everything
C        we need for displaying them. Otherwise, we have a lot of work
C        do.
C
         IF ( IDUMP ) THEN
 
C
C           All we need to do to dump intervals is to call Bills
C           ZZCKCRVs and copy output schedule to the buffers that
C           DISPSM expects. (BTW, if NOBJ is 0 this DO will never
C           DO :-)
C
            DO I = 1, NOBJ
 
C
C              Display segment order number.
C
               HWORD = 'Segment No.: #'
               CALL REPMI ( HWORD, '#', I, HWORD )
               CALL TOSTDO ( '  ' )
               CALL TOSTDO ( HWORD )
 
C
C              Does looking for interval for a segment of this
C              type make sense?
C
               IF ( ( TYPEA(I) .EQ. 2 ) .OR.
     .              ( TYPEA(I) .EQ. 3 ) .OR.
     .              ( TYPEA(I) .EQ. 4 ) .OR.
     .              ( TYPEA(I) .EQ. 5 ) .OR.
     .              ( TYPEA(I) .EQ. 6 )      ) THEN
 
C
C                 Sure does! Initialize window and call corresponding
C                 ZZCKCRVx depending on what type the segment is.
C
                  CALL SSIZED ( LRGWIN, WIND )
 
                  IF      ( TYPEA(I) .EQ. 2 ) THEN
 
                     CALL ZZCKCVR2 ( HANDLE, BADDRA(I), EADDRA(I), WIND)
 
                  ELSE IF ( TYPEA(I) .EQ. 3 ) THEN
 
                     CALL ZZCKCVR3 ( HANDLE, BADDRA(I), EADDRA(I), WIND)
 
                  ELSE IF ( TYPEA(I) .EQ. 4 ) THEN
 
                     CALL ZZCKCVR4 ( HANDLE, BADDRA(I), EADDRA(I), WIND)
 
                  ELSE IF ( TYPEA(I) .EQ. 5 ) THEN
 
                     CALL ZZCKCVR5 ( HANDLE, BADDRA(I), EADDRA(I), WIND)

                  ELSE IF ( TYPEA(I) .EQ. 6 ) THEN
C
C                    Set the SCLK ID to 0, since this input is unused.
C                    The lookup tolerance is zero; the time system is 
C                    SCLK.
C                    
                     DC(1) = TSTRTA(I)
                     DC(2) = TENDA(I)

                     CALL ZZCKCV06 ( HANDLE, BADDRA(I), EADDRA(I), 0,
     .                               DC,     0.D0,      'SCLK',    WIND)
 
                  END IF
 
C
C                 We fill have got a schedule for this segment. Copy
C                 it to buffers and call DISPSM.
C
                  IF ( CARDD ( WIND ) .NE. 0 ) THEN
 
                     NOBGS = CARDD ( WIND ) / 2
 
                     DO L = 0, NOBGS - 1
                        IDS    ( L + 1 ) = IDA    ( I )
                        TSTRTS ( L + 1 ) = WIND   ( L * 2 + 1 )
                        TENDS  ( L + 1 ) = WIND   ( L * 2 + 2 )
                        AVFS   ( L + 1 ) = AVFA   ( I )
                        FRAMES ( L + 1 ) = FRAMEA ( I )
                     END DO
 
                     CALL DISPSM ( NOBGS, IDS, TSTRTS, TENDS, AVFS,
     .                             FRAMES, TOUT, FDSP, TDSP, GDSP, NDSP)
 
                  END IF
 
               ELSE
 
C
C                 Well, this segment is not eligible for having
C                 intervals. Tell user about it.
C
                  HWORD = 'This segment is a type # segment for ' //
     .                    'which interpolation is not supported.'
                  CALL REPMI  ( HWORD, '#', TYPEA(I), HWORD )
                  CALL TOSTDO ( '  ' )
                  CALL TOSTDO ( HWORD )
 
               END IF
 
            END DO
 
         ELSE
 
C
C           We are here because we weren't asked to do interval dump
C           but were rather asked to do something intelligent (that
C           intelligent work is what CKRBIEF was written to do :-)
C
C           Data from all segment descriptors in the current file are
C           stored in arrays. Now it will be distributed to two
C           different groups of arrays.
C
C           First group - for objects which have multiple coverage
C           intervals in current CK-file.
C
C           Second group - for objects which have single coverage
C           interval in current CK-file.
C
C           This distribution is done to provide a possibility to merge
C           time intervals for a particular object if intervals
C           overlap.
C
C           Initialization of array pointers
C
            NOBGS = 1
            NOBGO = 1
            I = 1
 
C
C           Now we set IDA(NOBJ+1) to 0 we can safely do that because
C           we checked against MAXBOD-1 in the loop filling the
C           buffers.
C
            IDA( NOBJ + 1 ) = 0
 
C
C           Here is the cycle to get through all descriptors to
C           distribute them to two arrays.
C
            DO WHILE ( FNDSUM .AND. ( I .LE. NOBJ ) )
 
C
C              Skip all records with IDs set to zero -- these were
C              already taken into account.
C
               DO WHILE ( (IDA( I ) .EQ. 0) .AND. (I .LE. NOBJ ) )
                  I = I + 1
               END DO
 
               IF ( I .LE. NOBJ ) THEN
 
C
C                 Current segment is the first segment found for this
C                 ID in the buffer. Set counter of segments for current
C                 ID to 1 and copy complete summary for current segment
C                 to IDO, etc. buffers.
C
                  CNT = 1
 
                  IDO   ( NOBGO ) = IDA   ( I )
                  AVFO  ( NOBGO ) = AVFA  ( I )
                  FRAMEO( NOBGO ) = FRAMEA( I )
                  TSTRTO( NOBGO ) = TSTRTA( I )
                  TENDO ( NOBGO ) = TENDA ( I )
 
C
C                 Increase counter of segments for current ID and
C                 "mark" current segment as "processed" in IDA buffer
C                 by setting its IDA to zero.
C
                  NOBGO = NOBGO + 1
                  IDA( I ) = 0
 
C
C                 Loop to find all segments with the same ID in the IDA
C                 buffer.
C
                  LOC = ISRCHI(IDO( NOBGO - 1), NOBJ - I, IDA( I + 1 ))
                  K = LOC + I
 
                  DO WHILE ( LOC .NE. 0 )
 
C
C                    We found one more -- increase counter, save
C                    summary in IDO, etc. array and reset its IDS to 0.
C
                     CNT = CNT + 1
 
                     IDO   ( NOBGO ) = IDA   ( K )
                     AVFO  ( NOBGO ) = AVFA  ( K )
                     FRAMEO( NOBGO ) = FRAMEA( K )
                     TSTRTO( NOBGO ) = TSTRTA( K )
                     TENDO ( NOBGO ) = TENDA ( K )
 
                     NOBGO = NOBGO + 1
                     IDA( K ) = 0
 
                     LOC = ISRCHI( IDO(NOBGO-1), NOBJ-K, IDA(K + 1) )
                     K = K + LOC
 
                  END DO
 
C
C                 Did we find more than one segment for current ID?
C
                  IF ( CNT .EQ. 1 ) THEN
 
C
C                    No, we didn't. Then we include this segment into
C                    IDS buffer. But first we reset NOBGO back to
C                    remove it from IDO buffer.
C
                     NOBGO = NOBGO - 1
                     IDS   ( NOBGS ) = IDO   ( NOBGO )
                     AVFS  ( NOBGS ) = AVFO  ( NOBGO )
                     FRAMES( NOBGS ) = FRAMEO( NOBGO )
                     TSTRTS( NOBGS ) = TSTRTO( NOBGO )
                     TENDS ( NOBGS ) = TENDO ( NOBGO )
                     NOBGS = NOBGS + 1
 
 
                  END IF
 
               END IF
 
            END DO
 
            NOBGO = NOBGO - 1
 
C
C           At this point we have two buffers -- xxxO and xxxS --
C           filled with appropriate segment descriptors. There is no
C           need to do any more processing for xxxS buffer. But there
C           is work to be done on xxxO buffer: we need to merge
C           overlapping time intervals for each ID.
C
            IF ( NOBGO .GT. 1 ) THEN
 
               I = 1
               K = 1
 
               DO WHILE ( I .LE. NOBGO - 1)
 
C
C                 All segments for the same ID are already grouped
C                 together. We need to find out what is the first and
C                 last of them
C
                  DO WHILE (IDO(I) .EQ. IDO(K) .AND. K .LE. NOBGO )
                     K = K + 1
                  END DO
 
C
C                 After we know it, we copy start and stop times to
C                 a WINDOW array.
C
                  CALL SSIZED ( LRGWIN, WIND )
                  CALL SCARDD ( ( K - I ) * 2, WIND )
 
                  DO L = 0, K - I - 1
                     WIND( L * 2 + 1 ) = TSTRTO( L + I )
                     WIND( L * 2 + 2 ) = TENDO( L + I )
                  END DO
 
C
C                 Here is important point of algorithm. We'll validate
C                 window of time intervals. But we do it only if NOMERG
C                 flag is not set.
C
                  IF ( .NOT. NOMERG ) THEN
                     CALL WNVALD (LRGWIN, ( K - I ) * 2, WIND )
                  END IF
 
C
C                 Now we can check whether our window validating
C                 brought any results.
C
                  IF ( CARDD ( WIND ) .EQ. ( K - I ) * 2 ) THEN
 
C
C                    Nothing happened with our windows. Well, the best
C                    we can do then is to order coverages for this ID
C                    by start time (and this order in xxxO all arrays.)
C
                     CALL ORDERD ( TSTRTO(I), K - I, IORDER )
 
                     CALL REORDD ( IORDER, K - I, TSTRTO(I) )
                     CALL REORDD ( IORDER, K - I, TENDO(I)  )
                     CALL REORDI ( IORDER, K - I, AVFO(I)   )
                     CALL REORDI ( IORDER, K - I, FRAMEO(I) )
 
C
C                    Now we can copy sorted data back to xxxS buffer.
C
                     CALL MOVEI ( IDO(I),    K-I, IDS(NOBGS)    )
                     CALL MOVED ( TSTRTO(I), K-I, TSTRTS(NOBGS) )
                     CALL MOVED ( TENDO(I),  K-I, TENDS(NOBGS)  )
                     CALL MOVEI ( AVFO(I),   K-I, AVFS(NOBGS)   )
                     CALL MOVEI ( FRAMEO(I), K-I, FRAMES(NOBGS) )
                     NOBGS = NOBGS + K - I
 
                  ELSE
 
C
C                    Some of the windows got merged. It means that by
C                    validating we broke connection between them and
C                    AVFS and FRAMES for the original segments. And
C                    what if original segments used in window
C                    validating had a different AV flags of were
C                    relative to different frames? We have to check
C                    that and assign right values to indicate this --
C                    set AVS to 2 and FRAMES to 0.
C
                     MIXDAV = .FALSE.
                     MIXDFR = .FALSE.
                     L = I
 
                     DO WHILE( L .LT. (K - 1) )
 
                        IF ( AVFO(L) .NE. AVFO(L+1) ) THEN
                           MIXDAV = .TRUE.
                        END IF
 
                        IF ( FRAMEO(L) .NE. FRAMEO(L+1) ) THEN
                           MIXDFR = .TRUE.
                        END IF
 
                        L = L + 1
 
                     END DO
 
C
C                    If we had mixed AV flags, we set all AVFO to 2.
C
                     IF ( MIXDAV ) THEN
                        DO L = I, K - 1
                           AVFO( L ) = 2
                        END DO
                     END IF
 
C
C                    If we had mixed reference frames, we set all
C                    FRAMEO to 0.
C
                     IF ( MIXDFR ) THEN
                        DO L = I, K - 1
                           FRAMEO( L ) = 0
                        END DO
                     END IF
 
C
C                    What if after validation we have only 1 time
C                    interval? Then data for the object have to be
C                    moved from array for multiple intervals to array
C                    for single intervals.
C
                     IF ( CARDD ( WIND ) .EQ. 2 ) THEN
 
C
C                       Copy summaries to IDS, etc. arrays.
C
                        IDS   ( NOBGS ) = IDO   ( I )
                        AVFS  ( NOBGS ) = AVFO  ( I )
                        FRAMES( NOBGS ) = FRAMEO( I )
                        TSTRTS( NOBGS ) = WIND  ( 1 )
                        TENDS ( NOBGS ) = WIND  ( 2 )
 
C
C                       Increment number of elements in AVS, etc.
C                       arrays.
C
                        NOBGS = NOBGS + 1
 
                     ELSE
 
C
C                       It looks like we have more than one interval.
C
                        DO L = 0, CARDD ( WIND ) / 2 - 1
                           TEMPS( L + 1 ) = WIND( L * 2 + 1 )
                           TEMPE( L + 1 ) = WIND( L * 2 + 2 )
                        END DO
 
                        L = CARDD ( WIND ) / 2
C
C                       Copy objects with multiple time intervals to
C                       xxxS buffer.
C
                        CALL MOVEI ( IDO(I),    L, IDS(NOBGS)    )
                        CALL MOVED ( TEMPS,     L, TSTRTS(NOBGS) )
                        CALL MOVED ( TEMPE,     L, TENDS(NOBGS)  )
                        CALL MOVEI ( AVFO(I),   L, AVFS(NOBGS)   )
                        CALL MOVEI ( FRAMEO(I), L, FRAMES(NOBGS) )
                        NOBGS = NOBGS + L
 
                     END IF
 
                  END IF
 
C
C                 We are done with current ID. Lets move to the next
C                 one.
C
                  I = K
 
               END DO
 
            END IF
 
C
C           OK, we are done with processing of the xxxO buffer. All
C           data sorted/merged and stored in a single buffer -- xxxS.
C           Lets display summary then ....
C
            NOBGS = NOBGS - 1
            IF ( NOBGS .NE. 0 ) THEN
 
               CALL DISPSM (NOBGS, IDS, TSTRTS, TENDS, AVFS, FRAMES,
     .                      TOUT, FDSP, TDSP, GDSP, NDSP )
 
            END IF
 
         END IF
 
C
C        Current CK-file processing is over - close it and move on to
C        the next file.
C
         CALL DAFCLS (HANDLE)
 
         START = END + 1
 
         CALL FNDNWD (PASS3, START, BEG, END )
 
      END DO
 
C
C     Add one more blank line at the end of the summary report.
C
      CALL TOSTDO( ' ' )
 
C
C     Check out.
C
      CALL CHKOUT  ( 'CKBRIEF' )

C
C     Return with success status.
C
      CALL BYEBYE( 'SUCCESS' )

      STOP
      END
