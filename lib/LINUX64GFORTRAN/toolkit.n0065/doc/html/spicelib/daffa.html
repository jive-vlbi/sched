
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>daffa</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>daffa</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
 DAFFA ( DAF, find array )

      SUBROUTINE DAFFA ( HANDLE, SUM, NAME, FOUND )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Find arrays in a DAF.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/daf.html">DAF</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     FILES
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
      INCLUDE              'zzddhman.inc'

      INTEGER               TBSIZE
      PARAMETER           ( TBSIZE = FTSIZE )

      INTEGER               HANDLE
      DOUBLE PRECISION      SUM    ( * )
      CHARACTER*(*)         NAME
      LOGICAL               FOUND
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Entry
     --------  ---  --------------------------------------------------
     HANDLE    I,O  <a href="dafbfs.html">DAFBFS</a>, <a href="dafbbs.html">DAFBBS</a>, <a href="dafgh.html">DAFGH</a>, <a href="dafcs.html">DAFCS</a>
     SUM       I,O  <a href="dafgs.html">DAFGS</a>,  <a href="dafrs.html">DAFRS</a>,  <a href="dafws.html">DAFWS</a>
     NAME      I,O  <a href="dafgn.html">DAFGN</a>,  <a href="dafrn.html">DAFRN</a>
     FOUND      O   <a href="daffna.html">DAFFNA</a>, <a href="daffpa.html">DAFFPA</a>
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     HANDLE      on input is the handle of the DAF to be searched.

     SUM         on input is an array summary that replaces the
                 summary of the current array in the DAF currently
                 being searched.

     NAME        on input is an array name that replaces the name
                 of the current array in the DAF currently being
                 searched.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     HANDLE      on output is the handle of the DAF currently being
                 searched.

     SUM         on output is the summary for the array found most
                 recently.

     NAME        on output is the name for the array found
                 most recently.

     FOUND       is true whenever the search for the next or the
                 previous array is successful, and is false otherwise.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     TBSIZE      the maximum number of files (DAS and DAF) that may be
                 simultaneously open. TBSIZE is set to FTSIZE which is
                 assigned and defined in zzdhman.inc.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1) If <b>DAFFA</b> is called directly, the error SPICE(BOGUSENTRY)
        is signaled.

     2) See entry points <a href="dafbfs.html">DAFBFS</a>, <a href="daffna.html">DAFFNA</a>, <a href="dafbbs.html">DAFBBS</a>, <a href="daffpa.html">DAFFPA</a>, <a href="dafgs.html">DAFGS</a>, <a href="dafgn.html">DAFGN</a>,
        <a href="dafgh.html">DAFGH</a>, <a href="dafrs.html">DAFRS</a>, <a href="dafws.html">DAFWS</a>, <a href="dafrn.html">DAFRN</a>, and <a href="dafcs.html">DAFCS</a> for exceptions specific
        to those entry points.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     DAFs read by <b>DAFFA</b> and its entry points are opened
     elsewhere, and referred to only by their handles.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     <b>DAFFA</b> serves as an umbrella, allowing data to be shared by its
     entry points:

        <a href="dafbfs.html">DAFBFS</a>         Begin forward search.
        <a href="daffna.html">DAFFNA</a>         Find next array.

        <a href="dafbbs.html">DAFBBS</a>         Begin backward search.
        <a href="daffpa.html">DAFFPA</a>         Find previous array.

        <a href="dafgs.html">DAFGS</a>          Get summary.
        <a href="dafgn.html">DAFGN</a>          Get name.
        <a href="dafgh.html">DAFGH</a>          Get handle.

        <a href="dafrs.html">DAFRS</a>          Replace summary.
        <a href="dafws.html">DAFWS</a>          Write summary.
        <a href="dafrn.html">DAFRN</a>          Replace name.

        <a href="dafcs.html">DAFCS</a>          Continue search.

     The main function of these entry points is to allow the
     contents of any DAF to be examined on an array-by-array
     basis.

     Conceptually, the arrays in a DAF form a doubly linked list,
     which can be searched in either of two directions: forward or
     backward. It is possible to search multiple DAFs simultaneously.

     <a href="dafbfs.html">DAFBFS</a> (begin forward search) and <a href="daffna.html">DAFFNA</a> are used to search the
     arrays in a DAF in forward order. In applications that search a
     single DAF at a time, the normal usage is

        CALL <a href="dafbfs.html">DAFBFS</a> ( HANDLE )
        CALL <a href="daffna.html">DAFFNA</a> ( FOUND  )

        DO WHILE ( FOUND )
           CALL <a href="dafgs.html">DAFGS</a> ( SUM  )
           CALL <a href="dafgn.html">DAFGN</a> ( NAME )
            .
            .

           CALL <a href="daffna.html">DAFFNA</a> ( FOUND )
        END DO



     <a href="dafbbs.html">DAFBBS</a> (begin backward search) and <a href="daffpa.html">DAFFPA</a> are used to search the
     arrays in a DAF in backward order. In applications that search
     a single DAF at a time, the normal usage is

        CALL <a href="dafbbs.html">DAFBBS</a> ( HANDLE )
        CALL <a href="daffpa.html">DAFFPA</a> ( FOUND  )

        DO WHILE ( FOUND )
           CALL <a href="dafgs.html">DAFGS</a> ( SUM  )
           CALL <a href="dafgn.html">DAFGN</a> ( NAME )
            .
            .

           CALL <a href="daffpa.html">DAFFPA</a> ( FOUND )
        END DO


     In applications that conduct multiple searches simultaneously,
     the above usage must be modified to specify the handle of the
     file to operate on, in any case where the file may not be the
     last one specified by <a href="dafbfs.html">DAFBFS</a> or <a href="dafbbs.html">DAFBBS</a>. The routine <a href="dafcs.html">DAFCS</a>
     (DAF, continue search) is used for this purpose. Below, we
     give an example of an interleaved search of two files specified
     by the handles HANDL1 and HANDL2. The directions of searches
     in different DAFs are independent; here we conduct a forward
     search on one file and a backward search on the other.
     Throughout, we use <a href="dafcs.html">DAFCS</a> to specify which file to operate on,
     before calling <a href="daffna.html">DAFFNA</a>, <a href="daffpa.html">DAFFPA</a>, <a href="dafgs.html">DAFGS</a>, <a href="dafrs.html">DAFRS</a>, <a href="dafws.html">DAFWS</a>, <a href="dafgn.html">DAFGN</a>, or
     <a href="dafrn.html">DAFRN</a>.


        CALL <a href="dafbfs.html">DAFBFS</a> ( HANDL1 )
        CALL <a href="dafbbs.html">DAFBBS</a> ( HANDL2 )

        CALL <a href="dafcs.html">DAFCS</a>  ( HANDL1 )
        CALL <a href="daffna.html">DAFFNA</a> ( FOUND1 )

        CALL <a href="dafcs.html">DAFCS</a>  ( HANDL2 )
        CALL <a href="daffpa.html">DAFFPA</a> ( FOUND2 )

        DO WHILE ( FOUND1 .OR. FOUND2 )

           IF ( FOUND1 ) THEN

              CALL <a href="dafcs.html">DAFCS</a> ( HANDL1 )
              CALL <a href="dafgs.html">DAFGS</a> ( SUM    )
              CALL <a href="dafgn.html">DAFGN</a> ( NAME   )
               .
               .
              CALL <a href="dafcs.html">DAFCS</a>  ( HANDL1 )
              CALL <a href="daffna.html">DAFFNA</a> ( FOUND1 )

           END IF

           IF ( FOUND2 ) THEN

              CALL <a href="dafcs.html">DAFCS</a> ( HANDL2 )
              CALL <a href="dafgs.html">DAFGS</a> ( SUM    )
              CALL <a href="dafgn.html">DAFGN</a> ( NAME   )
               .
               .
              CALL <a href="dafcs.html">DAFCS</a>  ( HANDL2 )
              CALL <a href="daffpa.html">DAFFPA</a> ( FOUND2 )

           END IF

        END DO


     At any time, the latest array found (whether by <a href="daffna.html">DAFFNA</a> or <a href="daffpa.html">DAFFPA</a>)
     is regarded as the `current' array for the file in which the
     array was found. The last DAF in which a search was started,
     executed, or continued by any of <a href="dafbfs.html">DAFBFS</a>, <a href="dafbbs.html">DAFBBS</a>, <a href="daffna.html">DAFFNA</a>, <a href="daffpa.html">DAFFPA</a>
     or <a href="dafcs.html">DAFCS</a> is regarded as the `current' DAF. The summary and name
     for the current array in the current DAF can be returned
     separately, as shown above, by calls to <a href="dafgs.html">DAFGS</a> (get summary) and
     <a href="dafgn.html">DAFGN</a> (get name). The handle of the current DAF can also be
     returned by calling <a href="dafgh.html">DAFGH</a> (get handle).

     The summary and name of the current array in the current DAF can
     be updated (again, separately) by providing new ones through <a href="dafrs.html">DAFRS</a>
     (replace summary) and <a href="dafrn.html">DAFRN</a> (replace name). This feature
     should not be used except to correct errors that occurred during
     the creation of a file. Note that changes can only be made to
     files opened for write access. Also, the addresses of an array
     cannot be changed using these routines. (Another routine,
     <a href="dafws.html">DAFWS</a>, is provided for this purpose, but should be used only
     to reorder the arrays in a file.)

     Once a search has been begun, it may be continued in either
     direction. That is, <a href="daffpa.html">DAFFPA</a> may be used to back up during a
     forward search, and <a href="daffna.html">DAFFNA</a> may be used to advance during a
     backward search.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     1) The following code fragment illustrates the way the entry
        points of <b>DAFFA</b> might be used to edit the summaries and names
        for the arrays contained in a DAF. (All subroutines and
        functions are from SPICELIB.)

        In this example, the user begins by supplying the name of
        the file to be edited, followed by any number of the following
        commands.

           NEXT      finds the next array.

           PREV      finds the previous array.

           EDIT      changes the value of an item in the summary or
                     of the entire name. The keyword EDIT is
                     always followed by the name of the item to be
                     edited,

                        DC n
                        IC n
                        NAME

                     and the value, e.g.,

                        EDIT IC 2 315
                        EDIT NAME NAIF test K2905-1

        The user may terminate the session at any time by typing END.
        Commands other than those listed above are ignored.

           READ (*,FMT='(A)') FNAME
           CALL <a href="dafopw.html">DAFOPW</a> ( FNAME, HANDLE )
           CALL <a href="dafbfs.html">DAFBFS</a> ( HANDLE )

           READ (*,FMT='(A)') COMMAND

           DO WHILE ( COMMAND .NE. 'END' )
              CALL <a href="nextwd.html">NEXTWD</a> ( COMMAND, VERB, COMMAND )

              IF ( VERB .EQ. 'NEXT' ) THEN
                 CALL <a href="daffna.html">DAFFNA</a> ( FOUND )
                 IF ( .NOT. FOUND ) THEN
                    WRITE (*,*) 'At end of array list.'
                 END IF

              IF ( VERB .EQ. 'PREV' ) THEN
                 CALL <a href="daffpa.html">DAFFPA</a> ( FOUND )
                 IF ( .NOT. FOUND ) THEN
                    WRITE (*,*) 'At beginning of array list.'
                 END IF

              IF ( VERB .EQ. 'EDIT' ) THEN
                 CALL <a href="dafgs.html">DAFGS</a> ( SUM )
                 CALL <a href="dafgn.html">DAFGN</a> ( NAME )
                 CALL <a href="dafus.html">DAFUS</a> ( SUM, ND, NI, DC, IC )

                 CALL <a href="nextwd.html">NEXTWD</a> ( COMMAND, ITEM, VALUE )

                 IF ( ITEM .EQ. 'DC' ) THEN
                    CALL <a href="nextwd.html">NEXTWD</a> ( VALUE, INDEX, VALUE )
                    CALL <a href="nparsi.html">NPARSI</a> ( INDEX, LOC,     ERR, PTR )
                    CALL <a href="nparsd.html">NPARSD</a> ( VALUE, DC(LOC), ERR, PTR )

                 ELSE IF ( ITEM .EQ. 'IC' ) THEN
                    CALL <a href="nextwd.html">NEXTWD</a> ( VALUE, INDEX, VALUE )
                    CALL <a href="nparsi.html">NPARSI</a> ( INDEX, LOC,     ERR, PTR )
                    CALL <a href="nparsi.html">NPARSI</a> ( VALUE, IC(LOC), ERR, PTR )

                 ELSE IF ( ITEM .EQ. 'NAME' ) THEN
                    NAME = VALUE
                 END IF

                 CALL <a href="dafps.html">DAFPS</a> ( ND, NI, DC, IC, SUM )
                 CALL <a href="dafrs.html">DAFRS</a> ( SUM )
                 CALL <a href="dafrn.html">DAFRN</a> ( NAME )
              END IF

              READ (*,FMT='(A)') COMMAND
           END DO


     2)  The following program compares data in two DAFs. The DAFs are
         expected to have the same number of arrays, the same number
         of elements in each corresponding array, and the same summary
         format.

         Each difference whose magnitude exceeds a specified tolerance
         is flagged. The difference information is written to a file.


                  PROGRAM CMPDAF

            C
            C     Compare data in two DAFs having identical structures.
            C     No array in either DAF is longer than ARRYSZ d.p.
            C     numbers.
            C

            C
            C     Local parameters
            C
                  INTEGER               ARRYSZ
                  PARAMETER           ( ARRYSZ = 1000 )

                  INTEGER               ERRLEN
                  PARAMETER           ( ERRLEN =  240 )

                  INTEGER               FILEN
                  PARAMETER           ( FILEN  =  128 )

                  INTEGER               LINLEN
                  PARAMETER           ( LINLEN =   80 )

                  INTEGER               MAXND
                  PARAMETER           ( MAXND  =  125 )

                  INTEGER               MAXNI
                  PARAMETER           ( MAXNI  =  250 )

                  INTEGER               MAXSUM
                  PARAMETER           ( MAXSUM =  128 )

                  INTEGER               RLEN
                  PARAMETER           ( RLEN   = 1000 )


            C
            C     Local variables
            C
                  CHARACTER*(RLEN)      ANAME1
                  CHARACTER*(RLEN)      ANAME2
                  CHARACTER*(FILEN)     DAF1
                  CHARACTER*(FILEN)     DAF2
                  CHARACTER*(FILEN)     LOG
                  CHARACTER*(ERRLEN)    PRSERR
                  CHARACTER*(LINLEN)    STR
                  CHARACTER*(LINLEN)    TOLCH

                  DOUBLE PRECISION      ARRAY1 ( ARRYSZ )
                  DOUBLE PRECISION      ARRAY2 ( ARRYSZ )
                  DOUBLE PRECISION      DC1    ( MAXND )
                  DOUBLE PRECISION      DC2    ( MAXND )
                  DOUBLE PRECISION      TOL
                  DOUBLE PRECISION      DIFF
                  DOUBLE PRECISION      SUM1   ( MAXSUM )
                  DOUBLE PRECISION      SUM2   ( MAXSUM )

                  INTEGER               FA1
                  INTEGER               FA2
                  INTEGER               I
                  INTEGER               IA1
                  INTEGER               IA2
                  INTEGER               IC1    ( MAXNI )
                  INTEGER               IC2    ( MAXNI )
                  INTEGER               FA
                  INTEGER               HANDL1
                  INTEGER               HANDL2
                  INTEGER               LEN1
                  INTEGER               LEN2
                  INTEGER               ND1
                  INTEGER               ND2
                  INTEGER               NI1
                  INTEGER               NI2
                  INTEGER               PTR

                  LOGICAL               FOUND

            C
            C     Start out by obtaining the names of the DAFs to be
            C     compared.
            C
                  WRITE (*,*) 'Enter name of first DAF.'
                  READ  (*,FMT='(A)') DAF1

                  WRITE (*,*) 'Enter name of second DAF.'
                  READ  (*,FMT='(A)') DAF2

                  WRITE (*,*) 'Enter name of log file.'
                  READ  (*,FMT='(A)') LOG

                  WRITE (*,*) 'Enter tolerance for data comparison.'
                  READ  (*,FMT='(A)') TOLCH

                  CALL <a href="nparsd.html">NPARSD</a> ( TOLCH, TOL, PRSERR, PTR )

                  DO WHILE ( PRSERR .NE. ' ' )

                     WRITE (*,*) PRSERR
                     WRITE (*,*) 'Enter tolerance for data comparison.'
                     READ  (*,FMT='(A)') TOLCH

                     CALL <a href="nparsd.html">NPARSD</a> ( TOLCH, TOL, PRSERR, PTR )

                  END DO

            C
            C     Open both DAFs for reading.
            C
                  CALL <a href="dafopr.html">DAFOPR</a> ( DAF1, HANDL1 )
                  CALL <a href="dafopr.html">DAFOPR</a> ( DAF2, HANDL2 )

            C
            C     Start forward searches in both DAFS.
            C
                  CALL <a href="dafbfs.html">DAFBFS</a> ( HANDL1 )
                  CALL <a href="dafbfs.html">DAFBFS</a> ( HANDL2 )

            C
            C     Obtain the summary formats for each DAF. Stop now
            C     if the summary formats don't match.
            C
                  CALL <a href="dafhsf.html">DAFHSF</a> ( HANDL1, ND1, NI1 )
                  CALL <a href="dafhsf.html">DAFHSF</a> ( HANDL2, ND2, NI2 )

                  IF (  ( ND1 .NE. ND2 ) .OR. ( NI1 .NE. NI2 )  ) THEN

                     STR = 'Summary formats do not match.  NI1 = #, '//
                 .                      'NI2 = #, ND1 = #, ND2 = #.'

                     CALL <a href="repmi.html">REPMI</a>  ( STR, '#', NI1, STR )
                     CALL <a href="repmi.html">REPMI</a>  ( STR, '#', NI2, STR )
                     CALL <a href="repmi.html">REPMI</a>  ( STR, '#', ND1, STR )
                     CALL <a href="repmi.html">REPMI</a>  ( STR, '#', ND2, STR )

                     CALL WRLINE ( LOG,  STR )

                     CALL <a href="sigerr.html">SIGERR</a> ( 'Incompatible DAFs' )

                  END IF

            C
            C     Find the first array in each DAF. Use <a href="dafcs.html">DAFCS</a>
            C     (DAF, continue search) to set the handle of the DAF
            C     to search in before calling <a href="daffna.html">DAFFNA</a>.
            C
                  CALL <a href="dafcs.html">DAFCS</a>  ( HANDL1 )
                  CALL <a href="daffna.html">DAFFNA</a> ( FOUND  )

                  IF ( FOUND ) THEN
                     CALL <a href="dafcs.html">DAFCS</a>  ( HANDL2 )
                     CALL <a href="daffna.html">DAFFNA</a> ( FOUND  )
                  END IF

                  DO WHILE ( FOUND )

            C
            C        Get the summary and name of each array, using
            C        <a href="dafcs.html">DAFCS</a> to select the DAF to get the information
            C        from. Unpack the summaries and find the beginning
            C        and ending addresses of the arrays. Read the
            C        arrays into the variables ARRAY1 and ARRAY2.
            C
                     CALL <a href="dafcs.html">DAFCS</a> ( HANDL1 )
                     CALL <a href="dafgn.html">DAFGN</a> ( ANAME1 )
                     CALL <a href="dafgs.html">DAFGS</a> ( SUM1   )
                     CALL <a href="dafus.html">DAFUS</a> ( SUM1, ND1, NI1, DC1, IC1 )

                     IA1  = IC1 ( NI1 - 1 )
                     FA1  = IC1 ( NI1     )
                     LEN1 = FA1 - IA1  + 1

                     IF (  LEN1  .GT.  ARRYSZ  ) THEN
                        CALL <a href="setmsg.html">SETMSG</a> ( 'Buffer too small; need # elts.')
                        CALL <a href="errint.html">ERRINT</a> ( '#', LEN1                       )
                        CALL <a href="sigerr.html">SIGERR</a> ( 'ARRAYTOOSMALL'                 )
                     ELSE
                        CALL <a href="dafrda.html">DAFRDA</a> ( HANDL1, IA1, FA1, ARRAY1 )
                     END IF

                     CALL <a href="dafcs.html">DAFCS</a> ( HANDL2 )
                     CALL <a href="dafgn.html">DAFGN</a> ( ANAME2 )
                     CALL <a href="dafgs.html">DAFGS</a> ( SUM2   )
                     CALL <a href="dafus.html">DAFUS</a> ( SUM2, ND2, NI2, DC2, IC2 )

                     IA2 = IC2 ( NI2 - 1 )
                     FA2 = IC2 ( NI2     )

                     LEN2 = FA2 - IA2  + 1

                     IF (  LEN1  .GT.  ARRYSZ  ) THEN

                        CALL <a href="setmsg.html">SETMSG</a> ( 'Buffer too small; need # elts.')
                        CALL <a href="errint.html">ERRINT</a> ( '#', LEN2                       )
                        CALL <a href="sigerr.html">SIGERR</a> ( 'ARRAYTOOSMALL'                 )

                     ELSE IF ( LEN1 .NE. LEN2 ) THEN

                        CALL <a href="setmsg.html">SETMSG</a> ( 'DAF structures do not match. '//
                    .                 'LEN1 = #, LEN2 = #. ' )
                        CALL <a href="errint.html">ERRINT</a> ( '#', LEN1              )
                        CALL <a href="errint.html">ERRINT</a> ( '#', LEN2              )
                        CALL <a href="sigerr.html">SIGERR</a> ( 'Incompatible DAFs' )

                     ELSE
                        CALL <a href="dafrda.html">DAFRDA</a> ( HANDL2, IA2, FA2, ARRAY2 )
                     END IF
            C
            C
            C        Compare the data in the two arrays. Log a message
            C        for every instance of data that differs by more
            C        than the allowed tolerance. Use the array names
            C        to label the data sources.
            C
                     DO I = 1, LEN1

                        DIFF  =  ABS( ARRAY1(I) - ARRAY2(I) )

                        IF (  DIFF  .GT.  TOL  ) THEN
            C
            C              Get the array names.
            C
                           CALL <a href="dafcs.html">DAFCS</a> ( HANDL1 )
                           CALL <a href="dafgn.html">DAFGN</a> ( ANAME1 )
                           CALL <a href="dafcs.html">DAFCS</a> ( HANDL2 )
                           CALL <a href="dafgn.html">DAFGN</a> ( ANAME2 )

            C
            C              Construct the report strings. The number 14
            C              below is the number of significant digits to
            C              show in the strings representing d.p.
            C              numbers.
            C

                           CALL WRLINE ( LOG, ' ' )
                           CALL WRLINE ( LOG, 'Difference of array ' //
                    .                         'elements exceeded '   //
                    .                         'tolerance.'            )
                           CALL WRLINE ( LOG, 'First array:  '//ANAME1)
                           CALL WRLINE ( LOG, 'Second array: '//ANAME2)

                           STR = 'First value:  #'
                           CALL <a href="repmd.html">REPMD</a>  ( STR, '#', ARRAY1(I), 14, STR )
                           CALL WRLINE ( LOG, STR                     )

                           STR = 'Second value: #'
                           CALL <a href="repmd.html">REPMD</a>  ( STR, '#', ARRAY2(I), 14, STR )
                           CALL WRLINE ( LOG, STR                     )

                           STR = 'Difference:   #'
                           CALL <a href="repmd.html">REPMD</a>  ( STR, '#', DIFF,      14, STR )
                           CALL WRLINE ( LOG, STR                     )
                           CALL WRLINE ( LOG, ' '                     )

                        END IF

                     END DO

            C
            C        Find the next pair of arrays.
            C
                     CALL <a href="dafcs.html">DAFCS</a>  ( HANDL1 )
                     CALL <a href="daffna.html">DAFFNA</a> ( FOUND  )

                     IF ( FOUND ) THEN
                        CALL <a href="dafcs.html">DAFCS</a>  ( HANDL2 )
                        CALL <a href="daffna.html">DAFFNA</a> ( FOUND  )
                     END IF

                  END DO

            C
            C     Close the DAFs.
            C
                  CALL <a href="dafcls.html">DAFCLS</a> ( HANDL1 )
                  CALL <a href="dafcls.html">DAFCLS</a> ( HANDL2 )

                  END
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman    (JPL)
     W.L. Taber      (JPL)
     I.M. Underwood  (JPL)
     E.D. Wright     (JPL)
     B.V. Semenov    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 3.1.0, 10-FEB-2014 (EDW) (BVS)

        Added a functional code example to the Examples section
        in <a href="dafbfs.html">DAFBFS</a>, <a href="daffna.html">DAFFNA</a>, <a href="dafgs.html">DAFGS</a>.

        Added check on value of &quot;found&quot; boolean returned from
        <a href="dafgsr.html">DAFGSR</a> calls. Failure to check this value can cause an
        infinite loop during segment searches on damaged SPKs.

        Eliminated unneeded Revisions section.

        Removed the obsolete Reference citation to &quot;NAIF
        Document 167.0.&quot;

        Added full declaration of HANDLE to the Declarations section
        of the <a href="dafcs.html">DAFCS</a> header.

    SPICELIB Version 3.0.0, 16-NOV-2001 (FST)

        This umbrella and its entry points were updated to
        work properly with the changes in the DAF system as
        a result of its utilization of the new handle manager.
        Calls to <a href="dafrdr.html">DAFRDR</a> were replaced with the translation-aware
        interface <a href="dafgsr.html">DAFGSR</a> for retrieving summary records from
        DAFs.

        Updated the entry points of <b>DAFFA</b> to enable its
        internal state table size, TBSIZE, to be smaller
        than the file table maintained by <a href="dafah.html">DAFAH</a>: FTSIZE.

        Since <a href="dafah.html">DAFAH</a> now tracks FTSIZE files as defined in
        the include file 'zzddhman.inc', it was decided that
        in the interest of releasing the toolkit this module
        would undergo simple changes. As such most previous
        references to FTSIZE in this umbrella have been replaced
        with TBSIZE where appropriate. <a href="dafbfs.html">DAFBFS</a> and <a href="dafbbs.html">DAFBBS</a> now signal
        errors if there is not enough room to add a new DAF's
        dossier to the state table. Also, after attempting to
        clean up all files listed in the state table that are
        not currently open, <a href="dafbfs.html">DAFBFS</a> and <a href="dafbbs.html">DAFBBS</a> attempt to locate
        the first dossier with STADDG set to FALSE. This is then
        freed to make room for the new DAF. If <a href="dafbna.html">DAFBNA</a> fails
        to locate such a dossier in the state table, it
        signals the error SPICE(STFULL).

        The parameter FILEN was removed, as it is defined
        on an environmental basis in the include file
        'zzddhman.inc'.

    SPICELIB Version 2.0.1, 10-MAR-1992 (WLT)

        Comment section for permuted index source lines was added
        following the header.

    SPICELIB Version 2.0.0, 04-SEP-1991 (NJB) (WLT)

        Updated to support simultaneous searches of multiple DAFs.

        In previous versions of <b>DAFFA</b>, only one search could be
        conducted at a time. Therefore, there was no question about
        which DAF was being operated on by any of the <b>DAFFA</b> entry
        points that don't accept file handles as input arguments.
        In the current version of <b>DAFFA</b>, the entry points that don't
        accept file handles as inputs operate on the `current DAF'.
        The current DAF is the last one in which a search was
        started by <a href="dafbfs.html">DAFBFS</a> or <a href="dafbbs.html">DAFBBS</a>, or continued by the new entry
        point <a href="dafcs.html">DAFCS</a>. <a href="dafcs.html">DAFCS</a> was added to allow users to set the
        current DAF, so that searches of multiple DAFs can be
        interleaved.

        Note that the notion of `current DAF' as discussed here applies
        only to DAFs acted upon by entry points of <b>DAFFA</b>. In <a href="dafana.html">DAFANA</a>,
        there is a DAF that is treated as the `current DAF' for
        adding data; there is no connection between the DAFs regarded
        as current by <b>DAFFA</b> and <a href="dafana.html">DAFANA</a>.

        The two principal changes to <b>DAFFA</b> are the addition of the
        new entry point <a href="dafcs.html">DAFCS</a>, and the addition of a data structure
        called the `state table'. The state table is a collection of
        parallel arrays that maintain information about the state
        of each search that is currently in progress. The arrays are
        indexed by a singly linked list pool; this mechanism allows
        addition and deletion of information about searches without
        requiring movement of data already in the state table. The
        linked list pool contains an `active' list and a `free' list.
        Nodes in the active list are used to index elements of the
        state table where data about searches in progress is stored.
        The head node of the active list is of particular significance:
        the state information pointed to by this node is that of the
        current DAF. Nodes in the free list index elements of the
        state table that are available for use.

        When a search is started on a DAF that is not already `known'
        to <b>DAFFA</b>, information about the DAF is added to the state
        table. If there are no free elements in the state table,
        the routine starting the search (<a href="dafbfs.html">DAFBFS</a> or <a href="dafbbs.html">DAFBBS</a>) will
        perform garbage collection:  the routine will test the handles
        of each file about which information in stored in the state
        table to see whether that file is still open. Nodes containing
        information about DAFs that are no longer open will be moved
        to the free list.

        Whenever a DAF becomes the current DAF, the linked list
        that indexes the state table is adjusted so that the
        information about the current DAF is at the head of the list.
        This way, a slight efficiency is gained when repeated search
        accesses are made to the same DAF, since the linear search
        through the state table for information on that DAF will
        be shortened.

        Since the algorithms for maintenance of linked lists are well
        known, they are not documented here. However, see the
        internals of the SPICELIB routine <a href="spkbsr.html">SPKBSR</a> for a nice diagram
        describing a similar data structure.

        The state table contains two arrays that are quite large:
        there are buffers that contain the last character record
        and summary record read from each DAF. A parallel situation
        exists in <a href="dafana.html">DAFANA</a>, where the name and array summary for each
        array under construction are buffered. The total storage
        required for these arrays (in <a href="dafana.html">DAFANA</a> and <b>DAFFA</b> together) is
        4000 * TBSIZE bytes. For this reason, it may be a good idea
        to reduce the value of TBSIZE in SPICELIB versions for
        machines where memory is scarce.

    SPICELIB Version 1.0.1, 22-MAR-1990 (HAN)

        Literature references added to the header.

    SPICELIB Version 1.0.0, 31-JAN-1990 (IMU)</PRE>
<h4>Link to routine DAFFA source file <a href='../../../src/spicelib/daffa.f'>daffa.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:03 2014</pre>

</body>
</html>

