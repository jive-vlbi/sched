
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>lstlei</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>lstlei</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   LSTLEI ( Last integer element less than or equal to )
 
      INTEGER FUNCTION  LSTLEI ( X, N, ARRAY )
 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
      Given a number X and an array of non-decreasing numbers,
      find the index of the largest array element less than or equal
      to X.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
      SEARCH,  ARRAY
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
 
      INTEGER          X
      INTEGER          N
      INTEGER          ARRAY ( * )
 
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
      VARIABLE  I/O  DESCRIPTION
      --------  ---  --------------------------------------------------
      X          I   Value to search against.
      ARRAY      I   Array of possible lower bounds.
      N          I   Number elements in ARRAY.
      <b>LSTLEI</b>     O   the index of the last element of ARRAY &lt;= X.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
      X       Integer for which one desires to find
              the last ARRAY element less than or equal to X.

      ARRAY   Array of integers that forms a
              non-decreasing sequence.  We will find the last element
              of the sequence that is less than or equal to X.

      N       Total number of elements in ARRAY
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
      <b>LSTLEI</b>  Index of the last element of the non-decreasing sequence:
              {ARRAY(I) : 0 &lt; I &lt; N + 1} that is less than or equal
              to X. (Note that <b>LSTLEI</b> = I for some I in the range 1 to
              N  unless X is less than all of these elements in which
              case <b>LSTLEI</b> = 0.)

              In the case that N is input with value less than or equal
              to zero, <b>LSTLEI</b> is returned as zero.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
      None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     Error free.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
      None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
      An array of integers is given.  The array
      ARRAY(I) (0 &lt; I &lt; N ) forms a non-decreasing sequence of
      numbers.  Given a real number X, there will be a last one of
      these numbers that is less than or equal to X.  This routine
      finds the index <b>LSTLEI</b> such that ARRAY(<b>LSTLEI</b>) is that number.

      If X is not greater than ARRAY(1), INDEX will be set to zero.

      This routine uses a binary search algorithm and so requires
      at most LOG_2(N) steps to find the value of <b>LSTLEI</b>.

      Note:  If you need to find the first element of the array that
             is greater than X, simply add 1 to the result returned
             by this function and check to see if the result is
             within the array bounds given by N.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     Suppose that you have an reasonably large ordered array of
     integers, into which you want to insert a few more without
     destroying the ordering.

     Depending upon your application, it may be desirable to
     not insert duplicates, to insert duplicates before
     existing entries or to insert them after existing entries.

     The code fragment below, illustrates an insertion scheme
     that will insert duplicate items after existing items
     and simultaneously update a second parallel array of
     double precision numbers.

           get the pair to insert

           READ (*,*) KEY, VALUE

           locate the place to insert the new KEY into the sorted
           array of keys.

           LOC = <b>LSTLEI</b> ( KEY, NKEYS, KEYS ) + 1

           insert the key and its associated value into the
           KEYS and  VALUES arrays at location LOC

           CALL <a href="inslai.html">INSLAI</a> ( KEY,   1, LOC, NKEYS, KEYS   )
           CALL <a href="inslad.html">INSLAD</a> ( VALUE, 1, LOC, NVALS, VALUES )

     If at the READ statement the arrays KEYS and VALUES looked like:

           KEYS     VALUES     NKEYS = 6, NVALS = 6
           ----     -------
             2       3.00D0
             5       1.00D0
             7       3.14D0
            16       7.11D0
            18       2.14D0
            23      12.12D0

     and 9 and 33.33D3 were read into KEY and VALUE respectively
     then <b>LSTLEI</b> (KEY, NKEYS, KEYS ) would be 3 and LOC would be 4.
     After the calls to the routines <a href="inslai.html">INSLAI</a> and <a href="inslad.html">INSLAD</a> we would have

           KEYS     VALUES     NKEYS = 7, NVALS = 7
           ----     -------
             2       3.00D0
             5       1.00D0
             7       3.14D0
             9      33.33D3     &lt;===== inserted items.
            16       7.11D0
            18       2.14D0
            23      12.12D0

     If 7 and 33.33D3 were read into KEY and VALUE respectively
     then again <b>LSTLEI</b> (KEY, NKEYS, KEYS ) would be 3 and LOC would
     be 4. After the calls to the routines <a href="inslai.html">INSLAI</a> and <a href="inslad.html">INSLAD</a> we
     would have:

           KEYS     VALUES     NKEYS = 7, NVALS = 7
           ----     -------
             2       3.00D0
             5       1.00D0
             7       3.14D0
             7      33.33D3     &lt;===== inserted items.
            16       7.11D0
            18       2.14D0
            23      12.12D0

     If we replaced the line of code

           LOC = <b>LSTLEI</b> ( KEY, NKEYS, KEYS ) + 1
     by

           LOC = <a href="lstlti.html">LSTLTI</a> ( KEY, NKEYS, KEYS ) + 1

     we would obtain a routine that inserted duplicates before
     existing entries. (<a href="lstlti.html">LSTLTI</a> is similar to <b>LSTLEI</b> except it finds
     the last occurrance of an integer strictly less than a value.)
     Using 7 and 33.33D3 for KEY and VALUE again, the modified code
     fragment would yield the results shown below.

           KEYS     VALUES     NKEYS = 7, NVALS = 7
           ----     -------
             2       3.00D0
             5       1.00D0
             7      33.33D3     &lt;===== inserted items.
             7       3.14D0
            16       7.11D0
            18       2.14D0
            23      12.12D0


     (Note: you should NOT use the
     code outlined above as the basis of a sorting algorithm.
     The NAIF routines <a href="shelli.html">SHELLI</a>, <a href="shelld.html">SHELLD</a>, <a href="shellc.html">SHELLC</a>, <a href="orderi.html">ORDERI</a>, <a href="orderd.html">ORDERD</a>, <a href="orderc.html">ORDERC</a>,
     <a href="reordi.html">REORDI</a>, <a href="reordd.html">REORDD</a> and <a href="reordc.html">REORDC</a> are much more efficient routines for
     sorting arrays or sorting a set of parallel arrays using
     one of the set as a key. The fragment presented here is useful
     for performing update insertions into previously ordered arrays.)

     For more ideas regarding the use of this routine, see <a href="lstlec.html">LSTLEC</a>
     and <a href="lstltc.html">LSTLTC</a>.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
      If the sequence does not non-decreasing, the program will run
      to completion but the index found will not mean anything.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
      None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
      H.A. Neilan     (JPL)
      W.L. Taber      (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.1, 10-MAR-1992 (WLT)

        Comment section for permuted index source lines was added
        following the header.

    SPICELIB Version 1.0.0, 31-JAN-1990 (WLT)</PRE>
<h4>Link to routine LSTLEI source file <a href='../../../src/spicelib/lstlei.f'>lstlei.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:35 2014</pre>

</body>
</html>

