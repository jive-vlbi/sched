
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>readla</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>readla</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Examples">Examples<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   READLA   ( Read array of lines from a logical unit )
 
      SUBROUTINE READLA ( UNIT, MAXLIN, NUMLIN, ARRAY, EOF )
 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     This routine reads lines from a Fortran logical unit placing
     them into a character array buffer.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     UTILITY
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
 
      INTEGER               UNIT
      INTEGER               MAXLIN
      INTEGER               NUMLIN
      CHARACTER*(*)         ARRAY(*)
      LOGICAL               EOF
 
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     Variable  I/O  Description
     --------  ---  --------------------------------------------------
      UNIT      I    Fortran unit number to use for input.
      MAXLIN    I    Maximum number of lines ARRAY can hold.
      NUMLIN    O    Number of lines read from the file.
      ARRAY     O    Array containing the lines read from the file.
      EOF       O    Logical flag indicating the end of file.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     UNIT     The Fortran unit number for the input. This may
              be either the unit number for the terminal, or the
              unit number of a previously opened text file.

     MAXLIN   The maximum number of text lines that can be placed
              into the ARRAY.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     NUMLIN   The number of text lines read from the file attached to
              UNIT and placed into ARRAY. 0 &lt;= NUMLIN &lt;= MAXLIN.

              In the event of an error while attempting to read a line
              from the text file attached to UNIT, NUMLIN will contain
              the number of lines successfully read before the error
              occurred.

     ARRAY    The array which is to contain the lines of text read from
              the text file attached to UNIT.

              If an error or the end of file occurs while reading
              from the text file attached to UNIT, this array will
              contain the NUMLIN successfully read lines ARRAY(1)
              through ARRAY(NUMLIN).

     EOF      On output, this variable will be set to .TRUE. if the
              end of file ( IOSTAT &lt; 0 ) is encountered during an
              attempt to read from UNIT. Otherwise, this variable
              will be set to .FALSE..
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1)   If the maximum number of lines, MAXLIN, is not positive, the
          error SPICE(INVALIDARGUMENT) will be signalled.

     2)   If an error occurs while attempting to read from the text
          file attached to unit, a routine called by this routine will
          detect and signal the error.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     See the description of UNIT above.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     This routine reads lines of text from a file, placing each line
     into an element of a character string array.

     An end of file flag will have the value .TRUE. if the end of file
     is reached while reading. If the file contains more lines than the
     character string array ARRAY can hold, as specified by the
     argument MAXLIN, the routine will return and the end of file flag
     will have the value .FALSE., indicating that there are more lines
     of text that may be read from the file.

     Upon successful completion, the variable NUMLIN will contain the
     number of lines of text placed into the character string array.
     This value may be zero.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     For the examples which follow, assume that we have a file named
     'mary.txt' which contains the following lines of text:

        &lt;BOF&gt;
        Mary had a little lamb
        Whose fleece was white as snow
        And every where that Mary went
        The lamb was sure to go
        &lt;EOF&gt;

     where

        &lt;BOF&gt; marks the beginning of the file
        &lt;EOF&gt; marks the end of the file

     For each example, assume that we have opened the file 'mary.txt',
     obtaining the Fortran logical unit TXTLUN, and that we are
     positioned to begin reading at the beginning of the file, '&lt;BOF&gt;'.

     For brevity, none of the examples perform any error handling
     functions: they simply assume that everything will work.

     Example 1: ARRAY is large enough to contain the entire contents of
                the file.

        CHARACTER*(80)        ARRAY(10)

        INTEGER               NUMLIN

        LOGICAL               EOF

        CALL <b>READLA</b> ( TXTLUN, 10, NUMLIN, ARRAY, EOF )

     At this point the output variables NUMLIN, ARRAY, and EOF have
     the following values:

        NUMLIN   = 4

        ARRAY(1) = 'Mary had a little lamb'
        ARRAY(2) = 'Whose fleece was white as snow'
        ARRAY(3) = 'And every where that Mary went'
        ARRAY(4) = 'The lamb was sure to go'

        EOF      = .TRUE.

     Example 2: ARRAY is not large enough to contain the entire
                contents of the file -- perform multiple reads.

        CHARACTER*(80)        ARRAY(3)

        INTEGER               NUMLIN

        LOGICAL               EOF

        EOF = .FALSE.
        DO WHILE ( .NOT. EOF )

           CALL <b>READLA</b> ( TXTLUN, 3, NUMLIN, ARRAY, EOF )

        END DO

     Because the line buffer ARRAY may contain at most 3 lines and the
     file contains 4 lines, the loop calling <b>READLA</b> will be executed
     twice, terminating after the second call because EOF will be
     true.

     After the first call to <b>READLA</b> the output variables NUMLIN, ARRAY,
     and EOF have the following values:

        NUMLIN   = 3

        ARRAY(1) = 'Mary had a little lamb'
        ARRAY(2) = 'Whose fleece was white as snow'
        ARRAY(3) = 'And every where that Mary went'

        EOF      = .FALSE.

     After the second call to <b>READLA</b> the output variables NUMLIN,
     ARRAY, and EOF have the following values:

        NUMLIN   = 1

        ARRAY(1) = 'The lamb was sure to go'

        EOF      = .TRUE.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     K.R. Gehringer (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB     1.0.0, 20-DEC-1995 (KRG)

        The routine graduated

    Beta Version 3.0.0, 9-JAN-1995 (KRG)

        Added examples to the header.

        Fixed some problems with the variable descriptions in the
        $ Detailed_Input and $ Detailed_Output sections of the header.

        Rearranged some of the code to be more aesthetically pleasing.

    Beta Version 2.0.0, 05-JAN-1995 (KRG)

        This routine now participates fully with the SPICELIB error
        handler, checking in on entry and checking out on exit. The
        overhead associated with the error handler should not be
        significant relative to the operation of this routine.

        Moved the test for the end of file outside of the loop. There
        is no need to test for it every time in the loop, because we
        only do it to decrement the number of lines read by one to
        account for the pre-increment befor the READ that set the end
        of file.

        Added a local variable MYEOF so that a value of the variable
        EOF does not affect the termination of the read loop.

    Beta Version 1.0.0, 18-DEC-1992 (KRG)</PRE>
<h4>Link to routine READLA source file <a href='../../../src/spicelib/readla.f'>readla.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:24:48 2014</pre>

</body>
</html>

